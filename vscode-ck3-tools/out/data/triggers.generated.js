"use strict";
/**
 * CK3 Trigger Definitions (Auto-generated)
 *
 * Triggers are conditions that evaluate to true/false.
 * Each trigger has a list of scopes where it can be used.
 *
 * Source: OldEnt repository (version 1.10.2)
 * Total triggers: 1268
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.triggersMap = exports.allTriggers = exports.generalTriggers = exports.artifactTriggers = exports.activityTriggers = exports.warTriggers = exports.schemeTriggers = exports.armyTriggers = exports.religionTriggers = exports.faithTriggers = exports.cultureTriggers = exports.dynastyhouseTriggers = exports.dynastyTriggers = exports.provinceTriggers = exports.landedtitleTriggers = exports.characterTriggers = void 0;
exports.getTriggersForScope = getTriggersForScope;
/**
 * Triggers for character scope (718 triggers)
 */
exports.characterTriggers = [
    { name: 'any_killed_character', description: 'Iterate through all kills of a character', supportedScopes: ['character', 'artifact'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_killed_character = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'age', description: 'Get character age: scope:character = { age > 16 }', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'ai_boldness', description: 'AI boldness', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'ai_compassion', description: 'AI compassion', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'ai_diplomacy_stance', description: 'The AI\'s diplomatic view of the target character', supportedScopes: ['character'], syntax: "ai_diplomacy_stance = {\ntarget = target_character\nstance = neutral/threat/enemy/friend\n}" },
    { name: 'ai_energy', description: 'AI energy', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'ai_greed', description: 'AI greed', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'ai_honor', description: 'AI honor', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'ai_rationality', description: 'AI rationality', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'ai_sociability', description: 'AI sociability', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'ai_values_divergence', description: 'target = other character value >/</= sum of differences in ai values', supportedScopes: ['character'] },
    { name: 'ai_vengefulness', description: 'AI vengefulness', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'ai_zeal', description: 'AI zeal', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'all_court_artifact_slots', description: 'check if all the scoped characters court artifact slots are empty or full', supportedScopes: ['character'] },
    { name: 'all_inventory_artifact_slots', description: 'check if all the scoped characters inventory artifact slots are empty or full', supportedScopes: ['character'] },
    { name: 'allowed_concubines', description: 'Can the scope owner have concubines?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'allowed_more_concubines', description: 'Can the scope owner have more concubines?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'allowed_more_spouses', description: 'Can the scope owner have more spouses?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'amenity_level', description: 'amenity_level = { type = food value >= 5 }', supportedScopes: ['character'], valueType: 'comparison', syntax: "Compares the scoped character's amenity level in the given type to the given value" },
    { name: 'any_acclaimed_knight', description: 'Iterate through all acclaimed knights employed by a given character', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_acclaimed_knight = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_accolade', description: 'Iterate through all ( active and inactive ) Accolades of a given liege character\'s Acclaimed Knights', supportedScopes: ['character'], supportedTargets: ['accolade'], outputScope: 'accolade', isIterator: true, valueType: 'block', syntax: "any_accolade = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_active_accolade', description: 'Iterate through all active Accolades of a given liege character\'s Acclaimed Knights', supportedScopes: ['character'], supportedTargets: ['accolade'], outputScope: 'accolade', isIterator: true, valueType: 'block', syntax: "any_active_accolade = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_alert_creatable_title', description: 'Iterate through all titles that can be created by the character. (only for alerts)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_alert_creatable_title = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_alert_usurpable_title', description: 'Iterate through all titles that can be usurped by the character. (only for alerts)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_alert_usurpable_title = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_ally', description: 'Iterate through all allies', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_ally = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_ancestor', description: 'Iterate through all the ancestors of the scope character up to 5 generations', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_ancestor = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_army', description: 'Iterate through all armies', supportedScopes: ['character'], supportedTargets: ['army'], outputScope: 'army', isIterator: true, valueType: 'block', syntax: "any_army = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_character_artifact', description: 'Iterate through all artifacts in a given characters inventory', supportedScopes: ['character'], supportedTargets: ['artifact'], outputScope: 'artifact', isIterator: true, valueType: 'block', syntax: "any_character_artifact = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_character_struggle', description: 'Iterate through all struggles that character is involved in. Optional: Narrow down the involvement status *_chracter_struggle = { involvement = involved | interloper }', supportedScopes: ['character'], supportedTargets: ['struggle'], outputScope: 'struggle', isIterator: true, valueType: 'block', syntax: "any_character_struggle = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_character_to_title_neighboring_and_across_water_county', description: 'Scopes from a character to a neighboring county (incl. across water, looking trough the de Jure lieges)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_character_to_title_neighboring_and_across_water_county = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_character_to_title_neighboring_and_across_water_duchy', description: 'Scopes from a character to a neighboring duchy (incl. across water, looking trough the de Jure lieges)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_character_to_title_neighboring_and_across_water_duchy = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_character_to_title_neighboring_and_across_water_empire', description: 'Scopes from a character to a neighboring empire (incl. across water, looking trough the de Jure lieges)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_character_to_title_neighboring_and_across_water_empire = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_character_to_title_neighboring_and_across_water_kingdom', description: 'Scopes from a character to a neighboring kingdom (incl. across water, looking trough the de Jure lieges)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_character_to_title_neighboring_and_across_water_kingdom = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_character_to_title_neighboring_county', description: 'Scopes from a character to a neighboring county (looking trough the de Jure lieges)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_character_to_title_neighboring_county = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_character_to_title_neighboring_duchy', description: 'Scopes from a character to a neighboring duchy (looking trough the de Jure lieges)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_character_to_title_neighboring_duchy = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_character_to_title_neighboring_empire', description: 'Scopes from a character to a neighboring empire (looking trough the de Jure lieges)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_character_to_title_neighboring_empire = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_character_to_title_neighboring_kingdom', description: 'Scopes from a character to a neighboring kingdom (looking trough the de Jure lieges)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_character_to_title_neighboring_kingdom = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_character_trait', description: 'Iterate through all traits a character has', supportedScopes: ['character'], supportedTargets: ['trait'], outputScope: 'trait', isIterator: true, valueType: 'block', syntax: "any_character_trait = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_character_war', description: 'Wars of the scoped character', supportedScopes: ['character'], supportedTargets: ['war'], outputScope: 'war', isIterator: true, valueType: 'block', syntax: "any_character_war = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_child', description: 'Iterate through all children', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_child = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_claim', description: 'Iterate through the titles of all claims held by a character; parameters: explicit = yes/no/all pressed = yes/no/all', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_claim = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_claimed_artifact', description: 'Iterate through all claimed artifacts of the scoped character', supportedScopes: ['character'], supportedTargets: ['artifact'], outputScope: 'artifact', isIterator: true, valueType: 'block', syntax: "any_claimed_artifact = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_close_family_member', description: 'Iterate through all the close family [father, mother, siblings, children, grandparents]', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_close_family_member = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_close_or_extended_family_member', description: 'Iterate through all the close and extended relatives [father, mother, siblings, children, grandparents, uncles/aunts, nephew/niece, cousins]', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_close_or_extended_family_member = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_concubine', description: 'Iterate through all concubines', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_concubine = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_consort', description: 'Iterate through all consorts (concubines and spouses)', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_consort = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_councillor', description: 'Iterate through all councillors', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_councillor = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_court_position_employer', description: 'Iterates through all characters that employ the scoped character in any court position.', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_court_position_employer = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_court_position_holder', description: 'Iterates through all characters employed by the scoped character in the target court position.', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_court_position_holder = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_courtier', description: 'Iterate through all courtiers', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_courtier = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_courtier_away', description: 'Iterate through all courtiers that are away', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_courtier_away = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_courtier_or_guest', description: 'Iterate through all courtiers and guests (pool and foreign court guests)', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_courtier_or_guest = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_de_jure_claim', description: 'Iterate through all de jure claims for a character', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_de_jure_claim = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_diarchy_succession_character', description: 'Iterate through all character in the diarchy line of succession.If there\'s no active diarchy or active one doesn\'t have succession,it iterates over regency candidates', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_diarchy_succession_character = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_diplomacy_councillor', description: 'Iterate through all diplomacy-based councillors', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_diplomacy_councillor = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_directly_owned_province', description: 'Iterate through all directly owned provinces', supportedScopes: ['character'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, valueType: 'block', syntax: "any_directly_owned_province = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_election_title', description: 'Iterate through all titles the scoped character can vote on', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_election_title = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_equipped_character_artifact', description: 'Iterate through all equipped artifacts in a given characters inventory', supportedScopes: ['character'], supportedTargets: ['artifact'], outputScope: 'artifact', isIterator: true, valueType: 'block', syntax: "any_equipped_character_artifact = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_extended_family_member', description: 'Iterate through all the extended family [uncles/aunts, nephew/niece, cousins]', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_extended_family_member = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_foreign_court_guest', description: 'Iterate through all guests visiting from another court (in contrast to pool_guest they have a liege)', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_foreign_court_guest = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_former_concubine', description: 'Iterate through all former concubines. Not persisted past death', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_former_concubine = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_former_concubinist', description: 'Iterate through all former concubinists. Not persisted past death', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_former_concubinist = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_former_spouse', description: 'Iterate through all former spouses', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_former_spouse = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_general_councillor', description: 'Iterate through all councillors that are not related to a skill', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_general_councillor = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_heir', description: 'Heirs of the scoped character', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_heir = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_heir_title', description: 'Iterate through all landed titles character is heir to', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_heir_title = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_heir_to_title', description: 'Iterate through all titles the scoped character is heir to', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_heir_to_title = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_held_title', description: 'Iterate through all held landed titles', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_held_title = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_hired_mercenary', description: 'Iterate through all hired mercenary companies', supportedScopes: ['character'], supportedTargets: ['mercenary_company'], outputScope: 'mercenary_company', isIterator: true, valueType: 'block', syntax: "any_hired_mercenary = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_home_court_hostage', description: 'Iterate through all hostages currently abroad', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_home_court_hostage = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_hooked_character', description: 'Iterate through all characters this character has a hook on', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_hooked_character = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_hostile_raider', description: 'Iterate through anyone the character is hostile to due to their top-liege\'s realm having been raided', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_hostile_raider = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_intrigue_councillor', description: 'Iterate through all intrigue-based councillors', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_intrigue_councillor = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_invited_activity', description: 'Iterate through all activities a character has been invited to', supportedScopes: ['character'], supportedTargets: ['activity'], outputScope: 'activity', isIterator: true, valueType: 'block', syntax: "any_invited_activity = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_knight', description: 'Iterate through all knights', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_knight = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_known_secret', description: 'Iterate through all secrets known by the character', supportedScopes: ['character'], supportedTargets: ['secret'], outputScope: 'secret', isIterator: true, valueType: 'block', syntax: "any_known_secret = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_learning_councillor', description: 'Iterate through all learning-based councillors', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_learning_councillor = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_liege_or_above', description: 'Iterate through all lieges above a character (skipping the character themselves)', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_liege_or_above = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_martial_councillor', description: 'Iterate through all martial-based councillors', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_martial_councillor = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_memory', description: 'Iterate through all memories of a character', supportedScopes: ['character'], supportedTargets: ['character_memory'], outputScope: 'character_memory', isIterator: true, valueType: 'block', syntax: "any_memory = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_neighboring_and_across_water_realm_same_rank_owner', description: 'A sub-realm or realm bordering the scope character\'s realm (including across water) and has the same rank as the scope character (look for lieges of he owner of the land if necessary)', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_neighboring_and_across_water_realm_same_rank_owner = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_neighboring_and_across_water_top_liege_realm', description: 'A realm with a different top liege neighboring the realm of the scope character\'s top liege (including across water); switches to the realm\'s top title. Can be based on borders a day or two out of date', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_neighboring_and_across_water_top_liege_realm = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_neighboring_and_across_water_top_liege_realm_owner', description: 'A realm with a different top liege neighboring the realm of the scope character\'s top liege (including across water); switches to the holder of the realm. Can be based on borders a day or two out of date', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_neighboring_and_across_water_top_liege_realm_owner = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_neighboring_realm_same_rank_owner', description: 'A sub-realm or realm bordering the scope character\'s realm and has the same rank as the scope character (look for lieges of he owner of the land if necessary)', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_neighboring_realm_same_rank_owner = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_neighboring_top_liege_realm', description: 'A realm with a different top liege neighboring the realm of the scope character\'s top liege; switches to the realm\'s top title. Can be based on borders a day or two out of date', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_neighboring_top_liege_realm = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_neighboring_top_liege_realm_owner', description: 'A realm with a different top liege neighboring the realm of the scope character\'s top liege; switches to the holder of the realm. Can be based on borders a day or two out of date', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_neighboring_top_liege_realm_owner = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_opposite_sex_spouse_candidate', description: 'Iterate through all the spouse candidates of the opposite sex of a character.', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "WARNING: THIS IS VERY SLOW DO NOT DO IT OFTEN.\nany_opposite_sex_spouse_candidate = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_owned_story', description: 'Iterate through all owned stories for a character', supportedScopes: ['character'], supportedTargets: ['story'], outputScope: 'story', isIterator: true, valueType: 'block', syntax: "any_owned_story = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_parent', description: 'Iterate through all (both) parents', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_parent = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_patroned_holy_order', description: 'Iterate through all holy orders that the scoped character is a patron of', supportedScopes: ['character'], supportedTargets: ['holy_order'], outputScope: 'holy_order', isIterator: true, valueType: 'block', syntax: "any_patroned_holy_order = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_personal_claimed_artifact', description: 'Iterate through all personally claimed artifacts of the scoped character', supportedScopes: ['character'], supportedTargets: ['artifact'], outputScope: 'artifact', isIterator: true, valueType: 'block', syntax: "any_personal_claimed_artifact = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_pinned_character', description: 'Iterate through characters this player has pinned', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_pinned_character = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_pinning_character', description: 'Iterate through characters whose player has this character pinned', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_pinning_character = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_played_character', description: 'Iterate through all characters the player playing this character has played. Matches the game over legacy, except for excluding the currently played character', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_played_character = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_player_heir', description: 'Iterate through player heirs, capped at the first 10', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_player_heir = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_pool_guest', description: 'Iterate through all guests visiting the court from the pool (in contrast to foreign_court_guest they don\'t have a liege)', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_pool_guest = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_potential_marriage_option', description: 'Iterate through all potential selectable marriage or betrohed options', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_potential_marriage_option = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_powerful_vassal', description: 'Iterate through the all powerful vassals of a character', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_powerful_vassal = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_pretender_title', description: 'Iterate through all landed titles character is pretender to', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_pretender_title = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_primary_war_enemy', description: 'Iterate through all primary war enemies', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_primary_war_enemy = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_prisoner', description: 'Iterate through all prisoners', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_prisoner = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_prowess_councillor', description: 'Iterate through all prowess-based councillors', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_prowess_councillor = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_raid_target', description: 'Iterate through anyone the character is hostile to due to having raided them. Only returns top lieges', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_raid_target = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_realm_county', description: 'Iterate through all counties in the realm. Based on top liege', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_realm_county = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_realm_de_jure_duchy', description: 'Iterate through all de jure duchies that have at least one county in the realm. Based on top liege', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_realm_de_jure_duchy = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_realm_de_jure_empire', description: 'Iterate through all de jure empire that have at least one county in the realm. Based on top liege', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_realm_de_jure_empire = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_realm_de_jure_kingdom', description: 'Iterate through all de jure kingdom that have at least one county in the realm. Based on top liege', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_realm_de_jure_kingdom = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_realm_province', description: 'Iterate through all realm provinces of a character', supportedScopes: ['character'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, valueType: 'block', syntax: "any_realm_province = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_relation', description: 'Iterate through scripted relations of a given type or multiple types, if someone is multiple relations they will only be in the list once', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_relation = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_same_sex_spouse_candidate', description: 'Iterate through all the spouse candidates of the same sex of a character.', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "WARNING: THIS IS VERY SLOW DO NOT DO IT OFTEN.\nany_same_sex_spouse_candidate = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_scheme', description: 'Iterate through all schemes owned by the character', supportedScopes: ['character'], supportedTargets: ['scheme'], outputScope: 'scheme', isIterator: true, valueType: 'block', syntax: "any_scheme = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_secret', description: 'Iterate through all secrets of the character', supportedScopes: ['character'], supportedTargets: ['secret'], outputScope: 'secret', isIterator: true, valueType: 'block', syntax: "any_secret = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_sibling', description: 'Iterate through all siblings', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_sibling = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_sponsored_inspiration', description: 'Iterate through all sponsored inspirations', supportedScopes: ['character'], supportedTargets: ['inspiration'], outputScope: 'inspiration', isIterator: true, valueType: 'block', syntax: "any_sponsored_inspiration = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_spouse', description: 'Iterate through all spouses', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_spouse = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_spouse_candidate', description: 'Iterate through all the spouse candidates of a character.', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "WARNING: THIS IS VERY SLOW DO NOT DO IT OFTEN.\nany_spouse_candidate = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_stewardship_councillor', description: 'Iterate through all stewardship-based councillors', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_stewardship_councillor = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_sub_realm_barony', description: 'Iterate through all baronies in sub-realm', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_sub_realm_barony = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_sub_realm_county', description: 'Iterate through all counties in sub-realm', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_sub_realm_county = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_sub_realm_duchy', description: 'Iterate through all duchies in sub-realm', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_sub_realm_duchy = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_sub_realm_empire', description: 'Iterate through all empires in sub-realm', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_sub_realm_empire = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_sub_realm_kingdom', description: 'Iterate through all kingdoms in sub-realm', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_sub_realm_kingdom = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_sub_realm_title', description: 'Iterate through all titles in sub-realm', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_sub_realm_title = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_targeting_faction', description: 'Iterate through all factions targeting the scope character', supportedScopes: ['character'], supportedTargets: ['faction'], outputScope: 'faction', isIterator: true, valueType: 'block', syntax: "any_targeting_faction = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_targeting_scheme', description: 'Iterate through all schemes targeting the character', supportedScopes: ['character'], supportedTargets: ['scheme'], outputScope: 'scheme', isIterator: true, valueType: 'block', syntax: "any_targeting_scheme = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_targeting_secret', description: 'Iterate through all secrets that target the specified scope', supportedScopes: ['character'], supportedTargets: ['secret'], outputScope: 'secret', isIterator: true, valueType: 'block', syntax: "any_targeting_secret = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_traveling_family_member', description: 'Iterate though all characters that should travel with the scoped one (when moving between courts for instance); includes the scoped character', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_traveling_family_member = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_truce_holder', description: 'Iterate through all characters that have a truce on this character', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_truce_holder = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_truce_target', description: 'Iterate through all characters this character has a truce on', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_truce_target = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_unspent_known_secret', description: 'Iterate through all unspent secrets known by the character', supportedScopes: ['character'], supportedTargets: ['secret'], outputScope: 'secret', isIterator: true, valueType: 'block', syntax: "any_unspent_known_secret = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_vassal', description: 'Iterate through all DIRECT vassals', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_vassal = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_vassal_or_below', description: 'Iterate through ALL vassals, not just direct vassals', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_vassal_or_below = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_war_ally', description: 'Iterate through all direct war allies', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_war_ally = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_war_enemy', description: 'Iterate through all direct war enemies', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_war_enemy = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_warden_hostage', description: 'Iterate through all hostages having this warden', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_warden_hostage = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'aptitude', description: 'What is the scoped character\'s aptitude in the target court position type? aptitude = { court_position = court_position_type value >= 1 }', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'attraction', description: 'Attraction value for the scoped character', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'average_amenity_level', description: 'average_amenity_level >= 3', supportedScopes: ['character'], valueType: 'comparison', syntax: "Compares the scoped character's average amenity level to the given value, you probably never want to check for direct equality since the average will be some decimal number" },
    { name: 'base_weight', description: 'Base weight of the scoped character', supportedScopes: ['character'], valueType: 'comparison', syntax: "base_weight > 10" },
    { name: 'can_add_hook', description: 'will trying to hook the target character override the current hook? (if no current hook, always returns true)', supportedScopes: ['character'], syntax: "can_add_hook = {\ntarget = <character>\ntype = <hook type>\ndays/months/year = whatever (optional; will use the duration from the type if not provided)\n}" },
    { name: 'can_arrive_in_time_to_activity_minimum', description: 'can_arrive_in_time_to_activity_minimum = target_activity', supportedScopes: ['character'], supportedTargets: ['activity'], syntax: "Can the scoped character arrive to the target activity in time? (only does rough but performance consideration)" },
    { name: 'can_attack_in_hierarchy', description: 'can the scope target be attacking the defender based on their liege-vassal relations?', supportedScopes: ['character'] },
    { name: 'can_be_acclaimed', description: 'Can the given character potentially be the Acclaimed Knight of an Accolade?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'can_be_child_of', description: 'Would the target character have been able to have children at the time of the scoped character\'s birth? Only age is taken into account', supportedScopes: ['character'] },
    { name: 'can_be_employed_as', description: 'can the scoped character be employed as target court position type?', supportedScopes: ['character'] },
    { name: 'can_be_parent_of', description: 'Would the scoped character have been able to have children at the time of the target character\'s birth? Only age is taken into account', supportedScopes: ['character'] },
    { name: 'can_benefit_from_artifact', description: 'Can the scoped character benefit from the main bonuses of this artifact?', supportedScopes: ['character'], supportedTargets: ['artifact'] },
    { name: 'can_create_faction', description: 'can the character create the faction of the specified type against the specified character?', supportedScopes: ['character'], syntax: "can_create_faction = { type = X target = Y }" },
    { name: 'can_declare_war', description: 'Can the scoped character declare war on the defender with the specified casus bellis on the defender character for the target titles with an optional claimant. can_declare_war = { defender = X casus_belli = Y target_titles = { Z } claimant = A }', supportedScopes: ['character'] },
    { name: 'can_diverge', description: 'Can this ruler diverge their culture? Includes checking the cost', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'can_diverge_excluding_cost', description: 'Can this ruler diverge their culture? Does not check the cost', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'can_embrace_tradition', description: 'Can scoped charater embrace new culture tradition?', supportedScopes: ['character'], syntax: "scope:character = { can_embrace_tradition = scope:new_tradition }\nscope:character = {\ncan_embrace_tradition = {\ntradition = scope:new_tradition\nreplace = my_old_tradition\n}\n}" },
    { name: 'can_employ_court_position_type', description: 'can the scoped character employ the target court position type?', supportedScopes: ['character'] },
    { name: 'can_equip_artifact', description: 'Can the scoped character equip given artifact?', supportedScopes: ['character'], supportedTargets: ['artifact'] },
    { name: 'can_execute_decision', description: 'Is the scoped character able to execute the asigned decision?', supportedScopes: ['character'], supportedTargets: ['decision'] },
    { name: 'can_have_children', description: 'can the character have children? Only checks hard blocks from traits, not fertility', supportedScopes: ['character'], valueType: 'boolean', syntax: "can_have_children = yes/no" },
    { name: 'can_host_activity', description: 'can_host_activity = target_activity', supportedScopes: ['character'], supportedTargets: ['activity_type'], syntax: "Can the scoped character host the target activity type" },
    { name: 'can_hybridize', description: 'Can this ruler hybridize with the target culture? Includes checking the cost', supportedScopes: ['character'], supportedTargets: ['culture'] },
    { name: 'can_hybridize_excluding_cost', description: 'Can this ruler hybridize with the target culture? Does not check the cost', supportedScopes: ['character'], supportedTargets: ['culture'] },
    { name: 'can_join_activity', description: 'can_join_activity = target_activity', supportedScopes: ['character'], supportedTargets: ['activity'], syntax: "Can the scoped character join the target activity" },
    { name: 'can_join_faction', description: 'Can the scope character join the faction? can_join_faction = faction', supportedScopes: ['character'], supportedTargets: ['faction'] },
    { name: 'can_join_or_create_faction_against', description: 'Can the scope character create if join a faction against the target?', supportedScopes: ['character'], syntax: "can_join_or_create_faction_against = scope:faction_target\ncan_join_or_create_faction_against = {\nwho = scope:faction_target\nfaction = faction_key # optional\ncheck_in_a_faction = no # default: yes\n}" },
    { name: 'can_sponsor_inspiration', description: 'can_sponsor_inspiration = inspiration', supportedScopes: ['character'], supportedTargets: ['inspiration'], syntax: "Can the scoped character sponsor the target inspiration" },
    { name: 'can_start_scheme', description: 'can the character start the scheme?', supportedScopes: ['character'], syntax: "can_start_scheme = { type = X target = Y }" },
    { name: 'character_has_commander_trait_scope_does_not', description: 'Does the character have a commander trait that the scope does not?', supportedScopes: ['character'] },
    { name: 'character_is_land_realm_neighbor', description: 'Is the scoped character a realm neighbor of the target? Meaning they\'re independent or has the same liege, and border your realm.', supportedScopes: ['character'] },
    { name: 'character_is_realm_neighbor', description: 'Is the scoped character a realm neighbor of the target? Meaning they\'re independent or has the same liege, and border your realm. Including across two sea zones', supportedScopes: ['character'] },
    { name: 'character_men_at_arms_expense_gold_relative', description: 'What is the ratio of the scoped character\'s men-at-arms gold expenses, relative to their income?', supportedScopes: ['character'], valueType: 'comparison', syntax: "Similar calc compared to `ai_men_at_arms_expense_gold_min` / `ai_men_at_arms_expense_gold_ideal`.\n(Relative value 0.0 - 1.0 - *, where 1.0 is all income, unraised maa costs)" },
    { name: 'character_men_at_arms_expense_prestige_relative', description: 'What is the ratio of the scoped character\'s men-at-arms prestige expenses, relative to their income?', supportedScopes: ['character'], valueType: 'comparison', syntax: "Similar calc compared to `ai_men_at_arms_expense_prestige_min` / `ai_men_at_arms_expense_prestige_ideal`.\n(Relative value 0.0 - 1.0 - *, where 1.0 is all income, unraised maa costs)" },
    { name: 'completely_controls', description: 'does the character controls all counties and baronies inside de jure title (no hostile occupation either)?', supportedScopes: ['character'], supportedTargets: ['landed_title'] },
    { name: 'completely_controls_region', description: 'does the character controls all counties and baronies inside the specified region (no hostile occupation either)?', supportedScopes: ['character'] },
    { name: 'council_task_monthly_progress', description: 'Is the scoped character\'s monthly progress on their assigned council task this big?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'court_grandeur_base', description: 'Gets the base court grandeur value for a character, always NRoyalCourt::COURT_GRANDEUR_MIN for those without one', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'court_grandeur_current', description: 'Gets the current court grandeur value for a character, always NRoyalCourt::COURT_GRANDEUR_MIN for those without one', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'court_grandeur_current_level', description: 'Gets the current court grandeur level for a character, always 0 for those without one', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'court_grandeur_minimum_expected', description: 'Gets the minimum expected court grandeur value for a character, always NRoyalCourt::COURT_GRANDEUR_MIN for those without one', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'court_grandeur_minimum_expected_level', description: 'Gets the minimum expected court grandeur level for a character, always 0 for those without one', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'court_positions_currently_available', description: 'How many court positions the scoped character CAN currently employs', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'court_positions_currently_filled', description: 'How many court positions the scope character currently employs', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'create_faction_type_chance', description: 'Check if the chance to create a faction against a target of the scope character is is true against the scripted value', supportedScopes: ['character'], valueType: 'comparison', syntax: "create_faction_type_chance = {\ntype = faction_type #An ongoing faction\ntarget = target_character\nvalue <|<=|>=|> 0\n}" },
    { name: 'current_military_strength', description: 'Is the scoped character\'s current military strength this big?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'current_weight', description: 'Current weight of the scoped character', supportedScopes: ['character'], valueType: 'comparison', syntax: "current_weight > 10" },
    { name: 'current_weight_for_portrait', description: 'Current weight of the scoped character as a value for portraits scaled between 0.0 and 1.0', supportedScopes: ['character'], valueType: 'comparison', syntax: "current_weight_for_portrait > 0.1" },
    { name: 'days_as_ruler', description: 'Number of days this character has been a ruler, returns -1 if character isn\'t a ruler', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'days_in_prison', description: 'number of days the character has been imprisoned for (0 if not imprisoned)', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'days_of_continuous_peace', description: 'Number of days the character has been in peace (0 if in war). Raids count as \'not peace\'', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'days_of_continuous_war', description: 'Number of days the character has been in peace (0 if in peace)', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'days_since_death', description: 'number of days since the character has died.', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'days_since_joined_court', description: 'days_since_joined_court > 5', supportedScopes: ['character'], valueType: 'comparison', syntax: "Gets the days since scoped character joined their current court" },
    { name: 'death_reason', description: 'Does the scoped character have the given death reason?', supportedScopes: ['character'], syntax: "death_reason = death_natural_causes" },
    { name: 'debt_level', description: 'Is the scoped character\'s debt level this value? -1 if not meeting any debt level threshold.', supportedScopes: ['character'], valueType: 'comparison', syntax: "0 for the first one, and so on.\nNote that this might not match exactly with the modifier in effect as it calculates what the modifier will be now, and the character's actual modifier can lag behind" },
    { name: 'diarch_aptitude', description: 'Diarch aptitude score for the scoped (potential) diarch', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'diarch_loyalty', description: 'Diarch loyalty score for the scoped (potential) diarch', supportedScopes: ['character'], valueType: 'comparison', syntax: "scope:diarch = { diarch_loyalty >= 50 }" },
    { name: 'diarchy_swing', description: 'Get diarchy scales of power swing', supportedScopes: ['character'], valueType: 'comparison', syntax: "scope:liege = { diarchy_swing > 50 }" },
    { name: 'diplomacy', description: 'does the character have the required diplomacy skill level?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'diplomacy_diff', description: 'does the character have the required diplomacy skill level difference against target?', supportedScopes: ['character'], valueType: 'comparison', syntax: "diplomacy = { target = character value <= script_value abs = yes/no(optional, default no) }" },
    { name: 'diplomacy_for_portrait', description: 'Diplomacy skill scaled between 0.0 and 1.0 for portraits', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'diplomacy_lifestyle_perk_points', description: 'How many perk points available does the character have?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'diplomacy_lifestyle_perks', description: 'How many perks from this lifestyle does the character have?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'diplomacy_lifestyle_unlockable_perks', description: 'How many perks from this lifestyle can the character currently unlock? This checks that they have the parent perks, and that the can_be_picked is met. It doesn\'t check perk points', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'diplomacy_lifestyle_xp', description: 'How many perk points available does the character have?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'does_ai_liege_in_vassal_contract_desire_obligation_change', description: 'Does the AI liege in a vassal contract desire changing an obligation level', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'does_ai_vassal_in_vassal_contract_desire_obligation_change', description: 'Does the AI vassal in a vassal contract desire changing an obligation level', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'domain_limit', description: 'Is the scoped character\'s domain limit this big?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'domain_limit_available', description: 'Is there this much space left in the character\'s domain limit? Negative values also work for checking characters that are above their limit', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'domain_limit_percentage', description: 'Is the scoped character\'s domain this big in comparison to their limit?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'domain_size', description: 'Is the scoped character\'s domain this big?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'domain_size_excluding_grace_period', description: 'Is the scoped character\'s domain this big? Does not count titles currently in the grace period', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'dread', description: 'does the character have the required dread?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'dread_modified_ai_boldness', description: 'AI boldness modified by the dread of the specified character', supportedScopes: ['character'], syntax: "dread_modified_ai_boldness = {\ncharacter = root\t# the character whose dread is affecting the target character\nvalue >= 5\n}" },
    { name: 'effective_age', description: 'is the character old/young enough? If immortal, this uses the age they became immortal at', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'employs_court_position', description: 'is the scoped character employing a target court position type?', supportedScopes: ['character'] },
    { name: 'fertility', description: 'does the character have the required fertility?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'focus_progress', description: 'Does the character have this much focus progress', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'gold', description: 'does the character have the required gold?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'government_allows', description: 'checks if the government of the character allows something', supportedScopes: ['character'] },
    { name: 'government_disallows', description: 'checks if the government of the character disallows something', supportedScopes: ['character'] },
    { name: 'government_has_flag', description: 'checks if the government of the character has a specific flag', supportedScopes: ['character'] },
    { name: 'has_active_diarchy', description: 'Does the scoped character has an active diarchy', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'has_active_mandate', description: 'Does the diarch have this mandate active?', supportedScopes: ['character'], syntax: "scope:diarch = { has_active_mandate = live_long_and_prosper }" },
    { name: 'has_activity_intent', description: 'has_activity_intent = key', supportedScopes: ['character'], syntax: "Does the scoped character have the given activity intent" },
    { name: 'has_activity_state', description: 'has_activity_state > travel/passive/active', supportedScopes: ['character'], syntax: "Does the scoped character have the given state in their currenty involved activity" },
    { name: 'has_any_artifact', description: 'does the scoped character have any artifacts?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'has_any_artifact_claim', description: 'does the scoped character have any artifact claims at all? ( CHEAP )', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'has_any_cb_on', description: 'does the scope character have any casus bellis on the taget character?', supportedScopes: ['character'] },
    { name: 'has_any_court_position', description: 'does the scoped character have any court positions?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'has_any_display_cb_on', description: 'does the scope character have any casus bellis on the taget character that should be displayed? (Allowed to fail valid_to_start_display_regardless)', supportedScopes: ['character'] },
    { name: 'has_any_focus', description: 'Does the character have any focus set?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'has_any_nickname', description: 'Has the scope character any nickname?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'has_any_scripted_relation', description: 'does the scope character have any scripted relation with the taget character?', supportedScopes: ['character'] },
    { name: 'has_any_secret_relation', description: 'does the scope character have any secret relation with the taget character?', supportedScopes: ['character'] },
    { name: 'has_any_secrets', description: 'Does the character have any secrets?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'has_any_unequipped_artifact', description: 'does the scoped character have any unequipped artifacts?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'has_artifact_claim', description: 'Does the scoped character have a personal or house claim on the target artifact', supportedScopes: ['character'], supportedTargets: ['artifact'] },
    { name: 'has_away_hostages', description: 'Does the scoped character have Hostages abroad?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'has_bad_nickname', description: 'Has the scope character a bad nickname?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'has_banish_reason', description: 'Does the character have the banish reason towards the target?', supportedScopes: ['character'] },
    { name: 'has_cb_on', description: 'does the scope character have the specified casus bellis on the taget character? Invalid target returns false automatically. has_cb_on = { target = X casus_belli/cb = Y }', supportedScopes: ['character'] },
    { name: 'has_character_flag', description: 'Does the character have this flag?', supportedScopes: ['character'] },
    { name: 'has_character_modifier', description: 'Does the scoped character have a given modifier', supportedScopes: ['character'], syntax: "has_character_modifier = name" },
    { name: 'has_character_modifier_duration_remaining', description: 'Does the scoped character have the duration remaining on a given modifier', supportedScopes: ['character'], syntax: "has_character_modifier_duration_remaining = name" },
    { name: 'has_claim_on', description: 'does the character have a claim on the target title?', supportedScopes: ['character'], supportedTargets: ['landed_title'] },
    { name: 'has_completed_activity_intent', description: 'has_completed_activity_intent = { type = <key> target = <character> }', supportedScopes: ['character'], syntax: "has_completed_activity_intent = <key>\nHas the scoped character completed an intent of the given type in their involved activity, optionally against a specific target." },
    { name: 'has_completed_inspiration', description: 'has_completed_inspiration = bool', supportedScopes: ['character'], valueType: 'boolean', syntax: "Checks if the scoped character has ever completed an inspiration" },
    { name: 'has_council_position', description: 'Does the scoped character have the given position?', supportedScopes: ['character'] },
    { name: 'has_councillor_for_skill', description: 'does the scope character have a councillor for the specified skill?', supportedScopes: ['character'], syntax: "has_councillor_for_skill = X, where X is a skill name or 'general'" },
    { name: 'has_court_language', description: 'Is the character\'s court language the given language?', supportedScopes: ['character'], syntax: "has_court_language = language_norwegian" },
    { name: 'has_court_language_of_culture', description: 'Is the character\'s court language the language of the target culture?', supportedScopes: ['character'], supportedTargets: ['culture'], syntax: "has_court_language_of_culture = scope:target_culture" },
    { name: 'has_court_position', description: 'is the scoped character holding the target court position type?', supportedScopes: ['character'] },
    { name: 'has_court_type', description: 'has_court_type = court_diplomatic', supportedScopes: ['character'], syntax: "Does the character have this court type?" },
    { name: 'has_culture', description: 'Does the character have this culture?', supportedScopes: ['character'], supportedTargets: ['culture'] },
    { name: 'has_de_jure_claim_on', description: 'does the scope character have a dejure claim against the target?', supportedScopes: ['character'] },
    { name: 'has_diarchy_active_parameter', description: 'Does active diarchy have this parameter active for current power level?', supportedScopes: ['character'], syntax: "scope:liege = { has_diarchy_active_parameter = parameter_name }" },
    { name: 'has_diarchy_parameter', description: 'Can active diarchy have this parameter at some power level?', supportedScopes: ['character'], syntax: "scope:liege = { has_diarchy_parameter = parameter_name }" },
    { name: 'has_diarchy_type', description: 'Is scope character in a diarchy of a specific type?', supportedScopes: ['character'], syntax: "Trigger works even when there's no active diarchyscope:liege = { has_diarchy_type = regency }" },
    { name: 'has_divorce_reason', description: 'Does the character have the divorce reason towards the target?', supportedScopes: ['character'] },
    { name: 'has_dread_level_towards', description: 'How much is scared the scope character agains the target. 0 = not intimidated, 1 = intimidated, 2 = cowed.', supportedScopes: ['character'], syntax: "has_dread_level_towards = {\ntarget = X\nlevel >/</>=/<=/= Y\n}" },
    { name: 'has_dynasty', description: 'does the character have a valid dynasty?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'has_election_vote_of', description: 'Is the target character voting for the scoped character in the election of the target title', supportedScopes: ['character'], syntax: "has_election_vote_of = { who = scope:actor title = primary_title }" },
    { name: 'has_employed_any_court_position', description: 'does the scoped character have any employed court positions?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'has_execute_reason', description: 'Does the character have the execute reason towards the target?', supportedScopes: ['character'] },
    { name: 'has_faith', description: 'Does the character have this faith?', supportedScopes: ['character'], supportedTargets: ['faith'], syntax: "has_faith = faith:baltic_pagan" },
    { name: 'has_father', description: 'does the character have a valid living father?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'has_focus', description: 'Does the character have this focus?', supportedScopes: ['character'] },
    { name: 'has_free_council_slot', description: 'Does the scope character have a council position to fill? (ignoring automatically filled positions)', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'has_gene', description: 'Does the character have the specified gene template? Only works for morph genes. An interface trigger. has_gene = { category = X template = Y }', supportedScopes: ['character'], syntax: "An interface trigger, can only be used in specific places" },
    { name: 'has_government', description: 'checks if the character has a specific government type', supportedScopes: ['character'] },
    { name: 'has_had_focus_for_days', description: 'Does the character had a focus for that time?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'has_hook', description: 'does the character have a hook on the target, has_hook = <character>', supportedScopes: ['character'], supportedTargets: ['character'] },
    { name: 'has_hook_from_secret', description: 'does the character have a hook based on the target secret? example use: has_hook_from_secret = scope:saved_secret', supportedScopes: ['character'], supportedTargets: ['secret'] },
    { name: 'has_hook_of_type', description: 'does the character have a hook on the target of the given type?, has_hook_of_type = { target = X type = Y }', supportedScopes: ['character'] },
    { name: 'has_imprisonment_reason', description: 'Does the character have the imprisonment reason towards the target?', supportedScopes: ['character'] },
    { name: 'has_inactive_trait', description: 'Does the character have this trait or a trait of this trait group amongst their inactive traits?', supportedScopes: ['character'] },
    { name: 'has_lifestyle', description: 'Does the character have this lifestyle?', supportedScopes: ['character'] },
    { name: 'has_mother', description: 'does the character have a valid living mother?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'has_nickname', description: 'Does the character have this nickname?', supportedScopes: ['character'] },
    { name: 'has_opinion_modifier', description: 'does the character have the specified opinion modifier on the target? (optional *value <|<=|=|>=|> X* or *value = { MIN MAX }* inclusive)', supportedScopes: ['character'] },
    { name: 'has_opposite_relation', description: 'Does the scope character have an opposite relationship of the relation value with the target character? target = , relation =', supportedScopes: ['character'] },
    { name: 'has_outstanding_artifact_claims', description: 'does the scoped character have any artifact claims that can be pressed? ( EXPENSIVE )', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'has_owned_scheme', description: 'Does this character own a scheme?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'has_pending_court_events', description: 'has_pending_court_events = bool', supportedScopes: ['character'], valueType: 'boolean', syntax: "Does the character have pending court events? Meaning court events that'll spawn when they next open the royal court view.\nCan only be used on player characters with a royal court." },
    { name: 'has_pending_interaction_of_type', description: 'Does the character have a pending interaction of the type? Only works if the scope is player-controlled.', supportedScopes: ['character'], syntax: "Example: has_pending_interaction = interaction_key" },
    { name: 'has_perk', description: 'Does the character have this perk?', supportedScopes: ['character'] },
    { name: 'has_personal_artifact_claim', description: 'Does the scoped character have a personal claim on the target artifact', supportedScopes: ['character'], supportedTargets: ['artifact'] },
    { name: 'has_potential_acclaimed_knights', description: 'Does the given character have any potential knights that could be appointed as Acclaimed Knights?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'has_primary_title', description: 'does the character has specific title as his primary title', supportedScopes: ['character'], supportedTargets: ['landed_title'] },
    { name: 'has_prisoners', description: 'Does the character have prisoners?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'has_raid_immunity_against', description: 'Is the scoped character\'s (top-liege) realm immune to raiding by the target due to having defeated their raid army?', supportedScopes: ['character'], supportedTargets: ['character'], syntax: "has_raid_immunity_against = scope:character" },
    { name: 'has_raised_armies', description: 'does the character have raised or gathering armies?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'has_realm_law', description: 'Does the scoped character have the given realm law?', supportedScopes: ['character'] },
    { name: 'has_realm_law_flag', description: 'Does the scoped character have a law with the given flag?', supportedScopes: ['character'] },
    { name: 'has_relation_activity_recurrer', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
    { name: 'has_relation_antiquarian', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
    { name: 'has_relation_best_friend', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
    { name: 'has_relation_bully', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
    { name: 'has_relation_court_physician', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
    { name: 'has_relation_crush', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
    { name: 'has_relation_flag', description: 'Does the scope character have a specific flag on a relation with the target character? target = , relation = , flag =', supportedScopes: ['character'] },
    { name: 'has_relation_friend', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
    { name: 'has_relation_guardian', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
    { name: 'has_relation_intrigue_mentor', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
    { name: 'has_relation_intrigue_student', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
    { name: 'has_relation_lover', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
    { name: 'has_relation_mentor', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
    { name: 'has_relation_nemesis', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
    { name: 'has_relation_nursed_child', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
    { name: 'has_relation_oaf', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
    { name: 'has_relation_potential_friend', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
    { name: 'has_relation_potential_hook', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
    { name: 'has_relation_potential_lover', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
    { name: 'has_relation_potential_rival', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
    { name: 'has_relation_rival', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
    { name: 'has_relation_soldier_friend', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
    { name: 'has_relation_soulmate', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
    { name: 'has_relation_student', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
    { name: 'has_relation_to', description: 'does the character have a relation to the target? Matches the logic of the data system function HasRelationTo, has_relation_to = <character>', supportedScopes: ['character'], supportedTargets: ['character'] },
    { name: 'has_relation_victim', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
    { name: 'has_relation_ward', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
    { name: 'has_relation_wedding_bad_fertility', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
    { name: 'has_relation_wedding_good_fertility', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
    { name: 'has_relation_wedding_very_bad_fertility', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
    { name: 'has_relation_wedding_very_good_fertility', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
    { name: 'has_relation_wet_nurse', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
    { name: 'has_religion', description: 'Does the character have this religion?', supportedScopes: ['character'], supportedTargets: ['religion'], syntax: "has_religion = religion:buddhism_religion" },
    { name: 'has_revoke_title_reason', description: 'Does the character have the revoke title reason towards the target?', supportedScopes: ['character'] },
    { name: 'has_royal_court', description: 'has_royal_court = bool', supportedScopes: ['character'], valueType: 'boolean', syntax: "Does the scoped character have a royal court" },
    { name: 'has_same_court_language', description: 'Is the character\'s court language the same language as the target character\'s?', supportedScopes: ['character'], supportedTargets: ['character'], syntax: "has_same_court_language = scope:target_character" },
    { name: 'has_same_court_type_as', description: 'has_same_court_type_as = character', supportedScopes: ['character'], syntax: "Does the character have the same court type as the target?" },
    { name: 'has_same_culture_as', description: 'Does the character have the same culture as the target?', supportedScopes: ['character'] },
    { name: 'has_same_focus_as', description: 'Does the character have the same focus as the other?', supportedScopes: ['character'] },
    { name: 'has_same_government', description: 'checks if the character has the same government type as another character', supportedScopes: ['character'] },
    { name: 'has_same_sinful_trait', description: 'do the two characters share a trait that is considered sinful by both of their respective faiths?', supportedScopes: ['character'], syntax: "scope:character_1 = { has_same_sinful_trait = scope:character_2 }" },
    { name: 'has_same_virtue_trait', description: 'do the two characters share a trait that is considered virtuous by both of their respective faiths?', supportedScopes: ['character'], syntax: "scope:character_1 = { has_same_virtue_trait = scope:character_2 }" },
    { name: 'has_secret_relation_activity_recurrer', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
    { name: 'has_secret_relation_antiquarian', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
    { name: 'has_secret_relation_best_friend', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
    { name: 'has_secret_relation_bully', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
    { name: 'has_secret_relation_court_physician', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
    { name: 'has_secret_relation_crush', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
    { name: 'has_secret_relation_friend', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
    { name: 'has_secret_relation_guardian', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
    { name: 'has_secret_relation_intrigue_mentor', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
    { name: 'has_secret_relation_intrigue_student', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
    { name: 'has_secret_relation_lover', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
    { name: 'has_secret_relation_mentor', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
    { name: 'has_secret_relation_nemesis', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
    { name: 'has_secret_relation_nursed_child', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
    { name: 'has_secret_relation_oaf', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
    { name: 'has_secret_relation_potential_friend', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
    { name: 'has_secret_relation_potential_hook', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
    { name: 'has_secret_relation_potential_lover', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
    { name: 'has_secret_relation_potential_rival', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
    { name: 'has_secret_relation_rival', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
    { name: 'has_secret_relation_soldier_friend', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
    { name: 'has_secret_relation_soulmate', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
    { name: 'has_secret_relation_student', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
    { name: 'has_secret_relation_victim', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
    { name: 'has_secret_relation_ward', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
    { name: 'has_secret_relation_wedding_bad_fertility', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
    { name: 'has_secret_relation_wedding_good_fertility', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
    { name: 'has_secret_relation_wedding_very_bad_fertility', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
    { name: 'has_secret_relation_wedding_very_good_fertility', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
    { name: 'has_secret_relation_wet_nurse', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
    { name: 'has_selected_mandate', description: 'Was this mandate selected for the diarch?', supportedScopes: ['character'], syntax: "Trigger works even when there's no active diarchyscope:diarch = { has_selected_mandate = live_long_and_prosper }" },
    { name: 'has_sexuality', description: 'Does the character\'s sexuality match the scripted? (heterosexual, homosexual, bisexual, asexual, none). Characters that have yet to get a sexuality (children) have the none set.', supportedScopes: ['character'] },
    { name: 'has_spawned_court_events', description: 'has_spawned_court_events = bool', supportedScopes: ['character'], valueType: 'boolean', syntax: "Does the character have spawned court events? Meaning court events are shown (opened or not) in the royal court view.\nCan only be used on player characters with a royal court." },
    { name: 'has_strong_claim_on', description: 'does the character have a Pressed Claim on the target title?', supportedScopes: ['character'], supportedTargets: ['landed_title'] },
    { name: 'has_strong_hook', description: 'does the character have a strong hook on the target, has_strong_hook = <character>', supportedScopes: ['character'], supportedTargets: ['character'] },
    { name: 'has_strong_usable_hook', description: 'does the character have a strong hook on the target that is not on cooldown, has_strong_usable_hook = <character>', supportedScopes: ['character'], supportedTargets: ['character'] },
    { name: 'has_targeting_faction', description: 'Has the scope character a faction targeting him/her?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'has_title', description: 'does the character hold the title?', supportedScopes: ['character'], supportedTargets: ['landed_title'] },
    { name: 'has_trait', description: 'Does the character have this trait or a trait of this trait group?', supportedScopes: ['character'] },
    { name: 'has_trait_rank', description: 'Compare the trait rank of a character to a value or other character.', supportedScopes: ['character'], syntax: "has_trait_rank = {\ntrait = TRAIT_GROUP\nrank <=> number (can be script value) # need only one of rank or character\ncharacter <=> character target # need only one of rank or character\n}\nNote that not having the trait and having rank 0 counts as the same thing. rank < X on its own will therefore always return true for a character that does not have the trait." },
    { name: 'has_trait_with_flag', description: 'does the scope character have a trait with a certain flag?', supportedScopes: ['character'], syntax: "has_trait_with_flag = can_not_marry" },
    { name: 'has_trait_xp', description: 'Checks if the scopd character has the given amount of XP in the trait level track. Track name is required if the trait has multiple tracks, otherwise should not be provided.', supportedScopes: ['character'], valueType: 'comparison', syntax: "has_trait_xp = { trait = <trait_key> track = <track_key> value = <script_value> }" },
    { name: 'has_truce', description: 'Does the scope character have a truce with the target character? Truces are one way, which means we ask if the scope character can\'t attack the target character', supportedScopes: ['character'] },
    { name: 'has_usable_hook', description: 'does the character have a hook on the target that isn\'t on cooldown, has_usable_hook = <character>', supportedScopes: ['character'], supportedTargets: ['character'] },
    { name: 'has_weak_claim_on', description: 'does the character have an Unpressed Claim on the target title?', supportedScopes: ['character'], supportedTargets: ['landed_title'] },
    { name: 'has_weak_hook', description: 'does the character have a weak hook on the target. A strong hook will *not* count, has_weak_hook = <character>', supportedScopes: ['character'], supportedTargets: ['character'] },
    { name: 'health', description: 'does the character have the required health?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'highest_held_title_tier', description: 'what is the highest held landed title tier of the character?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'highest_skill', description: 'Is the skill the highest skill (excluding Prowess) of the character? True even when there are multiple skills with the same highest value.', supportedScopes: ['character'] },
    { name: 'holds_landed_title', description: 'Is the scope character landed (holds a county or barony)?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'hostage_duration', description: 'For how long has the scope character been a hostage? { days/months/years =,>,< X }', supportedScopes: ['character'] },
    { name: 'important_action_is_valid_but_invisible', description: 'is there an important action available to the character, but they dismissed it?', supportedScopes: ['character'], syntax: "important_action_is_valid_but_invisible = important_action_key" },
    { name: 'important_action_is_visible', description: 'is there an important action shown to the character?', supportedScopes: ['character'], syntax: "important_action_is_visible = important_action_key" },
    { name: 'in_diplomatic_range', description: 'Is the scope character and the target character within each others diplomatic range?', supportedScopes: ['character'] },
    { name: 'intrigue', description: 'does the character have the required intrigue skill level?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'intrigue_diff', description: 'does the character have the required intrigue skill level difference against target?', supportedScopes: ['character'], valueType: 'comparison', syntax: "intrigue = { target = character value <= script_value abs = yes/no(optional, default no) }" },
    { name: 'intrigue_for_portrait', description: 'Intrigue skill scaled between 0.0 and 1.0 for portraits', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'intrigue_lifestyle_perk_points', description: 'How many perk points available does the character have?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'intrigue_lifestyle_perks', description: 'How many perks from this lifestyle does the character have?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'intrigue_lifestyle_unlockable_perks', description: 'How many perks from this lifestyle can the character currently unlock? This checks that they have the parent perks, and that the can_be_picked is met. It doesn\'t check perk points', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'intrigue_lifestyle_xp', description: 'How many perk points available does the character have?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'is_a_faction_leader', description: 'Is the scope character a leader of a faction?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'is_a_faction_member', description: 'Is the scope character a member of a faction?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'is_acclaimed', description: 'Is the given character the Acclaimed Knight of an Accolade?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'is_accolade_successor', description: 'Is the given character the Successor of an Accolade?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'is_activity_type_on_cooldown', description: 'Is the given activity type on cooldown for the current character.', supportedScopes: ['character'], supportedTargets: ['activity_type'], syntax: "is_activity_type_on_cooldown = activity_type_key" },
    { name: 'is_adult', description: 'Is the scope character adult?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'is_agent_exposed_in_scheme', description: 'Is the scope character an exposed agent in the target scheme?', supportedScopes: ['character'], supportedTargets: ['scheme'] },
    { name: 'is_ai', description: 'is the character played by AI?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'is_alive', description: 'is the character alive or dead?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'is_allied_in_war', description: 'Is the scope character allied to the target character in a war?', supportedScopes: ['character'] },
    { name: 'is_allied_to', description: 'Is the scope character allied to the target character?', supportedScopes: ['character'] },
    { name: 'is_at_home', description: 'is the character at home?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'is_at_location', description: 'Is the character currently in the target province?', supportedScopes: ['character'], supportedTargets: ['province'] },
    { name: 'is_at_same_location', description: 'Is the character currently in the same province as the target character?', supportedScopes: ['character'] },
    { name: 'is_at_war', description: 'is the character at war? Does not consider your lieges\' wars', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'is_at_war_as_attacker', description: 'is the character at war as an attacker? Does not consider your lieges\' wars', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'is_at_war_as_defender', description: 'is the character at war as a defender? Does not consider your lieges\' wars', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'is_at_war_with', description: 'Is the character at war with the target? Does not consider your lieges\' wars', supportedScopes: ['character'] },
    { name: 'is_at_war_with_liege', description: 'is the character at war with their liege?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'is_attacker_in_war', description: 'is the scope character in the target war as an attacker?', supportedScopes: ['character'], supportedTargets: ['war'] },
    { name: 'is_attracted_to_gender_of', description: 'does the sexuality of the scope character make them attracted to the target character?', supportedScopes: ['character'] },
    { name: 'is_attracted_to_men', description: 'Is the character attracted to men?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'is_attracted_to_women', description: 'Is the character attracted to women?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'is_away_from_court', description: 'Is the character away from the court?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'is_betrothed', description: 'Is the scope character betrothed?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'is_causing_raid_hostility_towards', description: 'Is the scoped character making the target hostile due to having raided their (top-liege\'s) realm?', supportedScopes: ['character'], supportedTargets: ['character'], syntax: "is_causing_raid_hostility_towards = scope:character" },
    { name: 'is_character_interaction_potentially_accepted', description: 'Is the character interaction specified available and potentially accepted for the target character?', supportedScopes: ['character'], syntax: "is_character_interaction_potentially_accepted = {\nrecipient = character\ninteraction = interaction_name\nsecondary_actor = character <optional>\nsecondary_recipient = character <optional>\ntarget_title = title <optional>\n}" },
    { name: 'is_character_interaction_shown', description: 'Is the character interaction specified shown for the target character?', supportedScopes: ['character'], syntax: "is_character_interaction_shown = {\nrecipient = character\ninteraction = interaction_name\n}" },
    { name: 'is_character_interaction_valid', description: 'Is the character interaction specified valid (shown and usable) for the target character?', supportedScopes: ['character'], syntax: "is_character_interaction_valid = {\nrecipient = character\ninteraction = interaction_name\n}" },
    { name: 'is_character_window_main_character', description: 'Is the local player the main character in the character window?', supportedScopes: ['character'], valueType: 'boolean', syntax: "An interface trigger, can only be used in specific places" },
    { name: 'is_child_of', description: 'Is the character a child of the target character?', supportedScopes: ['character'] },
    { name: 'is_claimant', description: 'is the character a claimant to any landed titles?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'is_clergy', description: 'Is the scoped character a clergy?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'is_close_family_of', description: 'Is the character a close family [parents, children, siblings, grandparents, grandchildren] of the target character?', supportedScopes: ['character'] },
    { name: 'is_close_or_extended_family_of', description: 'Is the character a close or extended family [parents, children, siblings, grandparents, grandchildren, cousins, uncles, aunts, nephews, nieces] of the target character?', supportedScopes: ['character'] },
    { name: 'is_commanding_army', description: 'is the character a commanding an army?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'is_concubine', description: 'Is the scope character a concubine?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'is_concubine_of', description: 'Is the target character a concubine of the scope character?', supportedScopes: ['character'] },
    { name: 'is_consort_of', description: 'Is the character a spouse or concubine of the target character?', supportedScopes: ['character'] },
    { name: 'is_council_task_valid', description: 'Check if the task of the scope councillor is valid { task_type = council_position_type_key target = for_targeted_tasks }', supportedScopes: ['character'] },
    { name: 'is_councillor', description: 'Is the scoped character a councillor?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'is_councillor_of', description: 'Is the scoped character a councillor for the specified character?', supportedScopes: ['character'] },
    { name: 'is_court_position_employer', description: 'is the scoped character employed in the target position by target character', supportedScopes: ['character'] },
    { name: 'is_courtier', description: 'Is the scope character a courtier?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'is_courtier_of', description: 'Is the scope character a courtier of the target character?', supportedScopes: ['character'] },
    { name: 'is_cousin_of', description: 'Is the character a cousin of the target character?', supportedScopes: ['character'] },
    { name: 'is_decision_on_cooldown', description: 'Is the given decision on cooldown for the current character.', supportedScopes: ['character'], supportedTargets: ['decision'], syntax: "is_decision_on_cooldown = decision_key" },
    { name: 'is_defender_in_war', description: 'is the scope character in the target war as a defender?', supportedScopes: ['character'], supportedTargets: ['war'] },
    { name: 'is_designated_diarch', description: 'Is the scoped character was diesignated as diarch by their liege?', supportedScopes: ['character'], valueType: 'boolean', syntax: "scope:character = { is_designated_diarch = yes/no }" },
    { name: 'is_diarch', description: 'Is the scoped character currently an active diarch of anyone?', supportedScopes: ['character'], valueType: 'boolean', syntax: "scope:character = { is_diarch = yes/no }" },
    { name: 'is_diarch_of_target', description: 'Is the scoped character currently an active diarch of the target?', supportedScopes: ['character'], supportedTargets: ['character'], syntax: "scope:character = { is_diarch_of_target = scope:liege }" },
    { name: 'is_diarchy_successor', description: 'Is the scoped character next in the line of succession for diarchy?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'is_employer_of', description: 'Is the target character a courtier of the scope character?', supportedScopes: ['character'] },
    { name: 'is_extended_family_of', description: 'Is the character a extended family [cousins, uncles, aunts, nephews, nieces] of the target character?', supportedScopes: ['character'] },
    { name: 'is_female', description: 'Is the scope character female?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'is_forbidden_from_scheme', description: 'Is the scope character forbidden from the target scheme?', supportedScopes: ['character'], supportedTargets: ['scheme'] },
    { name: 'is_forced_into_faction', description: 'Is the scope character forced to be part of a faction?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'is_forced_into_scheme', description: 'Checks if the scope character is forced into the target scheme', supportedScopes: ['character'], supportedTargets: ['scheme'] },
    { name: 'is_foreign_court_guest', description: 'Is the character a guest from another a court? In contrast to is_pool_guest the character has a liege', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'is_foreign_court_guest_of', description: 'Is the character a guest from another a court, visiting the target character\'s court? In contrast to is_pool_guest_of the character has a liege', supportedScopes: ['character'] },
    { name: 'is_foreign_court_or_pool_guest', description: 'Is the character a guest? (is_pool_guest or is_foreign_court_guest)', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'is_foreign_court_or_pool_guest_of', description: 'Is the character a guest? (is_pool_guest_of or is_foreign_court_guest_of)', supportedScopes: ['character'] },
    { name: 'is_from_ruler_designer', description: 'Was this character made from the ruler designer', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'is_grandchild_of', description: 'Is the character a grandchild of the target character?', supportedScopes: ['character'] },
    { name: 'is_grandparent_of', description: 'Is the character a grandparent of the target character?', supportedScopes: ['character'] },
    { name: 'is_great_grandchild_of', description: 'Is the character a great grandchild of the target character?', supportedScopes: ['character'] },
    { name: 'is_great_grandparent_of', description: 'Is the character a great grandparent of the target character?', supportedScopes: ['character'] },
    { name: 'is_heir_of', description: 'Is the character an heir of the target [placeholder]?', supportedScopes: ['character'] },
    { name: 'is_hostage', description: 'Is the scoped character a Hostage?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'is_hostage_from', description: 'Is the scope character a Hostage with target character as their original Liege? is_hostage_from = TARGET', supportedScopes: ['character'] },
    { name: 'is_hostage_of', description: 'Is the scope character a Hostage with target character as their Warden? is_hostage_of = TARGET', supportedScopes: ['character'] },
    { name: 'is_hostage_warden', description: 'Is the scoped character a Warden with Hostages?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'is_immortal', description: 'Is the character immortal?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'is_important_decision', description: 'Is the scoped decision an important decision for the target character?', supportedScopes: ['character'], supportedTargets: ['decision'] },
    { name: 'is_imprisoned', description: 'is the character imprisoned?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'is_imprisoned_by', description: 'Is the scope character imprisoned by the target character? is_imprisoned_by = TARGET', supportedScopes: ['character'] },
    { name: 'is_in_army', description: 'is the character in an army (a commander or a knight)?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'is_in_civil_war', description: 'is the character at war with their liege, or one or more of their vassals?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'is_in_guest_subset', description: 'Is the scoped character in the specified guest subset in the activity they are', supportedScopes: ['character'], syntax: "involved in?\nis_in_guest_subset = {\nname = <subset_key>\nphase = <phase_key> #Optional\n}\nIf phase is not specified, it will check the current phase, otherwise it will\ncheck all phases matching the phase key." },
    { name: 'is_in_ongoing_great_holy_war', description: 'is the character in an ongoing (i.e. the war has started) great holy war?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'is_in_pool_at', description: 'Is the character in the pool the target province is a part of', supportedScopes: ['character'], supportedTargets: ['province'] },
    { name: 'is_in_prison_type', description: 'is the character imprisoned in a prison of the specified type? Accepts any static modifier (see also imprison effect).', supportedScopes: ['character'], syntax: "is_in_prison_type = house_arrest" },
    { name: 'is_in_the_same_court_as', description: 'Is the character in the same court as the target character (they have the same court owner or one is a courtier of the other)?', supportedScopes: ['character'] },
    { name: 'is_in_the_same_court_as_or_guest', description: 'Is the character in the same court as the target character (they have the same court owner or one is a courtier of the other)? Includes guests in the court.', supportedScopes: ['character'] },
    { name: 'is_incapable', description: 'is the character incapable?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'is_independent_ruler', description: 'is the character an independent ruler?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'is_knight', description: 'Is the scoped character a knight', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'is_knight_of', description: 'Is the scoped character a knight of the target character', supportedScopes: ['character'] },
    { name: 'is_landed', description: 'Is the scope character landed (holds a county or barony)?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'is_landless_ruler', description: 'Is the scope character a landless ruler (holds any title, but no on-map land)?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'is_leader_in_war', description: 'is the scope character leading one of the sides in the target war?', supportedScopes: ['character'], supportedTargets: ['war'] },
    { name: 'is_leading_faction_type', description: 'Is the character leading a faction of the specified type?', supportedScopes: ['character'] },
    { name: 'is_liege_or_above_of', description: 'is the scope character a liege or above of the target character?', supportedScopes: ['character'] },
    { name: 'is_local_player', description: 'is the character the local player?', supportedScopes: ['character'], valueType: 'boolean', syntax: "An interface trigger, can only be used in specific places" },
    { name: 'is_lowborn', description: 'Is the character a lowborn?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'is_male', description: 'Is the scope character male?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'is_married', description: 'Is the scope character married?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'is_nibling_of', description: 'Is the character a nibling (niece/nephew) of the target character?', supportedScopes: ['character'] },
    { name: 'is_normal_councillor', description: 'Is the scoped character a regular councillor?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'is_overriding_designated_winner', description: 'Is the scoped character overriding the winner in the GHW they\'re pledged to (will put their beneficiary on the throne if they\'re top participant)?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'is_parent_of', description: 'Is the character a parent of the target character?', supportedScopes: ['character'] },
    { name: 'is_participant_in_activity', description: 'is_participant_in_activity = target_activity', supportedScopes: ['character'], supportedTargets: ['activity'], syntax: "Is the scoped character a participant in the target activity" },
    { name: 'is_participant_in_war', description: 'is the scope character participating in the target war as an attacker or defender?', supportedScopes: ['character'], supportedTargets: ['war'] },
    { name: 'is_performing_council_task', description: 'Is the scoped character performing the given task?', supportedScopes: ['character'] },
    { name: 'is_player_heir_of', description: 'Is the scope character the player heir of the target character?', supportedScopes: ['character'] },
    { name: 'is_pledged_ghw_attacker', description: 'Is the scoped character a pledged attacker in the current GHW (it\'s an error to check this if there\'s no GHW around)', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'is_pool_character', description: 'Is the character in the pool? (not a ruler, courtier or guest at any court)', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'is_pool_guest', description: 'Is the character a guest from the pool? In contrast to is_foreign_court_guest the character has no liege', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'is_pool_guest_of', description: 'Is the character a guest from the pool, visiting the target character\'s court? In contrast to is_foreign_court_guest_of the character has no liege', supportedScopes: ['character'] },
    { name: 'is_potential_knight', description: 'Is the scoped character a POTENTIAL knight to their liege?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'is_powerful_vassal', description: 'Is the character a powerful vassal?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'is_powerful_vassal_of', description: 'Is the character a powerful vassal of the target?', supportedScopes: ['character'] },
    { name: 'is_pregnant', description: 'is the character pregnant?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'is_primary_heir_of', description: 'Is the character the heir of the target\'s primary title?', supportedScopes: ['character'] },
    { name: 'is_ruler', description: 'Is the scope character a ruler (holds any title)?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'is_scheming_against', description: 'Checks whether the scope character is an owner or an owner agent in a scheme agains target. There are 3 possible ways to use it:', supportedScopes: ['character'], syntax: "is_scheming_against = { target = X type = Y } limits to schemes of type Y\nis_scheming_against = { target = X scheme_skill = Y } limits to schemes of Y skill category\nis_scheming_against = { target = X } considers all schemes" },
    { name: 'is_sibling_of', description: 'Is the character a sibling of the target character?', supportedScopes: ['character'] },
    { name: 'is_spouse_of', description: 'Is the character a spouse of the target character, and are both alive?', supportedScopes: ['character'] },
    { name: 'is_spouse_of_even_if_dead', description: 'Is the character a spouse of the target character, even if one or both are dead?', supportedScopes: ['character'] },
    { name: 'is_successor_of_accolade', description: 'Is the scoped character the successor of a given Accolade?', supportedScopes: ['character'], supportedTargets: ['accolade'], syntax: "is_successor_of_accolade = accolade" },
    { name: 'is_theocratic_lessee', description: 'Is the scope character a theocratic lessee (bishop)?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'is_travel_entourage_character', description: 'Is the character travelling and part of the entourage? (travel leader is part of the entourage)', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'is_travel_leader', description: 'Is the character travelling and the active travel leader?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'is_travelling', description: 'Is the character currently travelling?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'is_twin_of', description: 'Is the character a twin of the target character?', supportedScopes: ['character'] },
    { name: 'is_unborn_child_of_concubine', description: 'Is the unborn a child of a concubine?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'is_unborn_known_bastard', description: 'Is the unborn a known bastard?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'is_uncle_or_aunt_of', description: 'Is the character an uncle or aunt of the target character?', supportedScopes: ['character'] },
    { name: 'is_valid_as_agent_in_scheme', description: 'Is the scope character suitable as an agent for the target scheme?', supportedScopes: ['character'], supportedTargets: ['scheme'] },
    { name: 'is_valid_for_event_debug', description: 'is the scoped character valid for the given event, without checking event cooldown?', supportedScopes: ['character'], syntax: "NOTE: this is only for debug purposes and will not work in release mode!\nis_valid_for_event_debug = event_key" },
    { name: 'is_valid_for_event_debug_cooldown', description: 'is the scoped character valid for the given event, including a cooldown check?', supportedScopes: ['character'], syntax: "NOTE: this is only for debug purposes and will not work in release mode!\nis_valid_for_event_debug_cooldown = event_key" },
    { name: 'is_valid_successor_for_accolade', description: 'Is the scoped character a valid candidate to take over as successor of this Accolade?', supportedScopes: ['character'], supportedTargets: ['accolade'], syntax: "is_valid_successor_for_accolade = accolade" },
    { name: 'is_vassal_of', description: 'Is the character a direct vassal of the target character?', supportedScopes: ['character'] },
    { name: 'is_vassal_or_below_of', description: 'is the scope character a vassal or below of the target character? Non-rulers are not considered vassals', supportedScopes: ['character'] },
    { name: 'is_visibly_fertile', description: 'Is the scoped character visibly fertile, that is: not too old if a woman, not too young and has no traits blocking having children', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'join_faction_chance', description: 'Check if the chance of the scope character to join the faction against the scripted value', supportedScopes: ['character'], valueType: 'comparison', syntax: "join_faction_chance = {\ntarget = faction_target #An ongoing faction\nvalue <|<=|>=|> 0\n}" },
    { name: 'join_scheme_chance', description: 'Check if the change of the scope character is between the given range (being min and max exclusive)', supportedScopes: ['character'], syntax: "join_scheme_chance = {\nscheme = scheme_target #An ongoing scheme\nmax = 0\nmin = -10\n}" },
    { name: 'knows_court_language_of', description: 'Does the character know the court language of the target character?', supportedScopes: ['character'], supportedTargets: ['character'], syntax: "knows_court_language_of = scope:target_character" },
    { name: 'knows_language', description: 'Does the character know the language?', supportedScopes: ['character'], syntax: "knows_language = language_norwegian" },
    { name: 'knows_language_of_culture', description: 'Does the character know the language of the target culture?', supportedScopes: ['character'], supportedTargets: ['culture'], syntax: "knows_language_of_culture = scope:target_culture" },
    { name: 'learning', description: 'does the character have the required learning skill level?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'learning_diff', description: 'does the character have the required learning skill level difference against target?', supportedScopes: ['character'], valueType: 'comparison', syntax: "learning = { target = character value <= script_value abs = yes/no(optional, default no) }" },
    { name: 'learning_for_portrait', description: 'Learning skill scaled between 0.0 and 1.0 for portraits', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'learning_lifestyle_perk_points', description: 'How many perk points available does the character have?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'learning_lifestyle_perks', description: 'How many perks from this lifestyle does the character have?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'learning_lifestyle_unlockable_perks', description: 'How many perks from this lifestyle can the character currently unlock? This checks that they have the parent perks, and that the can_be_picked is met. It doesn\'t check perk points', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'learning_lifestyle_xp', description: 'How many perk points available does the character have?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'long_term_gold', description: 'does the character have the required gold? (AI category \'long term\')', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'long_term_gold_maximum', description: 'How big is the \'long term\' budget is supposed to get?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'mandate_type_qualification', description: 'Diarch qualification for spefic mandate type', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'martial', description: 'does the character have the required martial skill level?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'martial_diff', description: 'does the character have the required martial skill level difference against target?', supportedScopes: ['character'], valueType: 'comparison', syntax: "martial = { target = character value <= script_value abs = yes/no(optional, default no) }" },
    { name: 'martial_for_portrait', description: 'Martial skill scaled between 0.0 and 1.0 for portraits', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'martial_lifestyle_perk_points', description: 'How many perk points available does the character have?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'martial_lifestyle_perks', description: 'How many perks from this lifestyle does the character have?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'martial_lifestyle_unlockable_perks', description: 'How many perks from this lifestyle can the character currently unlock? This checks that they have the parent perks, and that the can_be_picked is met. It doesn\'t check perk points', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'martial_lifestyle_xp', description: 'How many perk points available does the character have?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'matrilinear_betrothal', description: 'Is this character\'s betrothal matrilinear? False if there\'s no betrothal.', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'matrilinear_marriage', description: 'Is the marriage with the spouse matrilinear?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'max_active_accolades', description: 'How many active accolades can this character have at most?', supportedScopes: ['character'], valueType: 'comparison', syntax: "max_active_accolades <= 3" },
    { name: 'max_military_strength', description: 'Is the scoped character\'s max military strength this big?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'max_number_maa_soldiers_of_base_type', description: 'Does the scope character have value amount of max soldiers of MaA of the base type?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'max_number_maa_soldiers_of_type', description: 'Does the scope character have value amount of max soldiers of MaA of the type?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'max_number_of_concubines', description: 'The maximum number of concubines a character can have', supportedScopes: ['character'], valueType: 'comparison', syntax: "max_number_of_concubines > 2" },
    { name: 'max_number_of_knights', description: 'Check how many knights the scoped character can potentially have', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'missing_unique_ancestors', description: 'The amount of missing unique ancestors from the characters real father and mother', supportedScopes: ['character'], valueType: 'comparison', syntax: "Traverses the family tree for NDefines::NChildbirth::INBREEDING_ANCESTOR_GENERATIONS amount of generations. By default this means that we're traversing 62 ancestors and report the amount of duplicates we find.\ncalc_missing_unique_ancestors > 10" },
    { name: 'monthly_character_balance', description: 'Is the scoped character\'s monthly balance this big?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'monthly_character_expenses', description: 'Is the scoped character\'s monthly expenses this big?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'monthly_character_income', description: 'Is the scoped character\'s monthly income this big?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'monthly_character_income_long_term', description: 'did the character allocate the required gold? (AI category long term)', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'monthly_character_income_reserved', description: 'did the character allocate the required gold? (AI category reserved)', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'monthly_character_income_short_term', description: 'did the character allocate the required gold? (AI category short term)', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'monthly_character_income_war_chest', description: 'did the character allocate the required gold? (AI category war chest)', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'monthly_character_men_at_arms_expense_gold', description: 'Is the scoped character\'s monthly military gold expenses this big? (unraised maa costs)', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'monthly_character_men_at_arms_expense_prestige', description: 'Is the scoped character\'s monthly military prestige expenses this big? (unraised maa costs)', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'months_as_ruler', description: 'Number of months this character has been a ruler, returns -1 if character isn\'t a ruler', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'morph_gene_attribute', description: 'Compare entity attribute from specific gene', supportedScopes: ['character'], valueType: 'comparison', syntax: "Example scope:character = {\nmorph_gene_attribute = {\ncategory = gene_height\nattribute = body_height\nvalue < 0.05\n}\n}\nAn interface trigger, can only be used in specific places" },
    { name: 'morph_gene_value', description: 'Compare value of specific gene. Does NOT take into account trait modifiers', supportedScopes: ['character'], valueType: 'comparison', syntax: "Example scope:character = {\nmorph_gene_attribute = {\ncategory = gene_height\nvalue < 0.05\n}\n}\nAn interface trigger, can only be used in specific places" },
    { name: 'num_active_accolades', description: 'How many active accolades does this character currently have?', supportedScopes: ['character'], valueType: 'comparison', syntax: "num_active_accolades < 4" },
    { name: 'num_inactive_accolades', description: 'How many inactive accolades does this character currently have?', supportedScopes: ['character'], valueType: 'comparison', syntax: "num_inactive_accolades > 0" },
    { name: 'num_of_bad_genetic_traits', description: 'Compare the number of bad genetic traits', supportedScopes: ['character'], valueType: 'comparison', syntax: "<charater> = { num_of_bad_genetic_traits = 0 }" },
    { name: 'num_of_good_genetic_traits', description: 'Compare the number of good genetic traits', supportedScopes: ['character'], valueType: 'comparison', syntax: "<charater> = { num_of_good_genetic_traits >= 2 }" },
    { name: 'num_of_known_languages', description: 'How many languages does the character know?', supportedScopes: ['character'], valueType: 'comparison', syntax: "num_of_known_languages > 1" },
    { name: 'num_of_relation_activity_recurrer', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'num_of_relation_antiquarian', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'num_of_relation_best_friend', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'num_of_relation_bully', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'num_of_relation_court_physician', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'num_of_relation_crush', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'num_of_relation_friend', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'num_of_relation_guardian', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'num_of_relation_intrigue_mentor', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'num_of_relation_intrigue_student', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'num_of_relation_lover', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'num_of_relation_mentor', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'num_of_relation_nemesis', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'num_of_relation_nursed_child', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'num_of_relation_oaf', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'num_of_relation_potential_friend', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'num_of_relation_potential_hook', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'num_of_relation_potential_lover', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'num_of_relation_potential_rival', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'num_of_relation_rival', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'num_of_relation_soldier_friend', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'num_of_relation_soulmate', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'num_of_relation_student', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'num_of_relation_victim', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'num_of_relation_ward', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'num_of_relation_wedding_bad_fertility', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'num_of_relation_wedding_good_fertility', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'num_of_relation_wedding_very_bad_fertility', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'num_of_relation_wedding_very_good_fertility', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'num_of_relation_wet_nurse', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'num_sinful_traits', description: 'Does the scoped character have this number of virtous traits?', supportedScopes: ['character'], valueType: 'comparison', syntax: "num_virtous_traits > 5 ORnum_virtous_traits = { value > 5 faith = scope:faith }, to base it on what a specific faith considers virtuous" },
    { name: 'num_virtuous_traits', description: 'Does the scoped character have this number of virtous traits?', supportedScopes: ['character'], valueType: 'comparison', syntax: "num_virtous_traits > 5 ORnum_virtous_traits = { value > 5 faith = scope:faith }, to base it on what a specific faith considers virtuous" },
    { name: 'number_maa_regiments_of_base_type', description: 'Does the scope character have value amount of MaA of the base type?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'number_maa_regiments_of_type', description: 'Does the scope character have value amount of MaA of the type?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'number_maa_soldiers_of_base_type', description: 'Does the scope character have value amount of soldiers of MaA of the base type?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'number_maa_soldiers_of_type', description: 'Does the scope character have value amount of soldiers of MaA of the type?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'number_of_commander_traits', description: 'does the character have this many commander traits?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'number_of_commander_traits_in_common', description: 'does the character and the target have a number of commander traits in common?', supportedScopes: ['character'], syntax: "number_of_personality_traits_in_common = { target = X value >/</>=/<= Y }" },
    { name: 'number_of_concubines', description: 'The number of concubines the scoped character has', supportedScopes: ['character'], valueType: 'comparison', syntax: "number_of_concubines > 2" },
    { name: 'number_of_desired_concubines', description: 'The number of fertile concubines the scoped character should have to not get penalties', supportedScopes: ['character'], valueType: 'comparison', syntax: "number_of_desired_concubines > 2" },
    { name: 'number_of_election_votes', description: 'Check the number of votes the scoped character has in the target title', supportedScopes: ['character'], valueType: 'comparison', syntax: "number_of_election_votes = { title = scope:actor.primary_title value = 0 }" },
    { name: 'number_of_fertile_concubines', description: 'The number of visibly fertile concubines the scoped character has', supportedScopes: ['character'], valueType: 'comparison', syntax: "number_of_fertile_concubines > 2" },
    { name: 'number_of_knights', description: 'Check how many knights the scoped character has at the moment', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'number_of_lifestyle_traits', description: 'does the character have this many lifestyle traits?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'number_of_maa_regiments', description: 'The number of men at arms the scoped character has', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'number_of_opposing_personality_traits', description: 'does the character and the target have a number of opposing personality traits?', supportedScopes: ['character'], syntax: "number_of_opposing_personality_traits = { target = X value >/</>=/<= Y }" },
    { name: 'number_of_opposing_traits', description: 'does the character and the target have a number of opposing traits?', supportedScopes: ['character'], syntax: "number_of_opposing_traits = { target = X value >/</>=/<= Y }" },
    { name: 'number_of_personality_traits', description: 'does the character have this many personality traits?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'number_of_personality_traits_in_common', description: 'does the character and the target have a number of personality traits in common?', supportedScopes: ['character'], syntax: "number_of_personality_traits_in_common = { target = X value >/</>=/<= Y }" },
    { name: 'number_of_powerful_vassals', description: 'Does the character have a specified number of powerful vassals?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'number_of_sinful_traits_in_common', description: 'do the two characters share a number of traits that is considered sinful by both of their respective faiths?', supportedScopes: ['character'], valueType: 'comparison', syntax: "number_of_sinful_traits_in_common = { target = X value >/</>=/<= Y }" },
    { name: 'number_of_stationed_maa_regiments', description: 'The number of stationed men at arms the scoped character has', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'number_of_traits', description: 'does the character have this many traits?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'number_of_traits_in_common', description: 'does the character and the target have a number of traits in common?', supportedScopes: ['character'], syntax: "number_of_traits_in_common = { target = X value >/</>=/<= Y }" },
    { name: 'number_of_virtue_traits_in_common', description: 'do the two characters share a number of traits that is considered virtuous by both of their respective faiths?', supportedScopes: ['character'], valueType: 'comparison', syntax: "number_of_virtue_traits_in_common = { target = X value >/</>=/<= Y }" },
    { name: 'opinion', description: 'is the character\'s opinion of the target greater or equal than the value? opinion = { target = X [*value >/</>=/<= Y* or *value = { min max }*  }', supportedScopes: ['character'] },
    { name: 'owns_a_story', description: 'checks whether the scope character is the owner of any currently active story', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'owns_story_of_type', description: 'Does the character own a story of this type?', supportedScopes: ['character'] },
    { name: 'patrilinear_betrothal', description: 'Is this character\'s betrothal patrilinear? False if there\'s no betrothal.', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'patrilinear_marriage', description: 'Is the marriage with the spouse patrilinear?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'perk_points', description: 'Does the character have this many perk points across all lifestyles combined?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'perk_points_assigned', description: 'Does the character have this many perk points assigned across all lifestyles combined?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'perks_in_tree', description: 'Does the character have this many perk points assigned to this tree? perks_in_tree = { tree = tree_key value > 5 }', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'piety', description: 'does the character have the required piety?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'piety_level', description: 'does the character have the required piety level?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'player_heir_position', description: 'Check where the target character is in the scoped character\'s player heir list.', supportedScopes: ['character'], valueType: 'comparison', syntax: "player_heir_position = { target = scope:actor position = 0 }" },
    { name: 'pregnancy_days', description: 'How long has the character been pregnant? Counts from impregnation, not reveal', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'prestige', description: 'does the character have the required prestige?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'prestige_level', description: 'does the character have the required prestige level?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'prowess', description: 'does the character have the required prowess skill level?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'prowess_diff', description: 'does the character have the required prowess skill level difference against target?', supportedScopes: ['character'], valueType: 'comparison', syntax: "prowess = { target = character value <= script_value abs = yes/no(optional, default no) }" },
    { name: 'prowess_for_portrait', description: 'Prowess skill scaled between 0.0 and 1.0 for portraits', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'prowess_no_portrait', description: 'does the character have the required prowess skill level (ignores the prowess_no_portrait modifier)?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'ransom_cost', description: 'what is the ransom cost of the character?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'realm_size', description: 'Is the scoped character\'s top liege\'s realm this big (# of counties)?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'realm_to_title_distance_squared', description: 'Is the character\'s realm within this distance of the title? Distance is in pixels, squared for performance reasons. realm_to_title_distance_squared = { title = some_title value > 10000 }', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'reserved_gold', description: 'does the character have the required gold? (AI category \'reserved\')', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'reserved_gold_maximum', description: 'How big is the \'reserved\' budget is supposed to get?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'reverse_has_opinion_modifier', description: 'does the target have the specified opinion modifier on the character? (optional *value <|<=|=|>=|> X* or *value = { MIN MAX }* inclusive)', supportedScopes: ['character'] },
    { name: 'reverse_opinion', description: 'is the target character\'s opinion of the scope character greater or equal than the value? opinion = { target = X value >/</>=/<= Y }', supportedScopes: ['character'] },
    { name: 'scriptedtests_can_marry_character', description: 'can the character marry the target character?', supportedScopes: ['character'] },
    { name: 'scriptedtests_dread_base', description: 'does the character have the specified dread baseline value?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'scriptedtests_gold_income_no_theocracy', description: 'does the character have the specified tax income, excluding income from the theocratic lessee?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'scriptedtests_piety_income', description: 'does the character have the specified piety income?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'sex_opposite_of', description: 'Are the scope character the target character of the opposite sex?', supportedScopes: ['character'] },
    { name: 'sex_same_as', description: 'Are the scope character the target character of the same sex?', supportedScopes: ['character'] },
    { name: 'short_term_gold', description: 'does the character have the required gold? (AI category \'short term\')', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'short_term_gold_maximum', description: 'How big is the \'short term\' budget is supposed to get?(It may exceed this if all other budgets are full)', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'should_decision_create_alert', description: 'Is the scoped decision an important decision for the target character?', supportedScopes: ['character'], supportedTargets: ['decision'] },
    { name: 'should_notify_can_host_activity', description: 'should_notify_can_host_activity = target_activity', supportedScopes: ['character'], supportedTargets: ['activity_type'], syntax: "Should the scoped character be alerted that they can host the target activity type" },
    { name: 'should_notify_can_join_open_activity', description: 'should_notify_can_join_open_activity = target_activity', supportedScopes: ['character'], supportedTargets: ['activity_type'], syntax: "Should the scoped character be alerted that they can join the target activity type" },
    { name: 'stewardship', description: 'does the character have the required stewardship skill level?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'stewardship_diff', description: 'does the character have the required stewardship skill level difference against target?', supportedScopes: ['character'], valueType: 'comparison', syntax: "stewardship = { target = character value <= script_value abs = yes/no(optional, default no) }" },
    { name: 'stewardship_for_portrait', description: 'Stewardship skill scaled between 0.0 and 1.0 for portraits', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'stewardship_lifestyle_perk_points', description: 'How many perk points available does the character have?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'stewardship_lifestyle_perks', description: 'How many perks from this lifestyle does the character have?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'stewardship_lifestyle_unlockable_perks', description: 'How many perks from this lifestyle can the character currently unlock? This checks that they have the parent perks, and that the can_be_picked is met. It doesn\'t check perk points', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'stewardship_lifestyle_xp', description: 'How many perk points available does the character have?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'stress', description: 'does the character have the required stress?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'stress_level', description: 'does the character have the required stress level?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'strife_opinion', description: 'Strife opinion value accumulated by the character', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'sub_realm_size', description: 'Is the scoped character\'s sub-realm this big (# of counties)?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'target_is_liege_or_above', description: 'is the target character the liege or above the scope character?', supportedScopes: ['character'] },
    { name: 'target_is_same_character_or_above', description: 'is the target character the the same character or above (in the vassal hierarchy) the scope character?', supportedScopes: ['character'] },
    { name: 'target_is_vassal_or_below', description: 'is the target character a vassal or below of the scope character? Non-rulers are not considered vassals', supportedScopes: ['character'] },
    { name: 'target_weight', description: 'Target weight of the scoped character', supportedScopes: ['character'], valueType: 'comparison', syntax: "target_weight > 10" },
    { name: 'tier_difference', description: 'What is the difference in highest_held_title_tier between the scoped character and the target character (-5 to 5)', supportedScopes: ['character'], syntax: "For example, this is true:\nscope:a_baron = {\ntier_difference = {\ntarget = scope:a_king\nvalue = -3\n}\n}" },
    { name: 'time_after_diarch_designated', description: 'How much time passed after diarch was designated?', supportedScopes: ['character'], syntax: "time_after_designated_diarch = { days/months/years =,>,< X }" },
    { name: 'time_in_prison', description: 'for how long has the character been imprisoned? time_in_prison = { days/months/years =,>,< X }', supportedScopes: ['character'] },
    { name: 'time_in_prison_type', description: 'for how long has the character been imprisoned with the current type? time_in_prison_type = { days/months/years =,>,< X }', supportedScopes: ['character'] },
    { name: 'time_since_death', description: 'for how long has the character is dead? time_since_death  = { days/months/years =,>,< X }', supportedScopes: ['character'] },
    { name: 'time_to_hook_expiry', description: 'The # of days until the scoped character\'s hook on the target expires', supportedScopes: ['character'], valueType: 'comparison', syntax: "time_to_hook_expiry = { target = someone value > 50 }" },
    { name: 'trait_compatibility', description: 'target = other character value >/</= sum of trait compatibility values', supportedScopes: ['character'] },
    { name: 'travel_leader_cost', description: 'What this character would cost as a travel leader', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'travel_leader_safety', description: 'The safety-aptitude of the current travel leader', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'travel_leader_speed', description: 'The speed-aptitude of the current travel leader', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'tyranny', description: 'does the character have the required tyranny?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'vassal_contract_has_flag', description: 'Do any of the current active obligations in the scoped character\'s vassal contract have the given flag', supportedScopes: ['character'] },
    { name: 'vassal_contract_has_modifiable_obligations', description: 'Can the scoepd character\'s contract be modified at all, that is: they have one, they use obligation levels, and are count or above', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'vassal_contract_is_blocked_from_modification', description: 'Has the scoepd character\'s contract been blocked from modification by script via \'set_vassal_contract_modification_blocked\'', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'vassal_contract_obligation_level', description: 'The level of the provided contract type in the scoped character\'s current vassal contract', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'vassal_contract_obligation_level_can_be_decreased', description: 'Can the obligation level of the scoped character\'s vassal contract be decreasde?', supportedScopes: ['character'] },
    { name: 'vassal_contract_obligation_level_can_be_increased', description: 'Can the obligation level of the scoped character\'s vassal contract be increased?', supportedScopes: ['character'] },
    { name: 'vassal_contract_obligation_level_score', description: 'The score in favour of the avassal for the provided contract type in the scoped character\'s current vassal contract', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'vassal_count', description: 'Is the scoped character\'s number of vassals (excluding barons) this high?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'vassal_limit', description: 'Is the scoped character\'s vassal limit this big?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'vassal_limit_available', description: 'Is there this much space left in the character\'s vassal limit? Negative values also work for checking characters that are above their limit', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'vassal_limit_percentage', description: 'Is the scoped character\'s vassal count this big in comparison to their limit?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'war_chest_gold', description: 'does the character have the required gold? (AI category \'war chest\')', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'war_chest_gold_maximum', description: 'How big is the \'war chest\' budget is supposed to get?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'was_hostage_child', description: 'Was the scoped character a Hostage as a Child?', supportedScopes: ['character'], valueType: 'boolean' },
    { name: 'year_of_birth', description: 'Get character year_of_birth: scope:character = { year_of_birth > 1096 }', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'yearly_character_balance', description: 'Is the scoped character\'s yearly balance this big?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'yearly_character_expenses', description: 'Is the scoped character\'s yearly expenses this big?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'yearly_character_income', description: 'Is the scoped character\'s yearly income this big?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'yearly_character_men_at_arms_expense_gold', description: 'Is the scoped character\'s yearly military gold expenses this big? (unraised maa costs)', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'yearly_character_men_at_arms_expense_prestige', description: 'Is the scoped character\'s yearly military prestige expenses this big? (unraised maa costs)', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'years_as_diarch', description: 'How many whole years has the character been an active diarch?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'years_as_ruler', description: 'Number of years this character has been a ruler, returns -1 if character isn\'t a ruler', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'years_in_diarchy', description: 'How many whole years has liege spent in a diarchy?', supportedScopes: ['character'], valueType: 'comparison' },
    { name: 'yields_alliance', description: 'Checks if the character would get an alliance with the target character through such a marriage.', supportedScopes: ['character'] },
];
/**
 * Triggers for landed_title scope (89 triggers)
 */
exports.landedtitleTriggers = [
    { name: 'active_de_jure_drift_progress', description: 'task_current_value = scope:county.active_de_jure_drift_progress', supportedScopes: ['landed_title'], valueType: 'comparison' },
    { name: 'any_claimant', description: 'Iterate through all claimants to title. parameters: explicit = yes/no/all - default yes', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_claimant = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_connected_county', description: 'Iterate through all counties connected to this one. Is based on top liege', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any/every/whatever_connectec_county = {\nmax_naval_distance = 500\nallow_one_county_land_gap = yes\nany_connected_county = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_controlled_faith', description: 'Iterate through all faiths headed by a title', supportedScopes: ['landed_title'], supportedTargets: ['faith'], outputScope: 'faith', isIterator: true, valueType: 'block', syntax: "any_controlled_faith = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_county_province', description: 'Iterate through all provinces in a county', supportedScopes: ['landed_title'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, valueType: 'block', syntax: "any_county_province = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_county_struggle', description: 'Iterate through all struggles that a county is involved in.', supportedScopes: ['landed_title'], supportedTargets: ['struggle'], outputScope: 'struggle', isIterator: true, valueType: 'block', syntax: "any_county_struggle = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_de_jure_county', description: 'Iterate through all counties within this dejure title', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_de_jure_county = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_de_jure_county_holder', description: 'Iterate through all characters directly holding counties within this dejure title', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_de_jure_county_holder = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_de_jure_top_liege', description: 'Iterate through all top lieges of the counts within this dejure title', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_de_jure_top_liege = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_dejure_vassal_title_holder', description: 'Iterate through all the vassal holders of the title', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_dejure_vassal_title_holder = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_direct_de_facto_vassal_title', description: 'Iterate through all de facto vassal titles', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_direct_de_facto_vassal_title = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_direct_de_jure_vassal_title', description: 'Iterate through the all de jure vassals titles', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_direct_de_jure_vassal_title = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_election_candidate', description: 'Iterate through all characters who are valid candidates in an election for a title', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_election_candidate = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_elector', description: 'Iterate through all characters who are valid electors in an election for a title', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_elector = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_in_de_facto_hierarchy', description: 'Iterate through the title itself, all de facto vassals, and below. The continue trigger specifies whether to recursively iterate through the vassal\'s vassal', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "This is unrelated to the limit; if the limit is met it is added to the list, but its vassals will get checked even if the limit isn't met as long as the 'continue' trigger is\n..._de_jure_vassal_and_below = { continue = { conditions } }\nany_in_de_facto_hierarchy = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_in_de_jure_hierarchy', description: 'Iterate through the title itself, all de jure vassals, and below. The continue trigger specifies whether to recursively iterate through the vassal\'s vassal', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "This is unrelated to the limit; if the limit is met it is added to the list, but its vassals will get checked even if the limit isn't met as long as the 'continue' trigger is\n..._de_jure_vassal_and_below = { continue = { conditions } }\nany_in_de_jure_hierarchy = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_neighboring_county', description: 'Iterate through all neighboring counties. Can only be used in county scope', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_neighboring_county = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_past_holder', description: 'Iterate through all past owners of a title from earliest to latest', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_past_holder = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_past_holder_reversed', description: 'Iterate through all past owners of a title from latest to earliest', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_past_holder_reversed = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_this_title_or_de_jure_above', description: 'Iterate through this title and all its dejure liege titles', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_this_title_or_de_jure_above = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_title_heir', description: 'Line of succession for the scoped title', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_title_heir = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_title_joined_faction', description: 'Iterate through all factions joined the scope landed title', supportedScopes: ['landed_title'], supportedTargets: ['faction'], outputScope: 'faction', isIterator: true, valueType: 'block', syntax: "any_title_joined_faction = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_title_to_title_neighboring_and_across_water_county', description: 'Scopes from a title to a neighboring county (incl. across water, looking trough the de Jure lieges)', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_title_to_title_neighboring_and_across_water_county = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_title_to_title_neighboring_and_across_water_duchy', description: 'Scopes from a title to a neighboring duchy (incl. across water, looking trough the de Jure lieges)', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_title_to_title_neighboring_and_across_water_duchy = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_title_to_title_neighboring_and_across_water_empire', description: 'Scopes from a title to a neighboring empire (incl. across water, looking trough the de Jure lieges)', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_title_to_title_neighboring_and_across_water_empire = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_title_to_title_neighboring_and_across_water_kingdom', description: 'Scopes from a title to a neighboring kingdom (incl. across water, looking trough the de Jure lieges)', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_title_to_title_neighboring_and_across_water_kingdom = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_title_to_title_neighboring_county', description: 'Scopes from a title to a neighboring county (looking trough the de Jure lieges)', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_title_to_title_neighboring_county = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_title_to_title_neighboring_duchy', description: 'Scopes from a title to a neighboring duchy (looking trough the de Jure lieges)', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_title_to_title_neighboring_duchy = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_title_to_title_neighboring_empire', description: 'Scopes from a title to a neighboring empire (looking trough the de Jure lieges)', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_title_to_title_neighboring_empire = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_title_to_title_neighboring_kingdom', description: 'Scopes from a title to a neighboring kingdom (looking trough the de Jure lieges)', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_title_to_title_neighboring_kingdom = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'can_be_leased_out', description: 'Can the scoped title be leased out?', supportedScopes: ['landed_title'], valueType: 'boolean' },
    { name: 'can_title_create_faction', description: 'can the title create the faction of the specified type against the specified character?', supportedScopes: ['landed_title'], syntax: "can_title_create_faction = { type = X target = Y }" },
    { name: 'can_title_join_faction', description: 'Can the scope title join the faction? can_title_join_faction = faction', supportedScopes: ['landed_title'], supportedTargets: ['faction'] },
    { name: 'county_control', description: 'does the county title have the required county countrol?', supportedScopes: ['landed_title'], valueType: 'comparison' },
    { name: 'county_control_rate', description: 'how much county control is the county gaining each month?', supportedScopes: ['landed_title'], valueType: 'comparison' },
    { name: 'county_control_rate_modifier', description: 'What\'s the multiplier to the control gain rate? E.G., if there\'s just a +20% modifier, this would return 1.2', supportedScopes: ['landed_title'], valueType: 'comparison' },
    { name: 'county_holder_opinion', description: 'Compares the county\'s opinion of its holder', supportedScopes: ['landed_title'], valueType: 'comparison' },
    { name: 'county_opinion', description: 'compares the county\'s opinion of the current count', supportedScopes: ['landed_title'], valueType: 'comparison' },
    { name: 'county_opinion_target', description: 'compares the county\'s opinion of the target character to the specified value, county_opinion_target = { target = X value >/</= Y }', supportedScopes: ['landed_title'] },
    { name: 'de_jure_drift_progress', description: 'Compare drift progress towards target with value<drifting_title> = { de_jure_drif_progress = {     target = <drift_target_title>    value > 50 } }', supportedScopes: ['landed_title'] },
    { name: 'de_jure_drifting_towards', description: 'Is the scoped landed title de jure drifts toward another title?<drifting_title> = { de_jure_drifting_towards = <drift_target_title> }', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'] },
    { name: 'development_level', description: 'does the county title have the required county development level?', supportedScopes: ['landed_title'], valueType: 'comparison' },
    { name: 'development_rate', description: 'how much development progress is the county gaining each month?', supportedScopes: ['landed_title'], valueType: 'comparison' },
    { name: 'development_rate_modifier', description: 'What\'s the multiplier to the development progress?', supportedScopes: ['landed_title'], valueType: 'comparison' },
    { name: 'development_towards_level_increase', description: 'does the county title have the required progress towards the next level of development? E.G., if level 1 is 100, level 2 is 300 (these are set in defines), and current total is 150, this would return 50', supportedScopes: ['landed_title'], valueType: 'comparison' },
    { name: 'has_character_nominiated', description: 'Has the target character nominated a successor for the scoped title', supportedScopes: ['landed_title'] },
    { name: 'has_county_modifier', description: 'Does the scoped county have a given modifier', supportedScopes: ['landed_title'], syntax: "has_county_modifier = name" },
    { name: 'has_county_modifier_duration_remaining', description: 'Does the scoped county have the duration remaining on a given modifier', supportedScopes: ['landed_title'], syntax: "has_county_modifier_duration_remaining = name" },
    { name: 'has_disabled_building', description: 'Is the scope landed title connected to a holding that contains at least one disabled building?', supportedScopes: ['landed_title'], valueType: 'boolean' },
    { name: 'has_holy_site_flag', description: 'Does the barony have a holy site with the given flag? has_holy_site_flag = some flag', supportedScopes: ['landed_title'] },
    { name: 'has_order_of_succession', description: 'Does the scoped title have a given order of succession', supportedScopes: ['landed_title'], syntax: "has_order_of_succession = election" },
    { name: 'has_revokable_lease', description: 'Is the title under a lease that can be revoked manually?', supportedScopes: ['landed_title'], valueType: 'boolean' },
    { name: 'has_title_law', description: 'Does the scoped title have the given title-specifc-law?', supportedScopes: ['landed_title'] },
    { name: 'has_title_law_flag', description: 'Does the scoped title have a title-specific law with the given flag?', supportedScopes: ['landed_title'] },
    { name: 'has_user_set_coa', description: 'Has the user set a specific coat of arms for this title?', supportedScopes: ['landed_title'], valueType: 'boolean' },
    { name: 'has_wrong_holding_type', description: 'Is the scope landed title connected to a holding that cannot be governed by the current lessee or holder?', supportedScopes: ['landed_title'], valueType: 'boolean' },
    { name: 'is_capital_barony', description: 'Is title in the scope a capital barony?', supportedScopes: ['landed_title'], valueType: 'boolean' },
    { name: 'is_coastal_county', description: 'is the county coastal?', supportedScopes: ['landed_title'], valueType: 'boolean' },
    { name: 'is_connected_to', description: 'Is the county connected to the other county? Is based on top liege', supportedScopes: ['landed_title'], syntax: "is_connected_to = {\nmax_naval_distance = 500\nallow_one_county_land_gap = yes\ntarget = some other county\n}" },
    { name: 'is_contested', description: 'Is the scope landed title contested in any war?', supportedScopes: ['landed_title'], valueType: 'boolean' },
    { name: 'is_de_facto_liege_or_above_target', description: 'is the title de facto liege or above the target title?', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'] },
    { name: 'is_de_jure_liege_or_above_target', description: 'is the title de jure liege or above the target title?', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'] },
    { name: 'is_head_of_faith', description: 'Is this title a head of faith title', supportedScopes: ['landed_title'], valueType: 'boolean' },
    { name: 'is_holy_order', description: 'Is the scope landed title a holy order?', supportedScopes: ['landed_title'], valueType: 'boolean' },
    { name: 'is_holy_site', description: 'Is the barony a holy site of any faith? is_holy_site = yes', supportedScopes: ['landed_title'], valueType: 'boolean' },
    { name: 'is_holy_site_controlled_by', description: 'Does the target character control a holy site of the scoped object', supportedScopes: ['landed_title'], supportedTargets: ['character'], syntax: "is_holy_site_controlled_by = root" },
    { name: 'is_holy_site_of', description: 'Is the barony a holy site of the given faith? is_holy_site_of = some faith', supportedScopes: ['landed_title'], supportedTargets: ['faith'] },
    { name: 'is_landless_type_title', description: 'Is this title considered a landless type title?', supportedScopes: ['landed_title'], valueType: 'boolean' },
    { name: 'is_leased_out', description: 'Is the scoped title leased out?', supportedScopes: ['landed_title'], valueType: 'boolean' },
    { name: 'is_mercenary_company', description: 'Is the scope landed title a mercenary company?', supportedScopes: ['landed_title'], valueType: 'boolean' },
    { name: 'is_neighbor_to_realm', description: 'Is this landed title adjacent to the character\'s realm', supportedScopes: ['landed_title'], supportedTargets: ['character'], syntax: "is_neighbor_to_realm = character" },
    { name: 'is_riverside_county', description: 'is the county riverside?', supportedScopes: ['landed_title'], valueType: 'boolean' },
    { name: 'is_target_of_council_task', description: 'Is the county currently affected by the specified council task? Needs to be in a county title scope', supportedScopes: ['landed_title'] },
    { name: 'is_title_created', description: 'Is title in the scope created?', supportedScopes: ['landed_title'], valueType: 'boolean' },
    { name: 'is_titular', description: 'Is this title titular (has no dejure counties in it, and is not a barony/county)?', supportedScopes: ['landed_title'], valueType: 'boolean' },
    { name: 'is_under_holy_order_lease', description: 'Is the scoped title leased out to any holy order?', supportedScopes: ['landed_title'], valueType: 'boolean' },
    { name: 'place_in_line_of_succession', description: 'what place in line of succession does the character hold?', supportedScopes: ['landed_title'] },
    { name: 'recent_history', description: 'Does the scope title have a history entry of the specified type in recent history?', supportedScopes: ['landed_title'], syntax: "recent_history = { type = X days/months/years = Y }\nThe type can be omitted, all history types are considered then\nPossible types:\nconquest\nconquest_holy_war\nconquest_claim\nconquest_populist\nelection\ninheritance\nabdication\ncreated\ndestroyed\nusurped\ngranted\nrevoked\nindependency\nleased_out\nlease_revoked\nreturned\nfaction_demand\nswear_fealty" },
    { name: 'target_is_de_facto_liege_or_above', description: 'is the target title de facto liege or above?', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'] },
    { name: 'target_is_de_jure_liege_or_above', description: 'is the target title de jure liege or above?', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'] },
    { name: 'tier', description: 'What tier is the scoped title? barony = 1, empire = 5. Use the script values please, not raw numbers', supportedScopes: ['landed_title'], valueType: 'comparison' },
    { name: 'title_create_faction_type_chance', description: 'Check if the chance to create a faction against a target of the scope landed title is is true against the scripted value', supportedScopes: ['landed_title'], syntax: "title_create_faction_type_chance = {\ntype = faction_type #An ongoing faction\ntarget = target_character\nvalue <|<=|>=|> 0\n}" },
    { name: 'title_held_years', description: 'Returns the number of years a title is held if valid (otherwise returns 0)', supportedScopes: ['landed_title'], valueType: 'comparison' },
    { name: 'title_is_a_faction_member', description: 'Is the scope title a member of a faction?', supportedScopes: ['landed_title'], valueType: 'boolean' },
    { name: 'title_join_faction_chance', description: 'Check if the chance of the scope landed title to join the faction against the scripted value', supportedScopes: ['landed_title'], valueType: 'comparison', syntax: "title_join_faction_chance = {\nfaction = faction_target #An ongoing faction\nvalue <|<=|>=|> 0\n}" },
    { name: 'title_will_leave_sub_realm_on_succession', description: 'Will the title leave the sub-realm of the character on the right-hand-side upon succession? That is, is the first heir in someone outside the sub-realm, and the highest tier title they\'ll inherit from the person holding the title is not higher than their current tier', supportedScopes: ['landed_title'] },
    { name: 'building_levies', description: 'The amount of levies in a county or province from buildings', supportedScopes: ['landed_title', 'province'], valueType: 'comparison', syntax: "levies > 100" },
    { name: 'building_max_garrison', description: 'The max amount of garrison in a county or province from buildings', supportedScopes: ['landed_title', 'province'], valueType: 'comparison', syntax: "levies > 100" },
    { name: 'squared_distance', description: 'How far away is the province/barony/county from the target? Measured in map pixels. Squared for performance reasons (square root is expensive). squared_distance = { target = some province/barony/county value > 10000 }', supportedScopes: ['landed_title', 'province'], valueType: 'comparison' },
];
/**
 * Triggers for province scope (37 triggers)
 */
exports.provinceTriggers = [
    { name: 'any_army_in_location', description: 'Iterate through all armies currently located in the scoped province', supportedScopes: ['province'], supportedTargets: ['army'], outputScope: 'army', isIterator: true, valueType: 'block', syntax: "any_army_in_location = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_character_in_location', description: 'Iterate through all characters currently located in the scoped province', supportedScopes: ['province'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_character_in_location = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_neighboring_province', description: 'Iterate through all neighboring provinces of a province', supportedScopes: ['province'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, valueType: 'block', syntax: "any_neighboring_province = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'available_loot', description: 'How much gold is available to loot for raiding armies?', supportedScopes: ['province'], valueType: 'comparison', syntax: "available_loot >= 7" },
    { name: 'building_slots', description: 'How many building slots exist (including occupied ones)?', supportedScopes: ['province'], valueType: 'comparison', syntax: "building_slots > 3" },
    { name: 'combined_building_level', description: 'How many levels of normal buildings are there? Duchy and such buildings do not count. Building under construction does not count. The capital building does count', supportedScopes: ['province'], valueType: 'comparison', syntax: "combined_building_level > 10" },
    { name: 'fort_level', description: 'Compares the fort level of a province', supportedScopes: ['province'], valueType: 'comparison' },
    { name: 'free_building_slots', description: 'How many free building slots exist? A building in construction is considered to be taking a slot', supportedScopes: ['province'], valueType: 'comparison', syntax: "free_building_slots > 3" },
    { name: 'geographical_region', description: 'Checks if a province is in a certain geographical region', supportedScopes: ['province'] },
    { name: 'has_building', description: 'does the scope province have a particular building?', supportedScopes: ['province'], syntax: "has_building = temple_01" },
    { name: 'has_building_or_higher', description: 'does the scope province have a particular building or its successor?', supportedScopes: ['province'], syntax: "has_building_or_higher = temple_01" },
    { name: 'has_building_with_flag', description: 'does the scope province have a building with a certain flag?', supportedScopes: ['province'], syntax: "has_building_with_flag = { flag = temple count >= 2 }\nhas_building_with_flag = temple # count >= 1" },
    { name: 'has_construction_with_flag', description: 'does the scope province have a construction of a building with the specified flag?', supportedScopes: ['province'], syntax: "has_construction_with_flag = temple" },
    { name: 'has_free_building_slot', description: 'does the scope province have a free building slot? has_free_building_slot = yes', supportedScopes: ['province'], valueType: 'boolean' },
    { name: 'has_holding', description: 'does the scope province have holding?', supportedScopes: ['province'], valueType: 'boolean', syntax: "has_holding = yes" },
    { name: 'has_holding_type', description: 'does the scope province have a holding of particular type?', supportedScopes: ['province'], syntax: "has_holding_type = castle_holding" },
    { name: 'has_ongoing_construction', description: 'does the scope province have a construction ongoing?', supportedScopes: ['province'], valueType: 'boolean', syntax: "has_ongoing_construction = yes" },
    { name: 'has_province_modifier', description: 'Does the scoped province have a given modifier', supportedScopes: ['province'], syntax: "has_province_modifier = name" },
    { name: 'has_province_modifier_duration_remaining', description: 'Does the scoped province have the duration remaining on a given modifier', supportedScopes: ['province'], syntax: "has_province_modifier_duration_remaining = name" },
    { name: 'has_special_building', description: 'Does the province (holding) have a special building?', supportedScopes: ['province'], valueType: 'boolean' },
    { name: 'has_special_building_slot', description: 'Does the province (holding) have a special building slot?', supportedScopes: ['province'], valueType: 'boolean' },
    { name: 'has_stationed_regiment', description: 'Does this province have stationed regiments?', supportedScopes: ['province'], valueType: 'boolean' },
    { name: 'has_stationed_regiment_of_base_type', description: 'Does the province have stationed regiment of base type?', supportedScopes: ['province'] },
    { name: 'has_travel_point_of_interest', description: 'Checks if there is a travel point of interest of type X in the province.', supportedScopes: ['province'], syntax: "has_travel_point_of_interest = point_of_interest_type" },
    { name: 'is_coastal', description: 'is the province a coastal province?', supportedScopes: ['province'], valueType: 'boolean' },
    { name: 'is_county_capital', description: 'is the province the county capital?', supportedScopes: ['province'], valueType: 'boolean' },
    { name: 'is_occupied', description: 'Is this province currently being occupied?', supportedScopes: ['province'], valueType: 'boolean' },
    { name: 'is_raided', description: 'Is this province currently being raided?', supportedScopes: ['province'], valueType: 'boolean' },
    { name: 'is_river_province', description: 'is the province a river?', supportedScopes: ['province'], valueType: 'boolean' },
    { name: 'is_riverside_province', description: 'is the province riverside?', supportedScopes: ['province'], valueType: 'boolean' },
    { name: 'is_sea_province', description: 'Is this a sea province?', supportedScopes: ['province'], valueType: 'boolean' },
    { name: 'monthly_income', description: 'Check the income of the scoped province', supportedScopes: ['province'], valueType: 'comparison', syntax: "monthly_income > 10" },
    { name: 'num_buildings', description: 'How many normal buildings are there? Duchy and such buildings do not count. Building under construction does count', supportedScopes: ['province'], valueType: 'comparison', syntax: "num_buildings > 3" },
    { name: 'number_of_characters_in_pool', description: 'Check the number of characters in the pool the scoped province is a part of', supportedScopes: ['province'], valueType: 'comparison' },
    { name: 'terrain', description: 'Checks if a province is of a specific terrain type', supportedScopes: ['province'] },
    { name: 'travel_danger_type', description: 'Checks if a province\'s danger type is of a specific type for a specific travel plan', supportedScopes: ['province'], syntax: "travel_danger_type = { travel_plan = scope:some_travel_plan type = name_of_danger_type }\ntravel_danger_type = { travel_plan = scope:some_travel_plan terrain = terrain type }" },
    { name: 'travel_danger_value', description: 'What is the province\'s danger value for a specific travel plan? travel_danger_value = { target = scope:some_travel_plan value > 1 }', supportedScopes: ['province'], valueType: 'comparison' },
];
/**
 * Triggers for dynasty scope (21 triggers)
 */
exports.dynastyTriggers = [
    { name: 'any_dynasty_member', description: 'Iterate through all dynasty members', supportedScopes: ['dynasty'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_dynasty_member = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'blood_legacy_track_perks', description: 'How many perks in the lifestyle does this dynasty have?', supportedScopes: ['dynasty'], valueType: 'comparison' },
    { name: 'dynasty_can_unlock_relevant_perk', description: 'Can the scoped dynasty unlock a \'relevant\' perk? Relevant meaning one that isn\'t the first in its track unless the dynasty has no partially filled tracks', supportedScopes: ['dynasty'], valueType: 'boolean' },
    { name: 'dynasty_num_unlocked_perks', description: 'does the dynasty has the required number of unlocked dynasty perks?', supportedScopes: ['dynasty'], valueType: 'comparison' },
    { name: 'dynasty_prestige', description: 'does the dynasty have the required prestige?', supportedScopes: ['dynasty'], valueType: 'comparison' },
    { name: 'dynasty_prestige_level', description: 'does the dynasty have the required prestige level?', supportedScopes: ['dynasty'], valueType: 'comparison' },
    { name: 'ep1_culture_legacy_track_perks', description: 'How many perks in the lifestyle does this dynasty have?', supportedScopes: ['dynasty'], valueType: 'comparison' },
    { name: 'ep2_activities_legacy_track_perks', description: 'How many perks in the lifestyle does this dynasty have?', supportedScopes: ['dynasty'], valueType: 'comparison' },
    { name: 'erudition_legacy_track_perks', description: 'How many perks in the lifestyle does this dynasty have?', supportedScopes: ['dynasty'], valueType: 'comparison' },
    { name: 'fp1_adventure_legacy_track_perks', description: 'How many perks in the lifestyle does this dynasty have?', supportedScopes: ['dynasty'], valueType: 'comparison' },
    { name: 'fp1_pillage_legacy_track_perks', description: 'How many perks in the lifestyle does this dynasty have?', supportedScopes: ['dynasty'], valueType: 'comparison' },
    { name: 'fp2_coterie_legacy_track_perks', description: 'How many perks in the lifestyle does this dynasty have?', supportedScopes: ['dynasty'], valueType: 'comparison' },
    { name: 'fp2_urbanism_legacy_track_perks', description: 'How many perks in the lifestyle does this dynasty have?', supportedScopes: ['dynasty'], valueType: 'comparison' },
    { name: 'glory_legacy_track_perks', description: 'How many perks in the lifestyle does this dynasty have?', supportedScopes: ['dynasty'], valueType: 'comparison' },
    { name: 'guile_legacy_track_perks', description: 'How many perks in the lifestyle does this dynasty have?', supportedScopes: ['dynasty'], valueType: 'comparison' },
    { name: 'has_dynasty_modifier', description: 'Does the scoped dynasty have a given modifier', supportedScopes: ['dynasty'], syntax: "has_dynasty_modifier = name" },
    { name: 'has_dynasty_modifier_duration_remaining', description: 'Does the scoped dynasty have the duration remaining on a given modifier', supportedScopes: ['dynasty'], syntax: "has_dynasty_modifier_duration_remaining = name" },
    { name: 'has_dynasty_perk', description: 'Does the dynasty have this dynasty perk? has_dynasty_perk = key', supportedScopes: ['dynasty'] },
    { name: 'kin_legacy_track_perks', description: 'How many perks in the lifestyle does this dynasty have?', supportedScopes: ['dynasty'], valueType: 'comparison' },
    { name: 'law_legacy_track_perks', description: 'How many perks in the lifestyle does this dynasty have?', supportedScopes: ['dynasty'], valueType: 'comparison' },
    { name: 'warfare_legacy_track_perks', description: 'How many perks in the lifestyle does this dynasty have?', supportedScopes: ['dynasty'], valueType: 'comparison' },
];
/**
 * Triggers for dynasty_house scope (5 triggers)
 */
exports.dynastyhouseTriggers = [
    { name: 'any_house_claimed_artifact', description: 'Iterate through all claimed artifacts of the scoped house', supportedScopes: ['dynasty_house'], supportedTargets: ['artifact'], outputScope: 'artifact', isIterator: true, valueType: 'block', syntax: "any_house_claimed_artifact = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_house_member', description: 'Iterate through all house members', supportedScopes: ['dynasty_house'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_house_member = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'has_house_artifact_claim', description: 'Does the scoped dynasty house have a personal claim on the target artifact', supportedScopes: ['dynasty_house'], supportedTargets: ['artifact'] },
    { name: 'has_house_modifier', description: 'Does the scoped house have a given modifier', supportedScopes: ['dynasty_house'], syntax: "has_house_modifier = name" },
    { name: 'has_house_modifier_duration_remaining', description: 'Does the scoped house have the duration remaining on a given modifier', supportedScopes: ['dynasty_house'], syntax: "has_house_modifier_duration_remaining = name" },
];
/**
 * Triggers for culture scope (34 triggers)
 */
exports.cultureTriggers = [
    { name: 'any_culture_county', description: 'Iterate through all counties of the culture', supportedScopes: ['culture'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_culture_county = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_culture_duchy', description: 'Iterate through all duchies of the culture (duchies with at least one county of the culture', supportedScopes: ['culture'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_culture_duchy = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_culture_empire', description: 'Iterate through all empires of the culture (empires with at least one county of the culture', supportedScopes: ['culture'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_culture_empire = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_culture_kingdom', description: 'Iterate through all kingdoms of the culture (kingdoms with at least one county of the culture', supportedScopes: ['culture'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_culture_kingdom = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_parent_culture', description: 'Iterate through all parent cultures', supportedScopes: ['culture'], supportedTargets: ['culture'], outputScope: 'culture', isIterator: true, valueType: 'block', syntax: "any_parent_culture = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_parent_culture_or_above', description: 'Iterate through all parent cultures or above', supportedScopes: ['culture'], supportedTargets: ['culture'], outputScope: 'culture', isIterator: true, valueType: 'block', syntax: "any_parent_culture_or_above = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_tradition', description: 'Iterate through all traditions of the given culture', supportedScopes: ['culture'], supportedTargets: ['culture_tradition'], outputScope: 'culture_tradition', isIterator: true, valueType: 'block', syntax: "any_tradition = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'can_get_innovation_from', description: 'Get random applicable innovation from another culture', supportedScopes: ['culture'] },
    { name: 'cultural_acceptance', description: 'The cultural acceptance of the scoped culture with the target culture', supportedScopes: ['culture'], valueType: 'comparison', syntax: "cultural_acceptance = { target = culture value > 50 }" },
    { name: 'culture_age', description: 'Checks the age of the scope culture in years. If the culture has no creation date set, this will simply return the current year', supportedScopes: ['culture'], valueType: 'comparison', syntax: "culture_age >= 200" },
    { name: 'culture_number_of_counties', description: 'How many counties are there of this culture?', supportedScopes: ['culture'], valueType: 'comparison', syntax: "culture_number_of_counties > 10" },
    { name: 'culture_overlaps_geographical_region', description: 'Checks if any county with this culture is in the given geographical region', supportedScopes: ['culture'] },
    { name: 'free_tradition_slot', description: 'How many free tradition slot are in the scoped culturescope:culture = { free_tradition_slot > 1 }', supportedScopes: ['culture'], valueType: 'comparison' },
    { name: 'has_all_innovations', description: 'Has the culture discovered all innovations matching the filter?', supportedScopes: ['culture'], syntax: "has_all_innovations = {\nwith_flag = flag_name # innovation matches if it has the flag; optional\nwithout_flag = flag_name # innovation matches if it does not have the flag; optional\nculture_era = era_key # innovation matches if it is from the era; optional\n}" },
    { name: 'has_building_gfx', description: 'Does the culture have this building gfx?', supportedScopes: ['culture'], syntax: "<culture> = { has_building_gfx = mena_building_gfx }" },
    { name: 'has_clothing_gfx', description: 'Does the culture have this clothing gfx?', supportedScopes: ['culture'], syntax: "<culture> = { has_building_gfx = mena_clothing_gfx }" },
    { name: 'has_coa_gfx', description: 'Does the culture have this CoA gfx?', supportedScopes: ['culture'], syntax: "<culture> = { has_building_gfx = mena_coa_gfx }" },
    { name: 'has_cultural_era_or_later', description: 'Has this culture achieved specified era<culture> = { has_cultural_era_or_later = culture_era_early_medieval }', supportedScopes: ['culture'] },
    { name: 'has_cultural_parameter', description: 'Does the culture have this cultural parameter?', supportedScopes: ['culture'], syntax: "<culture> = { has_cultural_parameter = name }" },
    { name: 'has_cultural_pillar', description: 'Does the culture have this cultural pillar?', supportedScopes: ['culture'], syntax: "<culture> = { has_cultural_pillar = name }" },
    { name: 'has_cultural_tradition', description: 'Does the culture have this cultural tradition scope?', supportedScopes: ['culture'], supportedTargets: ['culture_tradition'], syntax: "<culture> = { has_cultural_tradition = scope:traditon }" },
    { name: 'has_innovation', description: 'Have the culture discovered this innovation?', supportedScopes: ['culture'] },
    { name: 'has_innovation_flag', description: 'Has the culture discovered an innovation with this flag? has_innovation_flag = flag', supportedScopes: ['culture'] },
    { name: 'has_name_list', description: 'Does the culture have this name list?', supportedScopes: ['culture'], syntax: "<culture> = { has_name_list = name }" },
    { name: 'has_primary_name_list', description: 'Does the culture have this name list as its first name list?', supportedScopes: ['culture'], syntax: "<culture> = { has_primary_name_list = name }" },
    { name: 'has_same_culture_ethos', description: 'Does the culture have the same ethos as the target?', supportedScopes: ['culture'], supportedTargets: ['culture'] },
    { name: 'has_same_culture_heritage', description: 'Does the culture have the same heritage as the target?', supportedScopes: ['culture'], supportedTargets: ['culture'] },
    { name: 'has_same_culture_language', description: 'Does the culture have the same language as the target?', supportedScopes: ['culture'], supportedTargets: ['culture'] },
    { name: 'has_same_culture_martial_tradition', description: 'Does the culture have the same martial tradition as the target?', supportedScopes: ['culture'], supportedTargets: ['culture'] },
    { name: 'has_unit_gfx', description: 'Does the culture have this unit gfx?', supportedScopes: ['culture'], syntax: "<culture> = { has_unit_gfx = mena_unit_gfx }" },
    { name: 'is_divergent_culture', description: 'Checks if the scope culture was created by diverging from a single parent culture and returns yes if true or no if false.', supportedScopes: ['culture'], valueType: 'boolean', syntax: "is_divergent_culture = yes" },
    { name: 'is_hybrid_culture', description: 'Checks if the scope culture was created from a hybridization of two cultures and returns yes if true or no if false.', supportedScopes: ['culture'], valueType: 'boolean', syntax: "is_hybrid_culture = yes" },
    { name: 'num_discovered_innovations', description: 'Does the culture have the required number of discovered innovations?', supportedScopes: ['culture'], valueType: 'comparison', syntax: "num_discovered_innovations > 20" },
    { name: 'num_discovered_innovations_in_era', description: 'Does the scoped culture have the required number of active discovered innovations in the specified era?', supportedScopes: ['culture'], valueType: 'comparison', syntax: "num_discovered_innovations_in_era = {\nera = culture_era_early_medieval\nvalue > 5\n}\nnum_discovered_innovations_in_era:culture_era_early_medieval > 15\nnum_discovered_innovations_in_era:culture_era_early_medieval > scope:target_culture.num_discovered_innovations_in_era:culture_era_early_medieval" },
];
/**
 * Triggers for faith scope (25 triggers)
 */
exports.faithTriggers = [
    { name: 'any_defensive_great_holy_wars', description: 'Iterate through all great holy wars this faith is defending against', supportedScopes: ['faith'], supportedTargets: ['ghw'], outputScope: 'ghw', isIterator: true, valueType: 'block', syntax: "any_defensive_great_holy_wars = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_faith_character', description: 'Iterate through characters of the scoped faith', supportedScopes: ['faith'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_faith_character = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_faith_holy_order', description: 'Iterate through all holy orders of the faith', supportedScopes: ['faith'], supportedTargets: ['holy_order'], outputScope: 'holy_order', isIterator: true, valueType: 'block', syntax: "any_faith_holy_order = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_faith_playable_ruler', description: 'Iterate through playable rulers of the scoped faith', supportedScopes: ['faith'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_faith_playable_ruler = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_faith_ruler', description: 'Iterate through rulers of the scoped faith', supportedScopes: ['faith'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_faith_ruler = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_holy_site', description: 'Iterate through all holy site baronies of a faith', supportedScopes: ['faith'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_holy_site = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'controls_holy_site', description: 'Does the faith control a holy site? controls_holy_site = key_of_holy_site', supportedScopes: ['faith'] },
    { name: 'controls_holy_site_with_flag', description: 'Does the faith control a holy site with the given flag? controls_holy_site_with_flag = some flag', supportedScopes: ['faith'] },
    { name: 'estimated_faith_strength', description: 'How strong is the scoped faith? *Expensive*, if you\'re gonna use the value repeatedly, save it to a scope first! This is scaled by a factor of 1000, so \'1\' means 1000 men. This is due to the cap of ~2 million, which would be too low in many cases', supportedScopes: ['faith'], valueType: 'comparison' },
    { name: 'faith_hostility_level', description: 'What is the faith\'s hostility level towards the target faith? faith_hostility_level { target = scope:some_faith value > 1 }', supportedScopes: ['faith'], valueType: 'comparison' },
    { name: 'faith_hostility_level_comparison', description: 'Compares the scoped faith\'s hostility level towards two other faiths. faith_hostility_level_comparison { faith1 > faith2 }', supportedScopes: ['faith'] },
    { name: 'fervor', description: 'What is the faith\'s fervor?', supportedScopes: ['faith'], valueType: 'comparison' },
    { name: 'has_allowed_gender_for_clergy', description: 'Is the target character of the allowed gender to be clergy of the faith?', supportedScopes: ['faith'] },
    { name: 'has_doctrine', description: 'Does the given faith have the given doctrine?? has_doctrine = doctrine_key', supportedScopes: ['faith'], supportedTargets: ['doctrine'] },
    { name: 'has_doctrine_parameter', description: 'Does the given faith have the given doctrine parameter? Can only check for bool parameters. has_doctrine_parameter = parameter_key', supportedScopes: ['faith'] },
    { name: 'has_dominant_ruling_gender', description: 'Is the target character\'s gender a dominant ruling gender of the faith? Also evaluates to true if there\'s no dominant ruling gender', supportedScopes: ['faith'] },
    { name: 'has_graphical_faith', description: 'Does the faith have this graphical faith?', supportedScopes: ['faith'], syntax: "<faith> = { has_graphical_faith = orthodoxgfx }" },
    { name: 'has_icon', description: 'Does the faith have the given icon', supportedScopes: ['faith'], syntax: "has_icon = some_cool_custom_icon" },
    { name: 'has_preferred_gender_for_clergy', description: 'Is the target character of the preferred gender to be clergy of the faith?', supportedScopes: ['faith'] },
    { name: 'holy_sites_controlled', description: 'How many holy sites does the faith control? holy_sites_controlled > 1', supportedScopes: ['faith'], valueType: 'comparison' },
    { name: 'num_character_followers', description: 'Returns how many characters follow the given faith', supportedScopes: ['faith'], valueType: 'comparison', syntax: "num_character_followers > 0" },
    { name: 'num_county_followers', description: 'Returns how many counties follow the given faith', supportedScopes: ['faith'], valueType: 'comparison', syntax: "num_county_followers > 0" },
    { name: 'religion_tag', description: 'checks the tag of the religion of the current faith', supportedScopes: ['faith'] },
    { name: 'trait_is_sin', description: 'Does the scoped faith consider the given trait a sin?', supportedScopes: ['faith'], supportedTargets: ['trait'], syntax: "trait_is_sin = lustful" },
    { name: 'trait_is_virtue', description: 'Does the scoped faith consider the given trait a virtue?', supportedScopes: ['faith'], supportedTargets: ['trait'], syntax: "trait_is_virtue = lustful" },
];
/**
 * Triggers for religion scope (2 triggers)
 */
exports.religionTriggers = [
    { name: 'any_faith', description: 'Iterate through all faiths within a religion', supportedScopes: ['religion'], supportedTargets: ['faith'], outputScope: 'faith', isIterator: true, valueType: 'block', syntax: "any_faith = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'is_in_family', description: 'Is the scoped faith in a given religious family', supportedScopes: ['religion'], syntax: "is_in_family = abrhamic" },
];
/**
 * Triggers for army scope (15 triggers)
 */
exports.armyTriggers = [
    { name: 'army_is_moving', description: 'is this army moving?', supportedScopes: ['army'], valueType: 'boolean' },
    { name: 'army_max_size', description: 'what size is this army\'s max size?', supportedScopes: ['army'], valueType: 'comparison' },
    { name: 'army_size', description: 'what size is this army?', supportedScopes: ['army'], valueType: 'comparison' },
    { name: 'can_disband_army', description: 'Can we disband this army?', supportedScopes: ['army'], valueType: 'boolean' },
    { name: 'is_army_in_combat', description: 'Is the scoped army in combat?', supportedScopes: ['army'], valueType: 'boolean' },
    { name: 'is_army_in_raid', description: 'Is the scoped army in a raid (this includes a raid interrupted by combat)?', supportedScopes: ['army'], valueType: 'boolean' },
    { name: 'is_army_in_siege', description: 'Is the scoped army in a siege (this includes a siege interrupted by combat)?', supportedScopes: ['army'], valueType: 'boolean' },
    { name: 'is_army_in_siege_relevant_for', description: 'Is the scoped army in a siege that is relevant to the target character?', supportedScopes: ['army'], supportedTargets: ['character'], syntax: "is_army_in_siege_relevant_for = scope:character" },
    { name: 'is_raid_army', description: 'Is the scoped army a raid army?', supportedScopes: ['army'], valueType: 'boolean' },
    { name: 'raid_loot', description: 'How much raid loot is the army carrying?', supportedScopes: ['army'], valueType: 'comparison' },
    { name: 'total_army_damage', description: 'What is the army\'s total damage stat in its current location?', supportedScopes: ['army'], valueType: 'comparison' },
    { name: 'total_army_pursuit', description: 'What is the army\'s total pursuit stat in its current location?', supportedScopes: ['army'], valueType: 'comparison' },
    { name: 'total_army_screen', description: 'What is the army\'s total screen stat in its current location?', supportedScopes: ['army'], valueType: 'comparison' },
    { name: 'total_army_siege_value', description: 'What is the army\'s total siege value stat in its current location?', supportedScopes: ['army'], valueType: 'comparison' },
    { name: 'total_army_toughness', description: 'What is the army\'s total toughness stat in its current location?', supportedScopes: ['army'], valueType: 'comparison' },
];
/**
 * Triggers for scheme scope (20 triggers)
 */
exports.schemeTriggers = [
    { name: 'any_scheme_agent', description: 'Iterate through all agents in the scheme', supportedScopes: ['scheme'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_scheme_agent = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'has_scheme_modifier', description: 'Is the scheme currently affected by the specified modifier? has_scheme_modifier = X', supportedScopes: ['scheme'] },
    { name: 'is_hostile', description: 'Is the scoped scheme a hostile scheme?', supportedScopes: ['scheme'], valueType: 'boolean', syntax: "is_hostile = bool" },
    { name: 'is_scheme_agent_exposed', description: 'Is the target character an exposed agent in the scope scheme?', supportedScopes: ['scheme'] },
    { name: 'is_scheme_exposed', description: 'Is the scheme exposed?', supportedScopes: ['scheme'], valueType: 'boolean' },
    { name: 'is_type_secret', description: 'Is the scoped scheme\'s type a secret type?', supportedScopes: ['scheme'], valueType: 'boolean', syntax: "is_type_secret = bool" },
    { name: 'scheme_duration_days', description: 'The number of days since scheme was started', supportedScopes: ['scheme'], valueType: 'comparison' },
    { name: 'scheme_is_character_agent', description: 'Is the target character part of this scheme?', supportedScopes: ['scheme'] },
    { name: 'scheme_monthly_progress', description: 'Monthly scheme progress in % (i.e. 50 equals 50%)', supportedScopes: ['scheme'], valueType: 'comparison' },
    { name: 'scheme_number_of_agents', description: 'The number of agents in a scheme', supportedScopes: ['scheme'], valueType: 'comparison' },
    { name: 'scheme_number_of_exposed_agents', description: 'The number of exposed agents in a scheme', supportedScopes: ['scheme'], valueType: 'comparison' },
    { name: 'scheme_power', description: 'Scheme power', supportedScopes: ['scheme'], valueType: 'comparison' },
    { name: 'scheme_power_resistance_difference', description: 'Scheme power minus scheme resistance difference', supportedScopes: ['scheme'], valueType: 'comparison' },
    { name: 'scheme_power_resistance_ratio', description: 'Scheme power/resistance ratio, the ratio is set to +/-10000 if resistance is zero and power is positive/negative (0 if both power and resistance are 0)', supportedScopes: ['scheme'], valueType: 'comparison' },
    { name: 'scheme_progress', description: 'Scheme progress (0 - 10 (defined))', supportedScopes: ['scheme'], valueType: 'comparison' },
    { name: 'scheme_resistance', description: 'Scheme resistance', supportedScopes: ['scheme'], valueType: 'comparison' },
    { name: 'scheme_secrecy', description: 'Scheme secrecy', supportedScopes: ['scheme'], valueType: 'comparison' },
    { name: 'scheme_skill', description: 'Is the scheme currently affected by the specified modifier? has_scheme_modifier = X', supportedScopes: ['scheme'] },
    { name: 'scheme_success_chance', description: 'Scheme success chance', supportedScopes: ['scheme'], valueType: 'comparison' },
    { name: 'scheme_type', description: 'Is the scheme of the specified type? scheme_type = X', supportedScopes: ['scheme'] },
];
/**
 * Triggers for war scope (17 triggers)
 */
exports.warTriggers = [
    { name: 'any_war_attacker', description: 'Iterate through all attackers in the war', supportedScopes: ['war'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_war_attacker = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_war_defender', description: 'Iterate through all defenders in the war', supportedScopes: ['war'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_war_defender = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_war_participant', description: 'Iterate through all participants in the war', supportedScopes: ['war'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_war_participant = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'attacker_war_score', description: 'compares the attacker war score', supportedScopes: ['war'], valueType: 'comparison' },
    { name: 'days_since_max_war_score', description: 'Number of days since the war score has been at max (+100 or -100). Returns -1 if the war score is not +100 or -100', supportedScopes: ['war'], valueType: 'comparison' },
    { name: 'defender_war_score', description: 'compares the defender war score', supportedScopes: ['war'], valueType: 'comparison' },
    { name: 'has_valid_casus_belli', description: 'does the war interaction still have a valid casus belli (those should be automatically removed on daily tick, but can exist for a tick)', supportedScopes: ['war'], valueType: 'boolean' },
    { name: 'is_attacker', description: 'is the target character in the scope war as an attacker?', supportedScopes: ['war'] },
    { name: 'is_civil_war', description: 'Check if the scope war is a civil war or not', supportedScopes: ['war'], valueType: 'boolean' },
    { name: 'is_defender', description: 'is the target character in the scope war as a defender?', supportedScopes: ['war'] },
    { name: 'is_participant', description: 'is the target character participating in the scope war as an attacker or defender?', supportedScopes: ['war'] },
    { name: 'is_war_leader', description: 'is the target character leading one of the sides in the scope war?', supportedScopes: ['war'] },
    { name: 'is_white_peace_possible', description: 'Check if the scoped war\'s CB has is_white_peace_possible = yes', supportedScopes: ['war'], valueType: 'boolean' },
    { name: 'using_cb', description: 'is the scope war using the specified CB? using_cb = religious_war', supportedScopes: ['war'] },
    { name: 'war_contribution', description: 'Checks how much a character has contributed to the scoped war', supportedScopes: ['war'], syntax: "war_contribution = {\ntarget = some character\nvalue > 5\n}" },
    { name: 'war_days', description: 'compares the number of days the war is going on for', supportedScopes: ['war'], valueType: 'comparison' },
    { name: 'was_called', description: 'has the target character been called to the scope war already?', supportedScopes: ['war'] },
];
/**
 * Triggers for activity scope (23 triggers)
 */
exports.activityTriggers = [
    { name: 'any_activity_phase_location', description: 'Iterate through all province locations of the phases of the activity, optionally limited to unique locations.', supportedScopes: ['activity'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, valueType: 'block', syntax: "any/every/random_activity_phase_location {\nunique = yes/no\n}\nany_activity_phase_location = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_activity_phase_location_future', description: 'Iterate through all future province locations of the phases of the activity, optionally limited to unique locations. (\'future\' does not include any started phase)', supportedScopes: ['activity'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, valueType: 'block', syntax: "any/every/random_activity_phase_location_future {\nunique = yes/no\n}\nany_activity_phase_location_future = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_activity_phase_location_past', description: 'Iterate through all past province locations of the phases of the activity, optionally limited to unique locations. (\'past\' only includes ended phases)', supportedScopes: ['activity'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, valueType: 'block', syntax: "any/every/random_activity_phase_location_future {\nunique = yes/no\n}\nany_activity_phase_location_past = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_attending_character', description: 'Iterate through all characters attending an activity.', supportedScopes: ['activity'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "Invited guests that have not accepted/declined yet are not part of this list.\nSupports an optional state the character must be in.\nany_attending_character = { state = travel/passive/active }\nany_attending_character = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_guest_subset', description: 'any/every/random_guest_subset = {', supportedScopes: ['activity'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "name = <subset_key>\nphase = <phase_key> # Optional\n}\nIterates through characteres within the specified subset for past, current and\nfuture phases. If phase is specified it will only iterate through characters\nsubsets of that particular phase type.\nany_guest_subset = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_guest_subset_current_phase', description: 'any/every/random_guest_subset_current_phase = {', supportedScopes: ['activity'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "name = <subset_key>\n}\nIterates through characteres within the specified subset of the current phase.\nany_guest_subset_current_phase = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_invited_character', description: 'Iterate through all characters invited to an activity. Once they accept/decline, they are removed from this list.', supportedScopes: ['activity'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_invited_character = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_special_guest', description: 'Iterate through all special guests of an activity.', supportedScopes: ['activity'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_special_guest = { ... }\nany_special_guest = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'has_active_locale', description: 'Does the scoped activity have the designated locale active?', supportedScopes: ['activity'], syntax: "has_active_locale = locale_key" },
    { name: 'has_activity_option', description: 'has_activity_option = { category = key option = key }', supportedScopes: ['activity'], syntax: "Does the scoped activity have the option in the given category active" },
    { name: 'has_activity_type', description: 'has_activity_type = key', supportedScopes: ['activity'], supportedTargets: ['activity_type'], syntax: "Does the scoped activity have the given activity type" },
    { name: 'has_current_phase', description: 'has_current_phase = key', supportedScopes: ['activity'], syntax: "Does the scoped activity have the given phase active" },
    { name: 'has_phase', description: 'Check if a phase exists on this activity. You can search for just a type directly, or a complex trigger with  only `type`, `location` or both.', supportedScopes: ['activity'], syntax: "has_phase = name_of_phase\nhas_phase = {\ntype = name_of_phase\nlocation = scope:province\n}" },
    { name: 'has_phase_future', description: 'Check if a past phase exists on this activity. You can search for just a type directly, or a complex trigger with  only `type`, `location` or both.', supportedScopes: ['activity'], syntax: "has_phase = name_of_phase\nhas_phase = {\ntype = name_of_phase\nlocation = scope:province\n}" },
    { name: 'has_phase_past', description: 'Check if a past phase exists on this activity. You can search for just a type directly, or a complex trigger with  only `type`, `location` or both.', supportedScopes: ['activity'], syntax: "has_phase = name_of_phase\nhas_phase = {\ntype = name_of_phase\nlocation = scope:province\n}" },
    { name: 'is_activity_complete', description: 'Check if the current activity is completed or not, this doesn\'t have much use for content since we delete an activity as soon as we can, but in multiplayer it exists until everyone stops viewing it so we use this to cancel some delayed events', supportedScopes: ['activity'], valueType: 'boolean', syntax: "is_activity_complete = yes/no" },
    { name: 'is_current_phase_active', description: 'Check if the current activity phase is in the active state (else it is in the passive state)', supportedScopes: ['activity'], valueType: 'boolean', syntax: "is_current_phase_active = yes/no" },
    { name: 'is_open_invite_activity', description: 'Check if the scoped activity is an open invite activity', supportedScopes: ['activity'], valueType: 'boolean', syntax: "is_open_invite_activity = yes/no" },
    { name: 'is_required_special_guest', description: 'Is the target character a required special guest in the scoped activity.', supportedScopes: ['activity'], syntax: "is_required_special_guest = character" },
    { name: 'is_special_guest', description: 'Is the target character a special guest in the scoped activity, optionally for a specific type.', supportedScopes: ['activity'], syntax: "is_special_guest = character\nis_special_guest = { target = character type = key }" },
    { name: 'num_future_phases', description: 'The number of future phases for the scoped activity.', supportedScopes: ['activity'], valueType: 'comparison', syntax: "num_future_phases > 5" },
    { name: 'num_past_phases', description: 'The number of past phases for the scoped activity.', supportedScopes: ['activity'], valueType: 'comparison', syntax: "num_past_phases > 5" },
    { name: 'num_phases', description: 'The number total number of planned phases for the scoped activity.', supportedScopes: ['activity'], valueType: 'comparison', syntax: "num_phases > 5" },
];
/**
 * Triggers for artifact scope (16 triggers)
 */
exports.artifactTriggers = [
    { name: 'any_artifact_claimant', description: 'Iterate through all characters with a claim on the scoped artifact', supportedScopes: ['artifact'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_artifact_claimant = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_artifact_house_claimant', description: 'Iterate through all dynasty houses with a claim on the scoped artifact', supportedScopes: ['artifact'], supportedTargets: ['dynasty_house'], outputScope: 'dynasty_house', isIterator: true, valueType: 'block', syntax: "any_artifact_house_claimant = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'artifact_durability', description: 'does this artifact have the required durability?', supportedScopes: ['artifact'], valueType: 'comparison' },
    { name: 'artifact_max_durability', description: 'does this artifact have the required max durability?', supportedScopes: ['artifact'], valueType: 'comparison' },
    { name: 'artifact_slot_type', description: 'is the artifact of the given inventory slot type?', supportedScopes: ['artifact'] },
    { name: 'artifact_type', description: 'is the artifact of the given type?', supportedScopes: ['artifact'] },
    { name: 'can_be_claimed_by', description: 'Can the scoped artifact be claimed by the given character?', supportedScopes: ['artifact'], supportedTargets: ['character'] },
    { name: 'category', description: 'is the scoped artifact of given category?', supportedScopes: ['artifact'] },
    { name: 'has_artifact_feature', description: 'Does the artifact have the given feature?', supportedScopes: ['artifact'], syntax: "has_artifact_feature = key" },
    { name: 'has_artifact_feature_group', description: 'Does the artifact have the given feature group?', supportedScopes: ['artifact'], syntax: "has_artifact_feature_group = key" },
    { name: 'has_artifact_modifier', description: 'Does the artifact have the given modifier?', supportedScopes: ['artifact'], syntax: "has_artifact_modifier  = key" },
    { name: 'is_equipped', description: 'is the scoped artifact currently equipped in its owners inventory?', supportedScopes: ['artifact'], valueType: 'boolean' },
    { name: 'is_unique', description: 'Is the scoped artifact unique', supportedScopes: ['artifact'], valueType: 'boolean', syntax: "defined in the scripted template of the artifact" },
    { name: 'num_artifact_kills', description: 'How many kills has this artifact been used in?', supportedScopes: ['artifact'], valueType: 'comparison' },
    { name: 'rarity', description: 'is the scoped artifact of given rarity?', supportedScopes: ['artifact'] },
    { name: 'should_decay', description: 'should the scoped artifact decay with time?', supportedScopes: ['artifact'], valueType: 'boolean' },
];
/**
 * Triggers for none scope (122 triggers)
 */
exports.generalTriggers = [
    { name: 'add_to_temporary_list', description: 'Saves a temporary target for use during the trigger execution', supportedScopes: ['none'], syntax: "This is used to build lists in triggers.\nIf used within an any-trigger, placement within the trigger is quite important. The game will iterate through every instance of the any-trigger until it finds a single instance that fulfills the requirements, and then it will stop.\nIn order to add every instance of a scope that fulfills certain conditions, use \"count = all\" while also placing this \"effect\" at the very end of the any-trigger (so that every condition is evaluated for every iteration)." },
    { name: 'all_false', description: 'true if all children are false (equivalent to NOR)', supportedScopes: ['none'] },
    { name: 'always', description: 'checks if the assigned yes/no value is true', supportedScopes: ['none'], valueType: 'boolean', syntax: "always = yes # always succeeds\nalways = no  # always fails\nalways = scope:a_boolean_value # evaluated at runtime" },
    { name: 'and', description: 'all inside trigger must be true', supportedScopes: ['none'] },
    { name: 'any_accolade_type', description: '1,', supportedScopes: ['none'], supportedTargets: ['accolade_type'], outputScope: 'accolade_type', isIterator: true },
    { name: 'any_activity', description: 'Iterate through all activities in the world', supportedScopes: ['none'], supportedTargets: ['activity'], outputScope: 'activity', isIterator: true, valueType: 'block', syntax: "any_activity = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_activity_type', description: ',', supportedScopes: ['none'], supportedTargets: ['activity_type'], outputScope: 'activity_type', isIterator: true },
    { name: 'any_artifact', description: 'Iterate through all existing artifacts', supportedScopes: ['none'], supportedTargets: ['artifact'], outputScope: 'artifact', isIterator: true, valueType: 'block', syntax: "any_artifact = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_barony', description: 'Iterate through all baronies in the game', supportedScopes: ['none'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_barony = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_character_with_royal_court', description: 'Iterate through all characters with a royal court', supportedScopes: ['none'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_character_with_royal_court = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_county', description: 'Iterate through all counties in the game', supportedScopes: ['none'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_county = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_county_in_region', description: 'Iterate through all counties in the region. Put \'region = region_name\' inside it', supportedScopes: ['none'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_county_in_region = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_culture_global', description: 'Iterate through all cultures in the game', supportedScopes: ['none'], supportedTargets: ['culture'], outputScope: 'culture', isIterator: true, valueType: 'block', syntax: "any_culture_global = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_culture_pillar', description: '', supportedScopes: ['none'], supportedTargets: ['culture_pillar'], outputScope: 'culture_pillar', isIterator: true },
    { name: 'any_decision', description: '8', supportedScopes: ['none'], supportedTargets: ['decision'], outputScope: 'decision', isIterator: true },
    { name: 'any_doctrine', description: '8', supportedScopes: ['none'], supportedTargets: ['doctrine'], outputScope: 'doctrine', isIterator: true },
    { name: 'any_duchy', description: 'Iterate through all duchies in the game', supportedScopes: ['none'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_duchy = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_empire', description: 'Iterate through all empires in the game', supportedScopes: ['none'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_empire = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_false', description: 'true if any child is false (equivalent to NAND)', supportedScopes: ['none'], isIterator: true },
    { name: 'any_government_type', description: 'r', supportedScopes: ['none'], supportedTargets: ['government_type'], outputScope: 'government_type', isIterator: true },
    { name: 'any_in_global_list', description: 'Iterate through all items in global list. list = name or variable = name', supportedScopes: ['none'], isIterator: true, valueType: 'block', syntax: "any_in_global_list = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_in_list', description: 'Iterate through all items in list. list = name or variable = name', supportedScopes: ['none'], isIterator: true, valueType: 'block', syntax: "any_in_list = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_in_local_list', description: 'Iterate through all items in local list. list = name or variable = name', supportedScopes: ['none'], isIterator: true, valueType: 'block', syntax: "any_in_local_list = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_independent_ruler', description: 'Independent rulers list with a COUNT tier or above who hold land', supportedScopes: ['none'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_independent_ruler = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_inspiration', description: 'Iterate through all inspirations in the world', supportedScopes: ['none'], supportedTargets: ['inspiration'], outputScope: 'inspiration', isIterator: true, valueType: 'block', syntax: "any_inspiration = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_inspired_character', description: 'Iterate through all characters with an inspirations in the world', supportedScopes: ['none'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_inspired_character = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_kingdom', description: 'Iterate through all kingdoms in the game', supportedScopes: ['none'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_kingdom = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_living_character', description: 'Iterate through all living characters', supportedScopes: ['none'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_living_character = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_mercenary_company', description: 'Iterate through all mercenary companies', supportedScopes: ['none'], supportedTargets: ['mercenary_company'], outputScope: 'mercenary_company', isIterator: true, valueType: 'block', syntax: "any_mercenary_company = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_open_invite_activity', description: 'Iterate through all open invite activities in the world', supportedScopes: ['none'], supportedTargets: ['activity'], outputScope: 'activity', isIterator: true, valueType: 'block', syntax: "any_open_invite_activity = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_player', description: 'Iterate through all player characters', supportedScopes: ['none'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_player = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_pool_character', description: 'Iterate through all characters in the pool of the given province', supportedScopes: ['none'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_pool_character = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_province', description: 'Iterate through all provinces (skips non-land and impassable provinces)', supportedScopes: ['none'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, valueType: 'block', syntax: "any_province = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_religion_global', description: 'Iterate through all religions in the game', supportedScopes: ['none'], supportedTargets: ['religion'], outputScope: 'religion', isIterator: true, valueType: 'block', syntax: "any_religion_global = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_ruler', description: 'Rulers list with a COUNT tier o above', supportedScopes: ['none'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_ruler = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_special_building_province', description: 'Iterate through all provinces with a special building slot (built or un-built)', supportedScopes: ['none'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, valueType: 'block', syntax: "any_special_building_province = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_trait', description: '@B', supportedScopes: ['none'], supportedTargets: ['trait'], outputScope: 'trait', isIterator: true },
    { name: 'any_trait_in_category', description: 'Iterate through all traits in a given category', supportedScopes: ['none'], supportedTargets: ['trait'], outputScope: 'trait', isIterator: true, valueType: 'block', syntax: "any_trait_in_category = { category = fame/health/etc }\nany_trait_in_category = { <count=num/all> / <percent=fixed_point> <triggers> }" },
    { name: 'any_vassal_contract', description: ';,', supportedScopes: ['none'], supportedTargets: ['vassal_contract'], outputScope: 'vassal_contract', isIterator: true },
    { name: 'assert_if', description: 'Conditionally cause an assert during run time', supportedScopes: ['none'], syntax: "assert_if = { limit = { X } text = Y }, where X is a trigger and Y is an optional string" },
    { name: 'assert_read', description: 'Conditionally cause an assert during read time', supportedScopes: ['none'], syntax: "assert_read = X, where X is yes or the string to be printed in the assert" },
    { name: 'calc_true_if', description: 'Returns true if the specified number of sub-triggers return true', supportedScopes: ['none'], syntax: "calc_true_if = { amount = 2 <trigger> <trigger> <trigger> }" },
    { name: 'can_start_tutorial_lesson', description: 'Can the specified tutorial lesson be started?', supportedScopes: ['none'], syntax: "can_start_tutorial_lesson = reactive_advice_succession\nAn interface trigger, can only be used in specific places" },
    { name: 'current_computer_date', description: 'Compare the current computer date.', supportedScopes: ['none'], valueType: 'comparison', syntax: "An interface trigger, can only be used in specific places" },
    { name: 'current_computer_date_day', description: 'Compare the current computer day.', supportedScopes: ['none'], valueType: 'comparison', syntax: "An interface trigger, can only be used in specific places" },
    { name: 'current_computer_date_month', description: 'Compare the current computer month.', supportedScopes: ['none'], valueType: 'comparison', syntax: "An interface trigger, can only be used in specific places" },
    { name: 'current_computer_date_year', description: 'Compare the current computer year.', supportedScopes: ['none'], valueType: 'comparison', syntax: "An interface trigger, can only be used in specific places" },
    { name: 'current_date', description: 'Compare the current ingame date.', supportedScopes: ['none'], valueType: 'comparison' },
    { name: 'current_day', description: 'Compare the current ingame day [1, 31]', supportedScopes: ['none'], valueType: 'comparison' },
    { name: 'current_month', description: 'Compare the current ingame month [1..12]', supportedScopes: ['none'], valueType: 'comparison' },
    { name: 'current_tooltip_depth', description: 'What is number of tooltips open rigth now?', supportedScopes: ['none'], valueType: 'comparison', syntax: "An interface trigger, can only be used in specific places" },
    { name: 'current_year', description: 'Compare the current ingame year', supportedScopes: ['none'], valueType: 'comparison' },
    { name: 'custom_description', description: 'Wraps triggers that get a custom description instead of the auto-generated one', supportedScopes: ['none'], syntax: "custom_description = {\ntext = <trigger_localization_key>\nsubject = <optional subject scope> #defaults to current scope\nobject = <optional object scope>\nvalue = <optional script value>\n... triggers ...\n}" },
    { name: 'custom_tooltip', description: 'Replaces the tooltips for the enclosed triggers with a custom text', supportedScopes: ['none'], syntax: "custom_tooltip = {\ntext = <text>\nsubject = <scope> (optional)\n<trigger>\n}" },
    { name: 'debug_log', description: 'Log whether the parent trigger succeeded or failed', supportedScopes: ['none'] },
    { name: 'debug_log_details', description: 'Log whether the parent trigger succeeded or failed. Log which children succeeded or failed', supportedScopes: ['none'] },
    { name: 'debug_only', description: 'Checks if the game is in debug mode or not.', supportedScopes: ['none'], valueType: 'boolean' },
    { name: 'exists', description: 'Checks whether the specified scope target exists (check for not being the null object)', supportedScopes: ['none'], syntax: "exists = from.owner.var:cool_var.mother" },
    { name: 'game_start_date', description: 'Compare the date of the bookmarked game launched.', supportedScopes: ['none'], valueType: 'comparison' },
    { name: 'global_variable_list_size', description: 'Checks the size of a variable list', supportedScopes: ['none'], syntax: "variable_list_size = { name = X target >= Y }\nWhere X is the name of the variable\nWhere Y is a script value or number" },
    { name: 'has_dlc', description: 'Does the host have this DLC', supportedScopes: ['none'] },
    { name: 'has_dlc_feature', description: 'Does the host have DLC that enables this particular feature', supportedScopes: ['none'] },
    { name: 'has_game_rule', description: 'Is the given game rule setting enabled?', supportedScopes: ['none'], syntax: "has_game_rule = faster_conversion" },
    { name: 'has_global_variable', description: 'Checks whether the current scope has the specified variable set', supportedScopes: ['none'], syntax: "has_variable = name" },
    { name: 'has_global_variable_list', description: 'Checks whether the current scope has the specified variable list set', supportedScopes: ['none'], syntax: "has_variable_list = name" },
    { name: 'has_local_player_open_court_event', description: 'Has the local player opened a court event in the royal court view?', supportedScopes: ['none'], valueType: 'boolean', syntax: "An interface trigger, can only be used in specific places" },
    { name: 'has_local_player_seen_unopened_court_event', description: 'Has the local player seen the unopened court event(s) waiting in the royal court view?', supportedScopes: ['none'], valueType: 'boolean', syntax: "An interface trigger, can only be used in specific places" },
    { name: 'has_local_player_unopened_court_event', description: 'Has the local player an unopened court event waiting in the royal court view?', supportedScopes: ['none'], valueType: 'boolean', syntax: "An interface trigger, can only be used in specific places" },
    { name: 'has_local_variable', description: 'Checks whether the current scope has the specified variable set', supportedScopes: ['none'], syntax: "has_variable = name" },
    { name: 'has_local_variable_list', description: 'Checks whether the current scope has the specified variable list set', supportedScopes: ['none'], syntax: "has_variable_list = name" },
    { name: 'has_map_mode', description: 'Checks if the current map mode is the specified one', supportedScopes: ['none'], syntax: "has_map_mode = realms\nAn interface trigger, can only be used in specific places" },
    { name: 'has_multiple_players', description: 'Does the game have at least two players currently connected?', supportedScopes: ['none'], valueType: 'boolean' },
    { name: 'has_reward_item', description: 'Does the player have a reward item', supportedScopes: ['none'], syntax: "An interface trigger, can only be used in specific places" },
    { name: 'has_variable', description: 'Checks whether the current scope has the specified variable set', supportedScopes: ['none'], syntax: "has_variable = name" },
    { name: 'has_variable_list', description: 'Checks whether the current scope has the specified variable list set', supportedScopes: ['none'], syntax: "has_variable_list = name" },
    { name: 'has_vassal_stance', description: 'Does the scoped vassal character have the given vassal stance', supportedScopes: ['none'], syntax: "has_vassal_stance = glory_hound" },
    { name: 'has_war_result_message_with_outcome', description: 'Is there a war result message with the specified outcome?', supportedScopes: ['none'], syntax: "has_war_result_message_with_outcome = victory/defeat/white_peace/invalidated/any\nAn interface trigger, can only be used in specific places" },
    { name: 'is_bad_nickname', description: 'Is the nickname bad?', supportedScopes: ['none'] },
    { name: 'is_frontend_character_selected', description: 'is the specified front end character selected (also can be used with "= yes" and "= no")?', supportedScopes: ['none'], syntax: "An interface trigger, can only be used in specific places" },
    { name: 'is_game_view_open', description: 'is the specified in-game view open?', supportedScopes: ['none'], syntax: "An interface trigger, can only be used in specific places" },
    { name: 'is_gamestate_tutorial_active', description: 'Is the gamestate tutorial active? See save_progress_in_gamestate in tutorial_lesson_chains documentation.', supportedScopes: ['none'], valueType: 'boolean', syntax: "An interface trigger, can only be used in specific places" },
    { name: 'is_in_list', description: 'Checks if a target in in a list', supportedScopes: ['none'] },
    { name: 'is_mercenary_in_hire_range', description: 'Is the mercenary company within the hiring range of the target character.', supportedScopes: ['none'], supportedTargets: ['character'], syntax: "is_mercenary_in_hire_range = scope:character" },
    { name: 'is_player_selected', description: 'is the player playing a character?', supportedScopes: ['none'], valueType: 'boolean', syntax: "An interface trigger, can only be used in specific places" },
    { name: 'is_set', description: 'Checks whether the specified scope target has been set (includes being the null object)', supportedScopes: ['none'], syntax: "is_set = from.owner.var:cool_var.mother" },
    { name: 'is_target_in_global_variable_list', description: 'Checks if a target is in a variable list', supportedScopes: ['none'], syntax: "is_target_in_variable_list = { name = X target = Y }\nWhere X is the name of the variable\nWhere Y is an event target" },
    { name: 'is_target_in_local_variable_list', description: 'Checks if a target is in a variable list', supportedScopes: ['none'], syntax: "is_target_in_variable_list = { name = X target = Y }\nWhere X is the name of the variable\nWhere Y is an event target" },
    { name: 'is_target_in_variable_list', description: 'Checks if a target is in a variable list', supportedScopes: ['none'], syntax: "is_target_in_variable_list = { name = X target = Y }\nWhere X is the name of the variable\nWhere Y is an event target" },
    { name: 'is_tooltip_with_name_open', description: 'is the tooltip with the specified name open?', supportedScopes: ['none'], syntax: "An interface trigger, can only be used in specific places" },
    { name: 'is_tutorial_active', description: 'Is the tutorial active?', supportedScopes: ['none'], valueType: 'boolean', syntax: "An interface trigger, can only be used in specific places" },
    { name: 'is_tutorial_lesson_active', description: 'Is this the current tutorial lesson?', supportedScopes: ['none'], syntax: "is_tutorial_lesson_active = reactive_advice_succession\nAn interface trigger, can only be used in specific places" },
    { name: 'is_tutorial_lesson_chain_completed', description: 'Has the tutorial lesson chain with the specified key been finished?', supportedScopes: ['none'], syntax: "An interface trigger, can only be used in specific places" },
    { name: 'is_tutorial_lesson_completed', description: 'has the tutorial lesson with the specified name been finished?', supportedScopes: ['none'], syntax: "An interface trigger, can only be used in specific places" },
    { name: 'is_tutorial_lesson_step_completed', description: 'Has the tutorial lesson step been finished?', supportedScopes: ['none'], syntax: "is_tutorial_lesson_step_completed = lesson_key:step_key\nAn interface trigger, can only be used in specific places" },
    { name: 'is_war_overview_tab_open', description: 'is the war overview open at a specified tab (victory, defeat, white_peace)?', supportedScopes: ['none'], syntax: "An interface trigger, can only be used in specific places" },
    { name: 'is_widget_open', description: 'is the widget with the specified name open?', supportedScopes: ['none'], syntax: "Separting strings with dots will search for specific children of children eg: appa.foo vs baz.foo\nAn interface trigger, can only be used in specific places" },
    { name: 'list_size', description: 'Checks the size of a list', supportedScopes: ['none'], valueType: 'comparison', syntax: "list_size = { name = X value >= Y }\nWhere X is the name of the list\nWhere Y is a script value" },
    { name: 'local_variable_list_size', description: 'Checks the size of a variable list', supportedScopes: ['none'], syntax: "variable_list_size = { name = X target >= Y }\nWhere X is the name of the variable\nWhere Y is a script value or number" },
    { name: 'nand', description: 'a negated AND trigger', supportedScopes: ['none'] },
    { name: 'nor', description: 'a negated OR trigger', supportedScopes: ['none'] },
    { name: 'not', description: 'negates content of trigger', supportedScopes: ['none'] },
    { name: 'or', description: 'at least one entry inside trigger must be true', supportedScopes: ['none'] },
    { name: 'perks_in_diplomacy_lifestyle', description: 'How many perks does this lifestyle have?', supportedScopes: ['none'], valueType: 'comparison' },
    { name: 'perks_in_intrigue_lifestyle', description: 'How many perks does this lifestyle have?', supportedScopes: ['none'], valueType: 'comparison' },
    { name: 'perks_in_learning_lifestyle', description: 'How many perks does this lifestyle have?', supportedScopes: ['none'], valueType: 'comparison' },
    { name: 'perks_in_martial_lifestyle', description: 'How many perks does this lifestyle have?', supportedScopes: ['none'], valueType: 'comparison' },
    { name: 'perks_in_stewardship_lifestyle', description: 'How many perks does this lifestyle have?', supportedScopes: ['none'], valueType: 'comparison' },
    { name: 'release_only', description: 'Checks if the game is in release mode or not.', supportedScopes: ['none'], valueType: 'boolean' },
    { name: 'save_temporary_opinion_value_as', description: 'Saves the scoped character\'s opinion of the target character as an arbitrarily-named target to be referenced later in the in the same trigger', supportedScopes: ['none'], syntax: "save_temporary_opinion_value_as = { name = <string> target = x" },
    { name: 'save_temporary_scope_as', description: 'Saves a temporary target for use during the trigger execution', supportedScopes: ['none'] },
    { name: 'save_temporary_scope_value_as', description: 'Saves a numerical or bool value as an arbitrarily-named temporary target to be referenced later in the same effect', supportedScopes: ['none'], syntax: "save_temporary_scope_value_as = { name = <string> value = x }" },
    { name: 'scripted_tests', description: 'Checks if the game is currently running scripted tests.', supportedScopes: ['none'], valueType: 'boolean' },
    { name: 'should_show_disturbing_portrait_modifiers', description: 'can disturbing portrait modifiers be shown?', supportedScopes: ['none'], valueType: 'boolean', syntax: "An interface trigger, can only be used in specific places" },
    { name: 'should_show_nudity', description: 'can nudity be shown?', supportedScopes: ['none'], valueType: 'boolean', syntax: "An interface trigger, can only be used in specific places" },
    { name: 'switch', description: 'Switch on a trigger for the evaluation of another trigger with an optional fallback trigger.', supportedScopes: ['none'], valueType: 'block', syntax: "switch = {\ntrigger = simple_assign_trigger\ncase_1 = { <triggers> }\ncase_2 = { <triggers> }\ncase_n = { <triggers> }\nfallback = { <triggers> }" },
    { name: 'time_of_year', description: 'Check if the current date is within the bounds', supportedScopes: ['none'], syntax: "time_of_year = {\nmin = 11.1 # default: beginning of year\nmax = 2.29 # default: end of year\n}\nDates are formatted as \"<month>.<day>\" or just \"<month>\".\nThe check includes the min and max dates.\nmin can be larger than max, in this case we wrap around to the next year (i.e., February is between October and March)." },
    { name: 'trigger_else', description: 'Evaluates the triggers if the display_triggers of preceding \'trigger_if\' or \'trigger_else_if\' is not mettrigger_if = { limit = { <display_triggers> } <triggers> }', supportedScopes: ['none'], valueType: 'block', syntax: "trigger_else = { <triggers> }" },
    { name: 'trigger_else_if', description: 'Evaluates the enclosed triggers if the display_triggers of the preceding `trigger_if` or `trigger_else_if` is not met and its own display_trigger of the limit is mettrigger_if = { limit = { <display_triggers> } <triggers> }', supportedScopes: ['none'], valueType: 'block', syntax: "trigger_else_if = { limit = { <display_triggers> } <triggers> }" },
    { name: 'trigger_if', description: 'Evaluates the triggers if the display_triggers of the limit are met', supportedScopes: ['none'], valueType: 'block', syntax: "trigger_if = { limit = { <display_triggers> } <triggers> }" },
    { name: 'variable_list_size', description: 'Checks the size of a variable list', supportedScopes: ['none'], syntax: "variable_list_size = { name = X target >= Y }\nWhere X is the name of the variable\nWhere Y is a script value or number" },
    { name: 'weighted_calc_true_if', description: 'Returns true if the sum of weights of fulfilled sub-triggers amount to the specified sum', supportedScopes: ['none'], syntax: "weighted_calc_true_if = { amount = 10 5 = { <trigger> } 15 = { <trigger> } 7 = { <trigger> } }" },
    { name: 'years_from_game_start', description: 'How many years it has been since the start of the game', supportedScopes: ['none'], valueType: 'comparison', syntax: "years_from_game_start > 5" },
];
/**
 * All triggers combined
 */
exports.allTriggers = [
    ...exports.characterTriggers,
    ...exports.landedtitleTriggers,
    ...exports.provinceTriggers,
    ...exports.dynastyTriggers,
    ...exports.dynastyhouseTriggers,
    ...exports.cultureTriggers,
    ...exports.faithTriggers,
    ...exports.religionTriggers,
    ...exports.armyTriggers,
    ...exports.schemeTriggers,
    ...exports.warTriggers,
    ...exports.activityTriggers,
    ...exports.artifactTriggers,
    ...exports.generalTriggers,
];
/**
 * Get triggers valid for a specific scope
 */
function getTriggersForScope(scope) {
    return exports.allTriggers.filter(trigger => {
        if (trigger.supportedScopes.includes('none'))
            return true;
        return trigger.supportedScopes.includes(scope);
    });
}
/**
 * Build a map for quick lookup
 */
exports.triggersMap = new Map(exports.allTriggers.map(t => [t.name, t]));
//# sourceMappingURL=triggers.generated.js.map