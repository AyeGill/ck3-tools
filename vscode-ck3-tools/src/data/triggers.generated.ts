/**
 * CK3 Trigger Definitions (Auto-generated)
 * 
 * Triggers are conditions that evaluate to true/false.
 * Each trigger has a list of scopes where it can be used.
 * 
 * Source: Local files from /Users/eigil/Projects/Gottfried/vscode-ck3-tools/src/data/script_docs
 * Total triggers: 1768
 */

import { ScopeType } from './scopes';

export interface TriggerDefinition {
  name: string;
  description: string;
  supportedScopes: ScopeType[];
  supportedTargets?: ScopeType[];
  outputScope?: ScopeType;
  isIterator?: boolean;
  valueType?: 'boolean' | 'comparison' | 'value' | 'block';
  syntax?: string;
  parameters?: string[];
}

/**
 * Triggers for character scope (945 triggers)
 */
export const characterTriggers: TriggerDefinition[] = [
  { name: 'age', description: 'Get character age: scope:character = { age > 16 }', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'ai_boldness', description: 'AI boldness', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'ai_compassion', description: 'AI compassion', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'ai_diplomacy_stance', description: 'The AI\'s diplomatic view of the target character', supportedScopes: ['character'], syntax: "ai_diplomacy_stance = {\ntarget = target_character\nstance = neutral/threat/enemy/friend\n}", parameters: ['target', 'stance'] },
  { name: 'ai_energy', description: 'AI energy', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'ai_greed', description: 'AI greed', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'ai_honor', description: 'AI honor', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'ai_rationality', description: 'AI rationality', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'ai_sociability', description: 'AI sociability', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'ai_values_divergence', description: 'target = other character value >/</= sum of differences in ai values', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'ai_vengefulness', description: 'AI vengefulness', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'ai_will_do_contribution', description: 'Compares the scope character\'s base willingness to make the contribution specified', supportedScopes: ['character'], valueType: 'comparison', syntax: "scope:my_char.contribution_ai_will_do( scope:great_project_contribution ) > 25" },
  { name: 'ai_zeal', description: 'AI zeal', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'all_court_artifact_slots', description: 'check if all the scoped characters court artifact slots are empty or full', supportedScopes: ['character'] },
  { name: 'all_inventory_artifact_slots', description: 'check if all the scoped characters inventory artifact slots are empty or full', supportedScopes: ['character'] },
  { name: 'allowed_concubines', description: 'Can the scope owner have concubines?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'allowed_more_concubines', description: 'Can the scope owner have more concubines?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'allowed_more_spouses', description: 'Can the scope owner have more spouses?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'amenity_level', description: 'Compares the scoped character\'s amenity level in the given type to the given value', supportedScopes: ['character'], valueType: 'comparison', syntax: "amenity_level = {\ntarget = food\nvalue >= 5\n}\namenity_level:court_lodging_standards > 1", parameters: ['target'] },
  { name: 'any_acclaimed_knight', description: 'Iterate through all acclaimed knights employed by a given character', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_acclaimed_knight = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_accolade', description: 'Iterate through all ( active and inactive ) Accolades of a given liege character\'s Acclaimed Knights', supportedScopes: ['character'], supportedTargets: ['accolade'], outputScope: 'accolade', isIterator: true, valueType: 'block', syntax: "any_accolade = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_active_accolade', description: 'Iterate through all active Accolades of a given liege character\'s Acclaimed Knights', supportedScopes: ['character'], supportedTargets: ['accolade'], outputScope: 'accolade', isIterator: true, valueType: 'block', syntax: "Optionally specify an accolade parameter filter\nany_active_accolade = { accolade_parameter = accolade_organize_army_bonus }\nany_active_accolade = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_alert_creatable_title', description: 'Iterate through all titles that can be created by the character. (only for alerts)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_alert_creatable_title = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_alert_usurpable_title', description: 'Iterate through all titles that can be usurped by the character. (only for alerts)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_alert_usurpable_title = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_ally', description: 'Iterate through all allies', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_ally = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_ancestor', description: 'Iterate through all the ancestors of the scope character up to 5 generations', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_ancestor = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_army', description: 'Iterate through all armies', supportedScopes: ['character'], supportedTargets: ['army'], outputScope: 'army', isIterator: true, valueType: 'block', syntax: "any_army = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_available_task_contract', description: 'Iterate through all task contracts of location of root province', supportedScopes: ['character'], supportedTargets: ['task_contract'], outputScope: 'task_contract', isIterator: true, valueType: 'block', syntax: "any_available_task_contract = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_character_active_contract', description: 'Gets all accepted task contracts of the root character', supportedScopes: ['character'], supportedTargets: ['task_contract'], outputScope: 'task_contract', isIterator: true, valueType: 'block', syntax: "Optionally specify a contract type filter\nany_character_active_contract = { task_contract_type = laamp_raid_contract }\nany_character_active_contract = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_character_artifact', description: 'Iterate through all artifacts in a given characters inventory', supportedScopes: ['character'], supportedTargets: ['artifact'], outputScope: 'artifact', isIterator: true, valueType: 'block', syntax: "any_character_artifact = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_character_epidemic', description: 'Gets epidemics affecting the scoped character', supportedScopes: ['character'], supportedTargets: ['epidemic'], outputScope: 'epidemic', isIterator: true, valueType: 'block', syntax: "any_character_epidemic = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_character_situation', description: 'Iterate through all situations that a character is participating in', supportedScopes: ['character'], supportedTargets: ['situation'], outputScope: 'situation', isIterator: true, valueType: 'block', syntax: "any_character_situation = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_character_struggle', description: 'Iterate through all struggles that character is involved in. Optional: Narrow down the involvement status *_chracter_struggle = { involvement = involved | interloper }', supportedScopes: ['character'], supportedTargets: ['struggle'], outputScope: 'struggle', isIterator: true, valueType: 'block', syntax: "any_character_struggle = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_character_task_contract', description: 'Gets all task contracts of the scoped character', supportedScopes: ['character'], supportedTargets: ['task_contract'], outputScope: 'task_contract', isIterator: true, valueType: 'block', syntax: "Optionally specify a contract type filter\nany_character_task_contract = { task_contract_type = laamp_raid_contract }\nany_character_task_contract = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_character_to_title_neighboring_and_across_water_county', description: 'Scopes from a character to a neighboring county (incl. across water, looking trough the de Jure lieges)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_character_to_title_neighboring_and_across_water_county = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_character_to_title_neighboring_and_across_water_duchy', description: 'Scopes from a character to a neighboring duchy (incl. across water, looking trough the de Jure lieges)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_character_to_title_neighboring_and_across_water_duchy = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_character_to_title_neighboring_and_across_water_empire', description: 'Scopes from a character to a neighboring empire (incl. across water, looking trough the de Jure lieges)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_character_to_title_neighboring_and_across_water_empire = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_character_to_title_neighboring_and_across_water_kingdom', description: 'Scopes from a character to a neighboring kingdom (incl. across water, looking trough the de Jure lieges)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_character_to_title_neighboring_and_across_water_kingdom = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_character_to_title_neighboring_county', description: 'Scopes from a character to a neighboring county (looking trough the de Jure lieges)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_character_to_title_neighboring_county = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_character_to_title_neighboring_duchy', description: 'Scopes from a character to a neighboring duchy (looking trough the de Jure lieges)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_character_to_title_neighboring_duchy = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_character_to_title_neighboring_empire', description: 'Scopes from a character to a neighboring empire (looking trough the de Jure lieges)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_character_to_title_neighboring_empire = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_character_to_title_neighboring_kingdom', description: 'Scopes from a character to a neighboring kingdom (looking trough the de Jure lieges)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_character_to_title_neighboring_kingdom = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_character_trait', description: 'Iterate through all traits a character has', supportedScopes: ['character'], supportedTargets: ['trait'], outputScope: 'trait', isIterator: true, valueType: 'block', syntax: "any_character_trait = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_character_war', description: 'Wars of the scoped character', supportedScopes: ['character'], supportedTargets: ['war'], outputScope: 'war', isIterator: true, valueType: 'block', syntax: "any_character_war = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_child', description: 'Iterate through all children', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_child = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_claim', description: 'Iterate through the titles of all claims held by a character; parameters: explicit = yes/no/all pressed = yes/no/all', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_claim = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_claimed_artifact', description: 'Iterate through all claimed artifacts of the scoped character', supportedScopes: ['character'], supportedTargets: ['artifact'], outputScope: 'artifact', isIterator: true, valueType: 'block', syntax: "any_claimed_artifact = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_close_family_member', description: 'Iterate through all the close family [father, mother, siblings, children, grandparents]', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_close_family_member = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_close_or_extended_family_member', description: 'Iterate through all the close and extended relatives [father, mother, siblings, children, grandparents, uncles/aunts, nephew/niece, cousins]', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_close_or_extended_family_member = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_concubine', description: 'Iterate through all concubines', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_concubine = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_consort', description: 'Iterate through all consorts (concubines and spouses)', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_consort = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_contact', description: 'Iterate through all contact characters of the root character', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_contact = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_councillor', description: 'Iterate through all councillors', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_councillor = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_court_position_candidate', description: 'Iterate through all valid candidates for a court position type.', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "*_court_position_candidate = {\ncourt_position = bodyguard_court_position\nOR\ncourt_position = scope:my_scoped_court_position_type\n...\n}\nany_court_position_candidate = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['court_position', 'count', 'percent'] },
  { name: 'any_court_position_employer', description: 'Iterates through all characters that employ the scoped character in any court position.', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_court_position_employer = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_court_position_holder', description: 'Iterates through all characters employed by the scoped character in the target court position.', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_court_position_holder = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_courtier', description: 'Iterate through all courtiers', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_courtier = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_courtier_away', description: 'Iterate through all courtiers that are away', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_courtier_away = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_courtier_or_guest', description: 'Iterate through all courtiers and guests (pool and foreign court guests)', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_courtier_or_guest = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_de_jure_claim', description: 'Iterate through all de jure claims for a character', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_de_jure_claim = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_diarchy_succession_character', description: 'Iterate through all character in the diarchy line of succession.If there\'s no active diarchy or active one doesn\'t have succession,it iterates over regency candidates', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_diarchy_succession_character = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_diplomacy_councillor', description: 'Iterate through all diplomacy-based councillors', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_diplomacy_councillor = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_directly_owned_province', description: 'Iterate through all directly owned provinces', supportedScopes: ['character'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, valueType: 'block', syntax: "any_directly_owned_province = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_election_title', description: 'Iterate through all titles the scoped character can vote on', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_election_title = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_equipped_character_artifact', description: 'Iterate through all equipped artifacts in a given characters inventory', supportedScopes: ['character'], supportedTargets: ['artifact'], outputScope: 'artifact', isIterator: true, valueType: 'block', syntax: "any_equipped_character_artifact = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_extended_family_member', description: 'Iterate through all the extended family [uncles/aunts, nephew/niece, cousins]', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_extended_family_member = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_foreign_court_guest', description: 'Iterate through all guests visiting from another court (in contrast to pool_guest they have a liege)', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_foreign_court_guest = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_former_concubine', description: 'Iterate through all former concubines. Not persisted past death', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_former_concubine = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_former_concubinist', description: 'Iterate through all former concubinists. Not persisted past death', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_former_concubinist = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_former_spouse', description: 'Iterate through all former spouses', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_former_spouse = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_general_councillor', description: 'Iterate through all councillors that are not related to a skill', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_general_councillor = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_heir', description: 'Heirs of the scoped character', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_heir = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_heir_title', description: 'Iterate through all titles the scoped character is heir to', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_heir_title = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_held_title', description: 'Iterate through all held landed titles. Optionally specify a tier filter', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any/every/ordered/random_held_title = { title_tier >= county }\nany_held_title = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['any', 'every', 'ordered', 'random_held_title', 'count', 'percent'] },
  { name: 'any_hired_mercenary', description: 'Iterate through all hired mercenary companies', supportedScopes: ['character'], supportedTargets: ['mercenary_company'], outputScope: 'mercenary_company', isIterator: true, valueType: 'block', syntax: "any_hired_mercenary = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_home_court_hostage', description: 'Iterate through all hostages currently abroad', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_home_court_hostage = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_hooked_character', description: 'Iterate through all characters this character has a hook on', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_hooked_character = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_hostile_raider', description: 'Iterate through anyone the character is hostile to due to their top-liege\'s realm having been raided', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_hostile_raider = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_intrigue_councillor', description: 'Iterate through all intrigue-based councillors', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_intrigue_councillor = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_invited_activity', description: 'Iterate through all activities a character has been invited to', supportedScopes: ['character'], supportedTargets: ['activity'], outputScope: 'activity', isIterator: true, valueType: 'block', syntax: "any_invited_activity = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_knight', description: 'Iterate through all knights', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_knight = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_known_secret', description: 'Iterate through all secrets known by the character', supportedScopes: ['character'], supportedTargets: ['secret'], outputScope: 'secret', isIterator: true, valueType: 'block', syntax: "any_known_secret = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_land_neighboring_realm_with_tributaries', description: 'A realm with a different top liege neighboring the realm of the scope character\'s top liege; switches to the realm\'s top title. Can be based on borders a day or two out of date. Includes land borders extended due to tributaries.', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_land_neighboring_realm_with_tributaries = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_land_neighboring_realm_with_tributaries_owner', description: 'A realm with a different top liege neighboring the realm of the scope character\'s top liege; switches to the holder of the realm. Can be based on borders a day or two out of date. Includes land borders extended due to tributaries.', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_land_neighboring_realm_with_tributaries_owner = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_learning_councillor', description: 'Iterate through all learning-based councillors', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_learning_councillor = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_liege_or_above', description: 'Iterate through all lieges above a character (skipping the character themselves)', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_liege_or_above = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_maa_regiment', description: 'Iterate through all MaA regiments', supportedScopes: ['character'], supportedTargets: ['regiment'], outputScope: 'regiment', isIterator: true, valueType: 'block', syntax: "any_maa_regiment = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_martial_councillor', description: 'Iterate through all martial-based councillors', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_martial_councillor = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_memory', description: 'Iterate through all memories of a character', supportedScopes: ['character'], supportedTargets: ['character_memory'], outputScope: 'character_memory', isIterator: true, valueType: 'block', syntax: "Optionally specify a memory type filter\nany_memory = { memory_type = completed_rites_of_passage }\nany_memory = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_neighboring_and_across_water_realm_owner', description: 'A sub-realm or realm bordering the scope character\'s realm (including across water). Returns counts and above.', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_neighboring_and_across_water_realm_owner = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_neighboring_and_across_water_realm_same_rank_owner', description: 'A sub-realm or realm bordering the scope character\'s realm (including across water) and has the same rank as the scope character (look for lieges of he owner of the land if necessary)', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_neighboring_and_across_water_realm_same_rank_owner = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_neighboring_and_across_water_top_liege_realm', description: 'A realm with a different top liege neighboring the realm of the scope character\'s top liege (including across water); switches to the realm\'s top title. Can be based on borders a day or two out of date', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_neighboring_and_across_water_top_liege_realm = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_neighboring_and_across_water_top_liege_realm_owner', description: 'A realm with a different top liege neighboring the realm of the scope character\'s top liege (including across water); switches to the holder of the realm. Can be based on borders a day or two out of date', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_neighboring_and_across_water_top_liege_realm_owner = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_neighboring_and_across_water_top_suzerain_realm', description: 'A realm with a different top suzerain neighboring the realm of the scope character\'s top suzerain (including across water); switches to the realm\'s top title. Can be based on borders a day or two out of date', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_neighboring_and_across_water_top_suzerain_realm = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_neighboring_and_across_water_top_suzerain_realm_owner', description: 'A realm with a different top suzerain neighboring the realm of the scope character\'s top suzerain (including across water); switches to the holder of the realm. Can be based on borders a day or two out of date', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_neighboring_and_across_water_top_suzerain_realm_owner = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_neighboring_realm_owner', description: 'A sub-realm or realm bordering the scope character\'s realm. Returns counts and above.', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_neighboring_realm_owner = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_neighboring_realm_same_rank_owner', description: 'A sub-realm or realm bordering the scope character\'s realm and has the same rank as the scope character (look for lieges of he owner of the land if necessary)', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_neighboring_realm_same_rank_owner = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_neighboring_realm_with_tributaries_owner', description: 'A realm with a different top liege neighboring the realm of the scope character\'s top liege; switches to the holder of the realm. Can be based on borders a day or two out of date. Includes land and water borders extended by including tributaries.', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_neighboring_realm_with_tributaries_owner = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_neighboring_top_liege_realm', description: 'A realm with a different top liege neighboring the realm of the scope character\'s top liege; switches to the realm\'s top title. Can be based on borders a day or two out of date', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_neighboring_top_liege_realm = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_neighboring_top_liege_realm_owner', description: 'A realm with a different top liege neighboring the realm of the scope character\'s top liege; switches to the holder of the realm. Can be based on borders a day or two out of date', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_neighboring_top_liege_realm_owner = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_neighboring_top_suzerain_realm', description: 'A realm with a different top suzerain neighboring the realm of the scope character\'s top suzerain; switches to the realm\'s top title. Can be based on borders a day or two out of date', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_neighboring_top_suzerain_realm = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_neighboring_top_suzerain_realm_owner', description: 'A realm with a different top suzerain neighboring the realm of the scope character\'s top suzerain; switches to the holder of the realm. Can be based on borders a day or two out of date', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_neighboring_top_suzerain_realm_owner = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_noble_family', description: 'Iterate through all noble family titles in the realm of scoped character.', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "If the character is not independent this will return an empty list.\nany_noble_family = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_opposite_sex_spouse_candidate', description: 'Iterate through all the spouse candidates of the opposite sex of a character.', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "WARNING: THIS IS VERY SLOW DO NOT DO IT OFTEN.\nany_opposite_sex_spouse_candidate = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_owned_story', description: 'Iterate through all owned stories for a character', supportedScopes: ['character'], supportedTargets: ['story'], outputScope: 'story', isIterator: true, valueType: 'block', syntax: "Optionally specify a story type filter\nany_owned_story = { type = story_cycle_pet_cat }\nany_owned_story = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_parent', description: 'Iterate through all (both) parents', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_parent = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_patroned_holy_order', description: 'Iterate through all holy orders that the scoped character is a patron of', supportedScopes: ['character'], supportedTargets: ['holy_order'], outputScope: 'holy_order', isIterator: true, valueType: 'block', syntax: "any_patroned_holy_order = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_personal_claimed_artifact', description: 'Iterate through all personally claimed artifacts of the scoped character', supportedScopes: ['character'], supportedTargets: ['artifact'], outputScope: 'artifact', isIterator: true, valueType: 'block', syntax: "any_personal_claimed_artifact = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_pinned_character', description: 'Iterate through characters this player has pinned', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_pinned_character = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_pinning_character', description: 'Iterate through characters whose player has this character pinned', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_pinning_character = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_played_character', description: 'Iterate through all characters the player playing this character has played. Matches the game over legacy, except for excluding the currently played character', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_played_character = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_player_heir', description: 'Iterate through player heirs, capped at the first 10', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_player_heir = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_player_legend_library', description: 'Get all legends in a player character library.', supportedScopes: ['character'], supportedTargets: ['legend'], outputScope: 'legend', isIterator: true, valueType: 'block', syntax: "any_player_legend_library = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_pool_guest', description: 'Iterate through all guests visiting the court from the pool (in contrast to foreign_court_guest they don\'t have a liege)', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_pool_guest = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_potential_marriage_option', description: 'Iterate through all potential selectable marriage or betrohed options', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_potential_marriage_option = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_powerful_family', description: 'Iterate through all powerful families in this character\'s realm.', supportedScopes: ['character'], supportedTargets: ['dynasty_house'], outputScope: 'dynasty_house', isIterator: true, valueType: 'block', syntax: "If the character is not independent this will return an empty list.\nany_powerful_family = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_powerful_vassal', description: 'Iterate through the all powerful vassals of a character', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_powerful_vassal = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_pretender_title', description: 'Iterate through all landed titles character is pretender to', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_pretender_title = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_primary_war_enemy', description: 'Iterate through all primary war enemies', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_primary_war_enemy = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_prisoner', description: 'Iterate through all prisoners', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_prisoner = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_prowess_councillor', description: 'Iterate through all prowess-based councillors', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_prowess_councillor = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_raid_target', description: 'Iterate through anyone the character is hostile to due to having raided them. Only returns top lieges', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_raid_target = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_realm_border_county', description: 'Iterate through all counties that are on the edge of your realm bordering a different neighboring realm.', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_realm_border_county = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_realm_county', description: 'Iterate through all counties in the realm. Based on top liege', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_realm_county = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_realm_de_jure_duchy', description: 'Iterate through all de jure duchies that have at least one county in the realm. Based on top liege', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_realm_de_jure_duchy = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_realm_de_jure_empire', description: 'Iterate through all de jure empire that have at least one county in the realm. Based on top liege', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_realm_de_jure_empire = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_realm_de_jure_kingdom', description: 'Iterate through all de jure kingdom that have at least one county in the realm. Based on top liege', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_realm_de_jure_kingdom = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_realm_province', description: 'Iterate through all realm provinces of a character', supportedScopes: ['character'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, valueType: 'block', syntax: "any_realm_province = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_relation', description: 'Iterate through scripted relations of a given type or multiple types, if someone is multiple relations they will only be in the list once', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_relation = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_same_sex_spouse_candidate', description: 'Iterate through all the spouse candidates of the same sex of a character.', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "WARNING: THIS IS VERY SLOW DO NOT DO IT OFTEN.\nany_same_sex_spouse_candidate = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_scheme', description: 'Iterate through all schemes owned by the character', supportedScopes: ['character'], supportedTargets: ['scheme'], outputScope: 'scheme', isIterator: true, valueType: 'block', syntax: "Optionally specify a type filter\nrandom_scheme = { type = befriend }\nany_scheme = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['random_scheme', 'count', 'percent'] },
  { name: 'any_secret', description: 'Iterate through all secrets of the character', supportedScopes: ['character'], supportedTargets: ['secret'], outputScope: 'secret', isIterator: true, valueType: 'block', syntax: "Optionally specify a secret type filter\nrandom_secret = { type = secret_lover }\nany_secret = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['random_secret', 'count', 'percent'] },
  { name: 'any_sibling', description: 'Iterate through all siblings', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_sibling = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_sponsored_inspiration', description: 'Iterate through all sponsored inspirations', supportedScopes: ['character'], supportedTargets: ['inspiration'], outputScope: 'inspiration', isIterator: true, valueType: 'block', syntax: "any_sponsored_inspiration = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_spouse', description: 'Iterate through all spouses', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_spouse = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_spouse_candidate', description: 'Iterate through all the spouse candidates of a character.', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "WARNING: THIS IS VERY SLOW DO NOT DO IT OFTEN.\nany_spouse_candidate = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_stewardship_councillor', description: 'Iterate through all stewardship-based councillors', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_stewardship_councillor = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_sub_realm_barony', description: 'Iterate through all baronies in sub-realm, counting only titles that either hold land or have dejure vassals that hold land.', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_sub_realm_barony = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_sub_realm_county', description: 'Iterate through all counties in sub-realm, counting only titles that either hold land or have dejure vassals that hold land.', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_sub_realm_county = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_sub_realm_duchy', description: 'Iterate through all duchies in sub-realm, counting only titles that either hold land or have dejure vassals that hold land.', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_sub_realm_duchy = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_sub_realm_empire', description: 'Iterate through all empires in sub-realm, counting only titles that either hold land or have dejure vassals that hold land.', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_sub_realm_empire = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_sub_realm_kingdom', description: 'Iterate through all kingdoms in sub-realm, counting only titles that either hold land or have dejure vassals that hold land.', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_sub_realm_kingdom = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_sub_realm_title', description: 'Iterate through all titles in sub-realm, counting only titles that either hold land or have dejure vassals that hold land.', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_sub_realm_title = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_subject', description: 'Iterate through all vassals and tributaries', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_subject = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_succession_appointment_invested_candidate', description: 'Iterate through all candidates supported by the scoped investor character for any title', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "It may contain people outside of investor's top realm or no longer valid for appointment\nany_succession_appointment_invested_candidate = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_succession_appointment_invested_title', description: 'Iterate through all titles that has candidates supported by the scoped investor', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "It may contain titles outside of investor's top realm, and so invalid for appointment,\nand candidates may be already dead\nany_succession_appointment_invested_title = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_targeting_faction', description: 'Iterate through all factions targeting the scope character', supportedScopes: ['character'], supportedTargets: ['faction'], outputScope: 'faction', isIterator: true, valueType: 'block', syntax: "Optionally specify a faction type filter\nany_targeting_faction = { faction_type = independence_faction }\nany_targeting_faction = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_targeting_scheme', description: 'Iterate through all schemes targeting the character', supportedScopes: ['character'], supportedTargets: ['scheme'], outputScope: 'scheme', isIterator: true, valueType: 'block', syntax: "any_targeting_scheme = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_targeting_secret', description: 'Iterate through all secrets that target the specified scope', supportedScopes: ['character'], supportedTargets: ['secret'], outputScope: 'secret', isIterator: true, valueType: 'block', syntax: "any_targeting_secret = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_tax_collector', description: 'Iterates through all Tax Collectors employed by the scoped character', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_tax_collector = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_tax_collector_vassal', description: 'Iterates through all Vassals the scoped Character is the Tax Collector for', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_tax_collector_vassal = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_tax_slot', description: 'Iterates through all Tax Slots the scoped character has', supportedScopes: ['character'], supportedTargets: ['tax_slot'], outputScope: 'tax_slot', isIterator: true, valueType: 'block', syntax: "any_tax_slot = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_top_realm_border_county', description: 'Iterate through all counties that are on the edge of your realm bordering a different neighboring top realm.', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_top_realm_border_county = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_traveling_family_member', description: 'Iterate though all characters that should travel with the scoped one (when moving between courts for instance); includes the scoped character', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_traveling_family_member = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_tributary', description: 'Iterate through all tributaries', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_tributary = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_truce_holder', description: 'Iterate through all characters that have a truce on this character', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_truce_holder = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_truce_target', description: 'Iterate through all characters this character has a truce on', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_truce_target = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_unassigned_taxpayers', description: 'Iterates through all unassigned taxpayers for scoped Character', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_unassigned_taxpayers = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_unspent_known_secret', description: 'Iterate through all unspent secrets known by the character', supportedScopes: ['character'], supportedTargets: ['secret'], outputScope: 'secret', isIterator: true, valueType: 'block', syntax: "any_unspent_known_secret = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_vassal', description: 'Iterate through all DIRECT vassals', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "Optionally specify a vassal stance filter\nany_vassal = { vassal_stance = parochial }\nany_vassal = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_vassal_or_below', description: 'Iterate through ALL vassals, not just direct vassals', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "Optionally specify a vassal stance filter\nany_vassal_or_below = { vassal_stance = parochial }\nany_vassal_or_below = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_war_ally', description: 'Iterate through all direct war allies', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_war_ally = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_war_enemy', description: 'Iterate through all direct war enemies', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_war_enemy = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_warden_hostage', description: 'Iterate through all hostages having this warden', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_warden_hostage = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'appointment_candidate_accumulated_score', description: 'Charater\'s accumulated score for appointment for the target title.', supportedScopes: ['character'], valueType: 'comparison', syntax: "Only investment count, and not character personality.\nappointment_candidate_accumulated_score = {\ntarget = scope:title\nvalue >= scope:fixed_point\n}\n\"appointment_candidate_accumulated_score(scope:title)\" >= value", parameters: ['target'] },
  { name: 'appointment_candidate_score', description: 'Charater\'s total score for appointment for the target title', supportedScopes: ['character'], valueType: 'comparison', syntax: "appointment_candidate_score = {\ntarget = scope:title\nvalue >= scope:fixed_point\n}\n\"appointment_candidate_score(scope:title)\" >= value", parameters: ['target'] },
  { name: 'appointment_level_for_title', description: 'Compare character\'s currency level required for appointment for target title', supportedScopes: ['character'], valueType: 'comparison', syntax: "\"scope:character.appointment_level_for_title(scope:target_title)\" > 2)\nscope:character = {\nappointment_level_for_title = {\ntarget = scope:target_title\nvalue > 2\n}\n}", parameters: ['target'] },
  { name: 'appointment_timeout_days', description: 'How many days until charcater can participate in appointment', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'aptitude', description: 'What is the scoped character\'s aptitude in the target court position type? aptitude = { court_position = court_position_type value >= 1 }', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'attraction', description: 'Attraction value for the scoped character', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'average_amenity_level', description: 'average_amenity_level >= 3', supportedScopes: ['character'], valueType: 'comparison', syntax: "Compares the scoped character's average amenity level to the given value, you probably never want to check for direct equality since the average will be some decimal number" },
  { name: 'barter_goods', description: 'does the character have the required barter goods?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'base_weight', description: 'Base weight of the scoped character', supportedScopes: ['character'], valueType: 'comparison', syntax: "base_weight > 10" },
  { name: 'can_accept_task_contract', description: 'Check character against task contract requirement triggers?', supportedScopes: ['character'], supportedTargets: ['task_contract'], syntax: "scope:actor = { can_accept_task_contract = SCOPE_TASK_CONTRACT }" },
  { name: 'can_add_hook', description: 'will trying to hook the target character override the current hook? (if no current hook, always returns true)', supportedScopes: ['character'], syntax: "can_add_hook = {\ntarget = <character>\ntype = <hook type>\ndays/months/year = whatever (optional; will use the duration from the type if not provided)\n}", parameters: ['target', 'type', 'days', 'months', 'year'] },
  { name: 'can_afford_enact_treasury_budget_costs', description: 'Can this character pay for the current treasury enact budget costs?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'can_appoint_for_title', description: 'Can character be appointed for the target title.', supportedScopes: ['character'], supportedTargets: ['landed_title'], syntax: "Appointment is only allowed for main administrative tier of the holder's government and above,\nand if it's top tier title for the holder" },
  { name: 'can_arrive_in_time_to_activity_minimum', description: 'can_arrive_in_time_to_activity_minimum = target_activity', supportedScopes: ['character'], supportedTargets: ['activity'], syntax: "Can the scoped character arrive to the target activity in time? (only does rough but performance consideration)" },
  { name: 'can_assign_to_tax_slot', description: 'Is this scoped character valid to assign to target tax slot', supportedScopes: ['character'], supportedTargets: ['tax_slot'], syntax: "scope:character = { can_assign_to_tax_slot = scope:tax_slot }" },
  { name: 'can_attack_in_hierarchy', description: 'can the scope target be attacking the defender based on their liege-vassal relations?', supportedScopes: ['character'] },
  { name: 'can_be_acclaimed', description: 'Can the given character potentially be the Acclaimed Knight of an Accolade?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'can_be_child_of', description: 'Would the target character have been able to have children at the time of the scoped character\'s birth? Only age is taken into account', supportedScopes: ['character'] },
  { name: 'can_be_employed_as', description: 'can the scoped character be employed as target court position type?', supportedScopes: ['character'] },
  { name: 'can_be_parent_of', description: 'Would the scoped character have been able to have children at the time of the target character\'s birth? Only age is taken into account', supportedScopes: ['character'] },
  { name: 'can_be_tributary_of', description: 'Can the scoped character be tributary of target character', supportedScopes: ['character'] },
  { name: 'can_become_owner_of_legend', description: 'Can the scoped character become owner of the provided legend?', supportedScopes: ['character'], supportedTargets: ['legend'], syntax: "scope:character = {\ncan_become_owner_of_legend = <legend>\n}" },
  { name: 'can_benefit_from_artifact', description: 'Can the scoped character benefit from the main bonuses of this artifact?', supportedScopes: ['character'], supportedTargets: ['artifact'] },
  { name: 'can_create_faction', description: 'can the character create the faction of the specified type against the specified character?', supportedScopes: ['character'], syntax: "can_create_faction = { type = X target = Y }" },
  { name: 'can_create_maa', description: 'Can target character create MaA of specified type', supportedScopes: ['character'] },
  { name: 'can_create_task_contract', description: 'scope:owner = { can_create_task_contact = { type_name = <key> employer = <character> }', supportedScopes: ['character'], syntax: "can_create_task_contact = <key>\nCan create task contract with <key> type and employer(optional)", parameters: ['can_create_task_contact'] },
  { name: 'can_declare_war', description: 'Can the scoped character declare war on the defender with the specified casus bellis on the defender character for the target titles with an optional claimant. can_declare_war = { defender = X casus_belli = Y target_titles = { Z } claimant = A }', supportedScopes: ['character'] },
  { name: 'can_diverge', description: 'Can this ruler diverge their culture? Includes checking the cost', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'can_diverge_excluding_cost', description: 'Can this ruler diverge their culture? Does not check the cost', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'can_embrace_tradition', description: 'Can scoped charater embrace new culture tradition?', supportedScopes: ['character'], syntax: "scope:character = { can_embrace_tradition = scope:new_tradition }\nscope:character = {\ncan_embrace_tradition = {\ntradition = scope:new_tradition\nreplace = my_old_tradition\n}\n}", parameters: ['tradition', 'replace'] },
  { name: 'can_employ_court_position_type', description: 'Can the scoped character employ the target court position type and is the position vacant?', supportedScopes: ['character'] },
  { name: 'can_equip_artifact', description: 'Can the scoped character equip given artifact?', supportedScopes: ['character'], supportedTargets: ['artifact'] },
  { name: 'can_execute_decision', description: 'Is the scoped character able to execute the asigned decision?', supportedScopes: ['character'], supportedTargets: ['decision'] },
  { name: 'can_fund_project_contribution', description: 'Checks if the Character can fund the specified Contribution. The Contribution must be specified as scoped object.', supportedScopes: ['character'], supportedTargets: ['project_contribution'], syntax: "Notice this will check for the triggers in the Contribution, but will also check if the Contribution wasn't already funded or was locked due to the Project being started.\nusage:\n<scope:character> = {\ncan_fund_project_contribution = var:saved_contribution\n}" },
  { name: 'can_have_children', description: 'can the character have children? Only checks hard blocks from traits, not fertility', supportedScopes: ['character'], valueType: 'boolean', syntax: "can_have_children = yes/no" },
  { name: 'can_host_activity', description: 'can_host_activity = target_activity', supportedScopes: ['character'], supportedTargets: ['activity_type'], syntax: "Can the scoped character host the target activity type" },
  { name: 'can_hybridize', description: 'Can this ruler hybridize with the target culture? Includes checking the cost', supportedScopes: ['character'], supportedTargets: ['culture'] },
  { name: 'can_hybridize_excluding_cost', description: 'Can this ruler hybridize with the target culture? Does not check the cost', supportedScopes: ['character'], supportedTargets: ['culture'] },
  { name: 'can_join_activity', description: 'can_join_activity = target_activity', supportedScopes: ['character'], supportedTargets: ['activity'], syntax: "Can the scoped character join the target activity" },
  { name: 'can_join_faction', description: 'Can the scope character join the faction? can_join_faction = faction', supportedScopes: ['character'], supportedTargets: ['faction'] },
  { name: 'can_join_or_create_faction_against', description: 'Can the scope character create if join a faction against the target?', supportedScopes: ['character'], syntax: "can_join_or_create_faction_against = scope:faction_target\ncan_join_or_create_faction_against = {\nwho = scope:faction_target\nfaction = faction_key # optional\ncheck_in_a_faction = no # default: yes\n}", parameters: ['who', 'faction', 'check_in_a_faction'] },
  { name: 'can_nomad_raze_holding', description: 'Interface trigger for checking if the scoped Nomad can raze the holding of the provided province using the Raze Holding command.', supportedScopes: ['character'], supportedTargets: ['province'], syntax: "scope:nomad = { can_nomad_raze_holding = scope:province }" },
  { name: 'can_plan_great_project', description: 'Checks if the given Character can start planning a Great Project with the given type somewhere in their realm.', supportedScopes: ['character'], supportedTargets: ['great_project_type'], syntax: "Will check both is_shown and can_start_planning triggers, as well as the cost required to start the project.\nusage:\n<scope:character> = {\ncan_plan_great_project = scope:great_project_type\n}" },
  { name: 'can_plan_great_project_in_province', description: 'Checks if the given Character can start planning a Great Project with the given key in the given province. Use the key from the DB to refer to the project.', supportedScopes: ['character'], syntax: "Will fail if the planner or project type are invalid.\nusage:\n<scope:character> = {\ncan_plan_great_project_in_province = {\ntype_name = <key>\nprovince = <province>\n}\n}", parameters: ['type_name', 'province'] },
  { name: 'can_sponsor_inspiration', description: 'can_sponsor_inspiration = inspiration', supportedScopes: ['character'], supportedTargets: ['inspiration'], syntax: "Can the scoped character sponsor the target inspiration" },
  { name: 'can_start_scheme', description: 'can the character start the scheme?', supportedScopes: ['character'], syntax: "can_start_scheme = { type = X target = Y }" },
  { name: 'can_vassals_be_attacked', description: 'Checks if the ruler has can_vassals_be_attacked modifier', supportedScopes: ['character'], valueType: 'boolean', syntax: "scope:character = {\ncan_vassals_be_attacked = yes\n}" },
  { name: 'cease_tribute_payments_ai_chance', description: 'cease_tribute_payments_ai_chance > 10', supportedScopes: ['character'], valueType: 'comparison', syntax: "Gets the ai_chance value of the cease_tribute_payments_interaction ai_chance" },
  { name: 'character_has_commander_trait_scope_does_not', description: 'Does the character have a commander trait that the scope does not?', supportedScopes: ['character'] },
  { name: 'character_is_land_realm_neighbor', description: 'Is the scoped character a realm neighbor of the target? Meaning they\'re independent or has the same liege, and border your realm.', supportedScopes: ['character'] },
  { name: 'character_is_realm_neighbor', description: 'Is the scoped character a realm neighbor of the target? Meaning they\'re independent or has the same liege, and border your realm. Including across two sea zones', supportedScopes: ['character'] },
  { name: 'character_men_at_arms_expense_gold_relative', description: 'What is the ratio of the scoped character\'s men-at-arms gold expenses, relative to their income?', supportedScopes: ['character'], valueType: 'comparison', syntax: "Similar calc compared to `ai_men_at_arms_expense_gold_min` / `ai_men_at_arms_expense_gold_ideal`.\n(Relative value 0.0 - 1.0 - *, where 1.0 is all income, unraised maa costs)" },
  { name: 'character_men_at_arms_expense_prestige_relative', description: 'What is the ratio of the scoped character\'s men-at-arms prestige expenses, relative to their income?', supportedScopes: ['character'], valueType: 'comparison', syntax: "Similar calc compared to `ai_men_at_arms_expense_prestige_min` / `ai_men_at_arms_expense_prestige_ideal`.\n(Relative value 0.0 - 1.0 - *, where 1.0 is all income, unraised maa costs)" },
  { name: 'character_men_at_arms_expense_treasury_relative', description: 'What is the ratio of the scoped character\'s men-at-arms treasury expenses, relative to their income?', supportedScopes: ['character'], valueType: 'comparison', syntax: "Similar calc compared to `ai_men_at_arms_expense_treasury_min` / `ai_men_at_arms_expense_treasury_ideal`.\n(Relative value 0.0 - 1.0 - *, where 1.0 is all income, unraised maa costs)" },
  { name: 'character_treasury_budget_capacity', description: 'Was the scoped character\'s current enacted treasury budget capacity (aka spendable Treasury) this big?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'character_treasury_new_budget_capacity', description: 'Is the scoped character\'s new treasury budget capacity (aka spendable Treasury right now) this big?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'completely_controls', description: 'does the character controls all counties and baronies inside de jure title (no hostile occupation either)?', supportedScopes: ['character'], supportedTargets: ['landed_title'] },
  { name: 'completely_controls_region', description: 'does the character controls all counties and baronies inside the specified region (no hostile occupation either)?', supportedScopes: ['character'], supportedTargets: ['geographical_region'] },
  { name: 'council_task_monthly_progress', description: 'Is the scoped character\'s monthly progress on their assigned council task this big?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'court_grandeur_base', description: 'Gets the base court grandeur value for a character, always NRoyalCourt::COURT_GRANDEUR_MIN for those without one', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'court_grandeur_current', description: 'Gets the current court grandeur value for a character, always NRoyalCourt::COURT_GRANDEUR_MIN for those without one', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'court_grandeur_current_level', description: 'Gets the current court grandeur level for a character, always 0 for those without one', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'court_grandeur_minimum_expected', description: 'Gets the minimum expected court grandeur value for a character, always NRoyalCourt::COURT_GRANDEUR_MIN for those without one', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'court_grandeur_minimum_expected_level', description: 'Gets the minimum expected court grandeur level for a character, always 0 for those without one', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'court_positions_currently_available', description: 'How many court positions the scoped character CAN currently employs', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'court_positions_currently_filled', description: 'How many court positions the scope character currently employs', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'create_faction_type_chance', description: 'Check if the chance to create a faction against a target of the scope character is is true against the scripted value', supportedScopes: ['character'], valueType: 'comparison', syntax: "create_faction_type_chance = {\ntype = faction_type #An ongoing faction\ntarget = target_character\nvalue <|<=|>=|> 0\n}", parameters: ['type', 'target'] },
  { name: 'current_domain_fertility', description: 'Get the current domain fertility of the scoped character', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'current_military_strength', description: 'Is the scoped character\'s current military strength this big?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'current_raised_military_strength', description: 'Is the scoped character\'s current raised military strength this big?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'current_weight', description: 'Current weight of the scoped character', supportedScopes: ['character'], valueType: 'comparison', syntax: "current_weight > 10" },
  { name: 'current_weight_for_portrait', description: 'Current weight of the scoped character as a value for portraits scaled between 0.0 and 1.0', supportedScopes: ['character'], valueType: 'comparison', syntax: "current_weight_for_portrait > 0.1" },
  { name: 'days_as_ruler', description: 'Number of days this character has been a ruler, returns -1 if character isn\'t a ruler', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'days_in_prison', description: 'number of days the character has been imprisoned for (0 if not imprisoned)', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'days_of_continuous_peace', description: 'Number of days the character has been in peace (0 if in war). Raids count as \'not peace\'', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'days_of_continuous_war', description: 'Number of days the character has been in peace (0 if in peace)', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'days_since_death', description: 'number of days since the character has died.', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'days_since_joined_court', description: 'days_since_joined_court > 5', supportedScopes: ['character'], valueType: 'comparison', syntax: "Gets the days since scoped character joined their current court" },
  { name: 'days_since_vassal_contract_liege_dynasty_reign_start', description: 'Days since this vassal\'s liege\'s dynasty started ruling over this vassal', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'death_reason', description: 'Does the scoped character have the given death reason?', supportedScopes: ['character'], syntax: "death_reason = death_natural_causes" },
  { name: 'debt_level', description: 'Is the scoped character\'s debt level this value? -1 if not meeting any debt level threshold.', supportedScopes: ['character'], valueType: 'comparison', syntax: "0 for the first one, and so on.\nNote that this might not match exactly with the modifier in effect as it calculates what the modifier will be now, and the character's actual modifier can lag behind" },
  { name: 'diarch_aptitude', description: 'Diarch aptitude score for the scoped (potential) diarch', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'diarch_loyalty', description: 'Diarch loyalty score for the scoped (potential) diarch', supportedScopes: ['character'], valueType: 'comparison', syntax: "scope:diarch = { diarch_loyalty >= 50 }" },
  { name: 'diarchy_swing', description: 'Get diarchy scales of power swing', supportedScopes: ['character'], valueType: 'comparison', syntax: "scope:liege = { diarchy_swing > 50 }" },
  { name: 'diplomacy', description: 'does the character have the required diplomacy skill level?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'diplomacy_diff', description: 'does the character have the required diplomacy skill level difference against target?', supportedScopes: ['character'], valueType: 'comparison', syntax: "diplomacy = { target = character value <= script_value abs = yes/no(optional, default no) }", parameters: ['diplomacy'] },
  { name: 'diplomacy_for_portrait', description: 'Diplomacy skill scaled between 0.0 and 1.0 for portraits', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'diplomacy_lifestyle_perk_points', description: 'How many perk points available does the character have?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'diplomacy_lifestyle_perks', description: 'How many perks from this lifestyle does the character have?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'diplomacy_lifestyle_unlockable_perks', description: 'How many perks from this lifestyle can the character currently unlock? This checks that they have the parent perks, and that the can_be_picked is met. It doesn\'t check perk points', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'diplomacy_lifestyle_xp', description: 'How many perk points available does the character have?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'does_ai_liege_in_vassal_contract_desire_admin_province_obligation_change', description: 'Does the AI liege in a vassal contract desire changing an obligation level - only applies to Admin Province Type obligations', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'does_ai_liege_in_vassal_contract_desire_obligation_change', description: 'Does the AI liege in a vassal contract desire changing an obligation level', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'does_ai_subject_in_subject_contract_desire_admin_province_obligation_change', description: 'Does the AI subject in a subject contract desire changing an obligation level - only applies to Admin Province Type obligations', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'does_ai_subject_in_subject_contract_desire_obligation_change', description: 'Does the AI subject in a subject contract desire changing an obligation level', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'does_ai_vassal_in_vassal_contract_desire_obligation_change', description: 'Does the AI vassal in a vassal contract desire changing an obligation level', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'domain_limit', description: 'Is the scoped character\'s domain limit this big?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'domain_limit_available', description: 'Is there this much space left in the character\'s domain limit? Negative values also work for checking characters that are above their limit', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'domain_limit_percentage', description: 'Is the scoped character\'s domain this big in comparison to their limit?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'domain_size', description: 'Is the scoped character\'s domain this big?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'domain_size_excluding_grace_period', description: 'Is the scoped character\'s domain this big? Does not count titles currently in the grace period', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'dread', description: 'does the character have the required dread?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'dread_modified_ai_boldness', description: 'AI boldness modified by the dread of the specified character', supportedScopes: ['character'], syntax: "dread_modified_ai_boldness = {\ncharacter = root\t# the character whose dread is affecting the target character\nvalue >= 5\n}", parameters: ['character'] },
  { name: 'effective_age', description: 'is the character old/young enough? If immortal, this uses the age they became immortal at', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'employs_court_position', description: 'is the scoped character employing a target court position type?', supportedScopes: ['character'] },
  { name: 'employs_tax_collector', description: 'employs_tax_collector = yes', supportedScopes: ['character'], valueType: 'boolean', syntax: "Does the scoped character have any Tax Collectors employed?" },
  { name: 'fertility', description: 'does the character have the required fertility?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'focus_progress', description: 'Does the character have this much focus progress', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'gold', description: 'does the character have the required gold?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'government_allows', description: 'checks if the government of the character allows something', supportedScopes: ['character'] },
  { name: 'government_disallows', description: 'checks if the government of the character disallows something', supportedScopes: ['character'] },
  { name: 'government_has_flag', description: 'checks if the government of the character has a specific flag', supportedScopes: ['character'] },
  { name: 'has_access_to_maa', description: 'Does the target character have access to MaA of specified type (excluding through tributaries)', supportedScopes: ['character'] },
  { name: 'has_active_diarchy', description: 'Does the scoped character has an active diarchy', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'has_active_mandate', description: 'Does the diarch have this mandate active?', supportedScopes: ['character'], syntax: "scope:diarch = { has_active_mandate = live_long_and_prosper }" },
  { name: 'has_activity_intent', description: 'has_activity_intent = key', supportedScopes: ['character'], syntax: "Does the scoped character have the given activity intent" },
  { name: 'has_activity_state', description: 'has_activity_state > travel/passive/active', supportedScopes: ['character'], syntax: "Does the scoped character have the given state in their currenty involved activity" },
  { name: 'has_any_artifact', description: 'does the scoped character have any artifacts?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'has_any_artifact_claim', description: 'does the scoped character have any artifact claims at all? ( CHEAP )', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'has_any_cb_on', description: 'does the scope character have any casus bellis on the taget character?', supportedScopes: ['character'] },
  { name: 'has_any_court_position', description: 'does the scoped character have any court positions?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'has_any_display_cb_on', description: 'does the scope character have any casus bellis on the taget character that should be displayed? (Allowed to fail valid_to_start_display_regardless)', supportedScopes: ['character'] },
  { name: 'has_any_focus', description: 'Does the character have any focus set?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'has_any_nickname', description: 'Has the scope character any nickname?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'has_any_opinion_with_reason', description: 'Does the scoped character have an opinion toward anyone with the target reason?', supportedScopes: ['character'], syntax: "has_any_opinion_with_reason = imprisonment_reason" },
  { name: 'has_any_scripted_relation', description: 'does the scope character have any scripted relation with the taget character?', supportedScopes: ['character'] },
  { name: 'has_any_secret_relation', description: 'does the scope character have any secret relation with the taget character?', supportedScopes: ['character'] },
  { name: 'has_any_secrets', description: 'Does the character have any secrets?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'has_any_unequipped_artifact', description: 'does the scoped character have any unequipped artifacts?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'has_appointment_influence_level_for_title_tier', description: 'Does the character has a high enough Influence Level for appointment for target title? Will ignore current title laws.', supportedScopes: ['character'], supportedTargets: ['landed_title'], syntax: "scope:character = {\nhas_appointment_influence_level_for_title_tier = scope:target_title\n}" },
  { name: 'has_appointment_invested_character', description: 'Has scoped investor supported appointment of target character in the same realm.', supportedScopes: ['character'], supportedTargets: ['character'], syntax: "Ignores if candidate has a valid reason to be appointed\nscope:investor = {\nhas_appointment_investment_in_character = scope:candidate\n}", parameters: ['has_appointment_investment_in_character'] },
  { name: 'has_appointment_invested_title', description: 'Has scoped investor supported appointment for target title in the same realm.', supportedScopes: ['character'], supportedTargets: ['landed_title'], syntax: "Returns true even for dead candidates, for the sake of efficiency.\nscope:investor = {\nhas_appointment_investment_in_title = scope:title\n}", parameters: ['has_appointment_investment_in_title'] },
  { name: 'has_appointment_level_for_title', description: 'Does the character has currency level sufficient for appointment for target title', supportedScopes: ['character'], supportedTargets: ['landed_title'], syntax: "scope:character = {\nhas_appointment_level_for_title = scope:target_title\n}" },
  { name: 'has_appointment_merit_level_for_title_tier', description: 'Does the character has a high enough Merit Level for appointment for target title? Will ignore current title laws.', supportedScopes: ['character'], supportedTargets: ['landed_title'], syntax: "scope:character = {\nhas_appointment_merit_level_for_title_tier = scope:target_title\n}" },
  { name: 'has_appointment_piety_level_for_title_tier', description: 'Does the character has a high enough Level of Devotion for appointment for target title? Will ignore current title laws.', supportedScopes: ['character'], supportedTargets: ['landed_title'], syntax: "scope:character = {\nhas_appointment_piety_level_for_title_tier = scope:target_title\n}" },
  { name: 'has_appointment_prestige_level_for_title_tier', description: 'Does the character has a high enough Prestige Level for appointment for target title? Will ignore current title laws.', supportedScopes: ['character'], supportedTargets: ['landed_title'], syntax: "scope:character = {\nhas_appointment_prestige_level_for_title_tier = scope:target_title\n}" },
  { name: 'has_artifact_claim', description: 'Does the scoped character have a personal or house claim on the target artifact', supportedScopes: ['character'], supportedTargets: ['artifact'] },
  { name: 'has_away_hostages', description: 'Does the scoped character have Hostages abroad?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'has_bad_nickname', description: 'Has the scope character a bad nickname?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'has_banish_reason', description: 'Does the character have the banish reason towards the target?', supportedScopes: ['character'] },
  { name: 'has_cb_on', description: 'does the scope character have the specified casus bellis on the taget character? Invalid target returns false automatically. has_cb_on = { target = X casus_belli/cb = Y }', supportedScopes: ['character'] },
  { name: 'has_character_flag', description: 'Does the character have this flag?', supportedScopes: ['character'] },
  { name: 'has_character_modifier', description: 'Does the scoped character have a given modifier', supportedScopes: ['character'], syntax: "has_character_modifier = name" },
  { name: 'has_character_modifier_duration_remaining', description: 'Does the scoped character have the duration remaining on a given modifier', supportedScopes: ['character'], syntax: "has_character_modifier_duration_remaining = name" },
  { name: 'has_claim_on', description: 'does the character have an explicit claim on the target title?', supportedScopes: ['character'], supportedTargets: ['landed_title'] },
  { name: 'has_completed_activity_intent', description: 'has_completed_activity_intent = { type = <key> target = <character> }', supportedScopes: ['character'], syntax: "has_completed_activity_intent = <key>\nHas the scoped character completed an intent of the given type in their involved activity, optionally against a specific target." },
  { name: 'has_completed_inspiration', description: 'has_completed_inspiration = bool', supportedScopes: ['character'], valueType: 'boolean', syntax: "Checks if the scoped character has ever completed an inspiration" },
  { name: 'has_contact', description: 'Check if laamp has character as employer?', supportedScopes: ['character'], supportedTargets: ['character'], syntax: "scope:actor = { has_contact = SCOPE_CHARACTER }" },
  { name: 'has_council', description: 'Does character have a council?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'has_council_position', description: 'Does the scoped character have the given position?', supportedScopes: ['character'] },
  { name: 'has_councillor_for_skill', description: 'does the scope character have a councillor for the specified skill?', supportedScopes: ['character'], syntax: "has_councillor_for_skill = X, where X is a skill name or 'general'" },
  { name: 'has_court_language', description: 'Is the character\'s court language the given language?', supportedScopes: ['character'], syntax: "has_court_language = language_norwegian" },
  { name: 'has_court_language_of_culture', description: 'Is the character\'s court language the language of the target culture?', supportedScopes: ['character'], supportedTargets: ['culture'], syntax: "has_court_language_of_culture = scope:target_culture" },
  { name: 'has_court_position', description: 'is the scoped character holding the target court position type?', supportedScopes: ['character'] },
  { name: 'has_court_type', description: 'has_court_type = court_diplomatic', supportedScopes: ['character'], syntax: "Does the character have this court type?" },
  { name: 'has_culture', description: 'Does the character have this culture?', supportedScopes: ['character'], supportedTargets: ['culture'] },
  { name: 'has_de_jure_claim_on', description: 'does the scope character have a dejure claim against the target?', supportedScopes: ['character'] },
  { name: 'has_dead_character_flag', description: 'Does the dead character have this flag?', supportedScopes: ['character'] },
  { name: 'has_dead_character_variable', description: 'Does the dead character have this variable?', supportedScopes: ['character'] },
  { name: 'has_diarchy_active_parameter', description: 'Does active diarchy have this parameter active for current power level?', supportedScopes: ['character'], syntax: "scope:liege = { has_diarchy_active_parameter = parameter_name }" },
  { name: 'has_diarchy_parameter', description: 'Can active diarchy have this parameter at some power level?', supportedScopes: ['character'], syntax: "scope:liege = { has_diarchy_parameter = parameter_name }" },
  { name: 'has_diarchy_type', description: 'Is scope character in a diarchy of a specific type?', supportedScopes: ['character'], syntax: "Trigger works even when there's no active diarchyscope:liege = { has_diarchy_type = regency }" },
  { name: 'has_divorce_reason', description: 'Does the character have the divorce reason towards the target?', supportedScopes: ['character'] },
  { name: 'has_domicile', description: 'Does scoped character have a domicile?', supportedScopes: ['character'], valueType: 'boolean', syntax: "scope:character = { has_domicile = yes }" },
  { name: 'has_domicile_temperament_high', description: 'Does scoped character have domicile temperament high?', supportedScopes: ['character'], valueType: 'boolean', syntax: "scope:character = { has_temperament_high = yes }" },
  { name: 'has_domicile_temperament_low', description: 'Does scoped character have domicile temperament low?', supportedScopes: ['character'], valueType: 'boolean', syntax: "scope:character = { has_temperament_low = yes }" },
  { name: 'has_domicile_temperament_neutral', description: 'Does scoped character have domicile temperament neutral?', supportedScopes: ['character'], valueType: 'boolean', syntax: "scope:character = { has_temperament_neutral = yes }" },
  { name: 'has_dread_level_towards', description: 'How much is scared the scope character agains the target. 0 = not intimidated, 1 = intimidated, 2 = cowed.', supportedScopes: ['character'], syntax: "has_dread_level_towards = {\ntarget = X\nlevel >/</>=/<=/= Y\n}", parameters: ['target'] },
  { name: 'has_dynasty', description: 'does the character have a valid dynasty?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'has_election_vote_of', description: 'Is the target character voting for the scoped character in the election of the target title', supportedScopes: ['character'], syntax: "has_election_vote_of = { who = scope:actor title = primary_title }" },
  { name: 'has_employed_any_court_position', description: 'does the scoped character have any employed court positions?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'has_execute_reason', description: 'Does the character have the execute reason towards the target?', supportedScopes: ['character'] },
  { name: 'has_faith', description: 'Does the character have this faith?', supportedScopes: ['character'], supportedTargets: ['faith'], syntax: "has_faith = faith:baltic_pagan" },
  { name: 'has_father', description: 'does the character have a valid living father?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'has_focus', description: 'Does the character have this focus?', supportedScopes: ['character'] },
  { name: 'has_free_council_slot', description: 'Does the scope character have a council position to fill? (ignoring automatically filled positions)', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'has_gene', description: 'Does the character have the specified gene template? Only works for morph genes. An interface trigger. has_gene = { category = X template = Y }', supportedScopes: ['character'], syntax: "An interface trigger, can only be used in specific places" },
  { name: 'has_government', description: 'checks if the character has a specific government type', supportedScopes: ['character'] },
  { name: 'has_had_focus_for_days', description: 'Does the character had a focus for that time?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'has_hook', description: 'does the character have a hook on the target, has_hook = <character>', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'has_hook_from_secret', description: 'does the character have a hook based on the target secret? example use: has_hook_from_secret = scope:saved_secret', supportedScopes: ['character'], supportedTargets: ['secret'] },
  { name: 'has_hook_of_type', description: 'does the character have a hook on the target of the given type?, has_hook_of_type = { target = X type = Y }', supportedScopes: ['character'] },
  { name: 'has_imprisonment_reason', description: 'Does the character have the imprisonment reason towards the target?', supportedScopes: ['character'] },
  { name: 'has_inactive_trait', description: 'Does the character have this trait or a trait of this trait group amongst their inactive traits?', supportedScopes: ['character'] },
  { name: 'has_legitimacy', description: 'Does the scoped character uses legitimacy', supportedScopes: ['character'], valueType: 'boolean', syntax: "has_legitimacy = yes" },
  { name: 'has_legitimacy_flag', description: 'Does the scoped character\'s current legitimacy level have the given flag', supportedScopes: ['character'], syntax: "has_legitimacy_flag = cool_folk" },
  { name: 'has_lifestyle', description: 'Does the character have this lifestyle?', supportedScopes: ['character'] },
  { name: 'has_mother', description: 'does the character have a valid living mother?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'has_nickname', description: 'Does the character have this nickname?', supportedScopes: ['character'] },
  { name: 'has_obedience_reason', description: 'Does the character have the obedience reason towards the target?', supportedScopes: ['character'] },
  { name: 'has_opinion_modifier', description: 'does the character have the specified opinion modifier on the target? (optional *value <|<=|=|>=|> X* or *value = { MIN MAX }* inclusive)', supportedScopes: ['character'] },
  { name: 'has_opposite_relation', description: 'Does the scope character have an opposite relationship of the relation value with the target character? target = , relation =', supportedScopes: ['character'] },
  { name: 'has_outstanding_artifact_claims', description: 'does the scoped character have any artifact claims that can be pressed? ( EXPENSIVE )', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'has_owned_scheme', description: 'Does this character own a scheme?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'has_pending_court_events', description: 'has_pending_court_events = bool', supportedScopes: ['character'], valueType: 'boolean', syntax: "Does the character have pending court events? Meaning court events that'll spawn when they next open the royal court view.\nCan only be used on player characters with a royal court." },
  { name: 'has_pending_interaction_of_type', description: 'Does the character have a pending interaction of the type? Only works if the scope is player-controlled.', supportedScopes: ['character'], syntax: "Example: has_pending_interaction = interaction_key" },
  { name: 'has_perk', description: 'Does the character have this perk?', supportedScopes: ['character'] },
  { name: 'has_personal_artifact_claim', description: 'Does the scoped character have a personal claim on the target artifact', supportedScopes: ['character'], supportedTargets: ['artifact'] },
  { name: 'has_personal_legend_seed', description: 'Does the scoped character have a legend seed of the specified legend type?.', supportedScopes: ['character'], supportedTargets: ['legend_type'], syntax: "scope:character = {\nhas_personal_legend_seed = heroic\n}" },
  { name: 'has_player_court_position_automation_assign_best', description: 'Is the scoped character a player that has automated the target court position to auto-assign the best candidate?', supportedScopes: ['character'], supportedTargets: ['court_position_type'] },
  { name: 'has_player_court_position_automation_assign_best_or_event', description: 'Is the scoped character a player that has automated the target court position to auto-assign the best candidate (or else show an event)?', supportedScopes: ['character'], supportedTargets: ['court_position_type'] },
  { name: 'has_player_court_position_automation_event', description: 'Is the scoped character a player that has automated the target court position to show events?', supportedScopes: ['character'], supportedTargets: ['court_position_type'] },
  { name: 'has_player_court_position_automation_none', description: 'Is the scoped character a player that has NOT automated the target court position?', supportedScopes: ['character'], supportedTargets: ['court_position_type'] },
  { name: 'has_potential_acclaimed_knights', description: 'Does the given character have any potential knights that could be appointed as Acclaimed Knights?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'has_primary_title', description: 'does the character has specific title as his primary title', supportedScopes: ['character'], supportedTargets: ['landed_title'] },
  { name: 'has_prisoners', description: 'Does the character have prisoners?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'has_raid_immunity_against', description: 'Is the scoped character\'s (top-liege) realm immune to raiding by the target due to having defeated their raid army?', supportedScopes: ['character'], supportedTargets: ['character'], syntax: "has_raid_immunity_against = scope:character" },
  { name: 'has_raised_armies', description: 'does the character have raised or gathering armies?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'has_realm_law', description: 'Does the scoped character have the given realm law?', supportedScopes: ['character'] },
  { name: 'has_realm_law_flag', description: 'Does the scoped character have a law with the given flag?', supportedScopes: ['character'] },
  { name: 'has_realm_law_in_group', description: 'Does the scoped character have a realm law in the given group?', supportedScopes: ['character'] },
  { name: 'has_relation_activity_recurrer', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_relation_antiquarian', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_relation_best_friend', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_relation_blood_brother', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_relation_bully', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_relation_court_physician', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_relation_crush', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_relation_disciple', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_relation_elder', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_relation_event_recurrer', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_relation_favorite_child', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_relation_fellow_disciple', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_relation_flag', description: 'Does the scope character have a specific flag on a relation with the target character? target = , relation = , flag =', supportedScopes: ['character'] },
  { name: 'has_relation_friend', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_relation_grudge', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_relation_guardian', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_relation_intrigue_mentor', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_relation_intrigue_student', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_relation_lover', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_relation_mentor', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_relation_nemesis', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_relation_nursed_child', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_relation_oaf', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_relation_old_flame', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_relation_potential_friend', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_relation_potential_hook', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_relation_potential_lover', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_relation_potential_rival', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_relation_rival', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_relation_soldier_friend', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_relation_soulmate', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_relation_student', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_relation_to', description: 'does the character have a relation to the target? Matches the logic of the data system function HasRelationTo, has_relation_to = <character>', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'has_relation_victim', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_relation_ward', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_relation_wedding_bad_fertility', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_relation_wedding_good_fertility', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_relation_wedding_very_bad_fertility', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_relation_wedding_very_good_fertility', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_relation_wet_nurse', description: 'Checks for a scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_religion', description: 'Does the character have this religion?', supportedScopes: ['character'], supportedTargets: ['religion'], syntax: "has_religion = religion:buddhism_religion" },
  { name: 'has_revoke_title_reason', description: 'Does the character have the revoke title reason towards the target?', supportedScopes: ['character'] },
  { name: 'has_royal_court', description: 'has_royal_court = bool', supportedScopes: ['character'], valueType: 'boolean', syntax: "Does the scoped character have a royal court" },
  { name: 'has_ruler_objective', description: 'Does this character have a ruler objective?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'has_same_court_language', description: 'Is the character\'s court language the same language as the target character\'s?', supportedScopes: ['character'], supportedTargets: ['character'], syntax: "has_same_court_language = scope:target_character" },
  { name: 'has_same_court_type_as', description: 'has_same_court_type_as = character', supportedScopes: ['character'], syntax: "Does the character have the same court type as the target?" },
  { name: 'has_same_culture_as', description: 'Does the character have the same culture as the target?', supportedScopes: ['character'] },
  { name: 'has_same_focus_as', description: 'Does the character have the same focus as the other?', supportedScopes: ['character'] },
  { name: 'has_same_government', description: 'checks if the character has the same government type as another character', supportedScopes: ['character'] },
  { name: 'has_same_sinful_trait', description: 'do the two characters share a trait that is considered sinful by both of their respective faiths?', supportedScopes: ['character'], syntax: "scope:character_1 = { has_same_sinful_trait = scope:character_2 }" },
  { name: 'has_same_virtue_trait', description: 'do the two characters share a trait that is considered virtuous by both of their respective faiths?', supportedScopes: ['character'], syntax: "scope:character_1 = { has_same_virtue_trait = scope:character_2 }" },
  { name: 'has_scheme_countermeasure_parameter', description: 'Does the given ruler, or the liege of the given courtier, have a countermeasure with the given parameter?', supportedScopes: ['character'], syntax: "Can only check for boolean parameters.\nhas_scheme_countermeasure_parameter = parameter_key" },
  { name: 'has_secret_relation_activity_recurrer', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_secret_relation_antiquarian', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_secret_relation_best_friend', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_secret_relation_blood_brother', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_secret_relation_bully', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_secret_relation_court_physician', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_secret_relation_crush', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_secret_relation_disciple', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_secret_relation_elder', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_secret_relation_event_recurrer', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_secret_relation_favorite_child', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_secret_relation_fellow_disciple', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_secret_relation_friend', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_secret_relation_grudge', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_secret_relation_guardian', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_secret_relation_intrigue_mentor', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_secret_relation_intrigue_student', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_secret_relation_lover', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_secret_relation_mentor', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_secret_relation_nemesis', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_secret_relation_nursed_child', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_secret_relation_oaf', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_secret_relation_old_flame', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_secret_relation_potential_friend', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_secret_relation_potential_hook', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_secret_relation_potential_lover', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_secret_relation_potential_rival', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_secret_relation_rival', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_secret_relation_soldier_friend', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_secret_relation_soulmate', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_secret_relation_student', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_secret_relation_victim', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_secret_relation_ward', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_secret_relation_wedding_bad_fertility', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_secret_relation_wedding_good_fertility', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_secret_relation_wedding_very_bad_fertility', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_secret_relation_wedding_very_good_fertility', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_secret_relation_wet_nurse', description: 'Checks for a secret scripted relationship with a target character', supportedScopes: ['character'] },
  { name: 'has_selected_mandate', description: 'Was this mandate selected for the diarch?', supportedScopes: ['character'], syntax: "Trigger works even when there's no active diarchyscope:diarch = { has_selected_mandate = live_long_and_prosper }" },
  { name: 'has_sexuality', description: 'Does the character\'s sexuality match the scripted? (heterosexual, homosexual, bisexual, asexual, none). Characters that have yet to get a sexuality (children) have the none set.', supportedScopes: ['character'] },
  { name: 'has_spawned_court_events', description: 'has_spawned_court_events = bool', supportedScopes: ['character'], valueType: 'boolean', syntax: "Does the character have spawned court events? Meaning court events are shown (opened or not) in the royal court view.\nCan only be used on player characters with a royal court." },
  { name: 'has_strong_claim_on', description: 'does the character have an explicit Pressed Claim on the target title?', supportedScopes: ['character'], supportedTargets: ['landed_title'] },
  { name: 'has_strong_hook', description: 'does the character have a strong hook on the target, has_strong_hook = <character>', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'has_strong_implicit_claim_on', description: 'does the character have an implicit Pressed Claim on the target title', supportedScopes: ['character'], supportedTargets: ['landed_title'] },
  { name: 'has_strong_usable_hook', description: 'does the character have a strong hook on the target that is not on cooldown, has_strong_usable_hook = <character>', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'has_subject_contract_group', description: 'Check if the character has a specific contract group', supportedScopes: ['character'], syntax: "scope:actor = { has_contract_group = { contract_group = <key> } }" },
  { name: 'has_succession_appointment_investors', description: 'Does the scope the scoped character have any investors for their appointment towards the target title?', supportedScopes: ['character'], supportedTargets: ['landed_title'], syntax: "scope:character = { has_succession_appointment_investors = scope:title }" },
  { name: 'has_targeting_faction', description: 'Has the scope character a faction targeting him/her?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'has_title', description: 'does the character hold the title?', supportedScopes: ['character'], supportedTargets: ['landed_title'] },
  { name: 'has_trait', description: 'Does the character have this trait or a trait of this trait group?', supportedScopes: ['character'] },
  { name: 'has_trait_rank', description: 'Compare the trait rank of a character to a value or other character.', supportedScopes: ['character'], syntax: "has_trait_rank = {\ntrait = TRAIT_GROUP\nrank <=> number (can be script value) # need only one of rank or character\ncharacter <=> character target # need only one of rank or character\n}\nNote that not having the trait and having rank 0 counts as the same thing. rank < X on its own will therefore always return true for a character that does not have the trait.", parameters: ['trait'] },
  { name: 'has_trait_with_flag', description: 'does the scope character have a trait with a certain flag?', supportedScopes: ['character'], syntax: "has_trait_with_flag = can_not_marry" },
  { name: 'has_trait_xp', description: 'Checks if the scopd character has the given amount of XP in the trait level track. Track name is required if the trait has multiple tracks, otherwise should not be provided.', supportedScopes: ['character'], valueType: 'comparison', syntax: "has_trait_xp = { trait = <trait_key> track = <track_key> value = <script_value> }" },
  { name: 'has_treasury', description: 'Does the scoped character use treasury', supportedScopes: ['character'], valueType: 'boolean', syntax: "has_treasury = yes" },
  { name: 'has_triggered_legend_seed', description: 'Does the scoped character qualify for the specified triggered legend seed?.', supportedScopes: ['character'], syntax: "scope:character = {\nhas_triggered_legend_seed = king_arthur\n}" },
  { name: 'has_truce', description: 'Does the scope character have a truce with the target character? Truces are one way, which means we ask if the scope character can\'t attack the target character', supportedScopes: ['character'] },
  { name: 'has_usable_hook', description: 'does the character have a hook on the target that isn\'t on cooldown, has_usable_hook = <character>', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'has_weak_claim_on', description: 'does the character have an explicit Unpressed Claim on the target title?', supportedScopes: ['character'], supportedTargets: ['landed_title'] },
  { name: 'has_weak_hook', description: 'does the character have a weak hook on the target. A strong hook will *not* count, has_weak_hook = <character>', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'has_weak_implicit_claim_on', description: 'does the character have an implicit Unpressed Claim on the target title', supportedScopes: ['character'], supportedTargets: ['landed_title'] },
  { name: 'health', description: 'does the character have the required health?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'highest_held_title_tier', description: 'what is the highest held landed title tier of the character?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'highest_skill', description: 'Is the skill the highest skill (excluding Prowess) of the character? True even when there are multiple skills with the same highest value.', supportedScopes: ['character'] },
  { name: 'highest_skill_including_prowess', description: 'Is the skill the highest skill (including Prowess) of the character? True even when there are multiple skills with the same highest value.', supportedScopes: ['character'] },
  { name: 'holds_landed_title', description: 'Is the scope character landed (holds a county or barony)?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'hostage_duration', description: 'For how long has the scope character been a hostage? { days/months/years =,>,< X }', supportedScopes: ['character'] },
  { name: 'important_action_is_valid_but_invisible', description: 'is there an important action available to the character, but they dismissed it?', supportedScopes: ['character'], syntax: "important_action_is_valid_but_invisible = important_action_key" },
  { name: 'important_action_is_visible', description: 'is there an important action shown to the character?', supportedScopes: ['character'], syntax: "important_action_is_visible = important_action_key" },
  { name: 'in_diplomatic_range', description: 'Is the scope character and the target character within each others diplomatic range?', supportedScopes: ['character'] },
  { name: 'influence', description: 'does the character have the required influence?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'influence_level', description: 'does the character have the required influence level?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'intrigue', description: 'does the character have the required intrigue skill level?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'intrigue_diff', description: 'does the character have the required intrigue skill level difference against target?', supportedScopes: ['character'], valueType: 'comparison', syntax: "intrigue = { target = character value <= script_value abs = yes/no(optional, default no) }", parameters: ['intrigue'] },
  { name: 'intrigue_for_portrait', description: 'Intrigue skill scaled between 0.0 and 1.0 for portraits', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'intrigue_lifestyle_perk_points', description: 'How many perk points available does the character have?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'intrigue_lifestyle_perks', description: 'How many perks from this lifestyle does the character have?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'intrigue_lifestyle_unlockable_perks', description: 'How many perks from this lifestyle can the character currently unlock? This checks that they have the parent perks, and that the can_be_picked is met. It doesn\'t check perk points', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'intrigue_lifestyle_xp', description: 'How many perk points available does the character have?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'is_a_faction_leader', description: 'Is the scope character a leader of a faction?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_a_faction_member', description: 'Is the scope character a member of a faction?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_acclaimed', description: 'Is the given character the Acclaimed Knight of an Accolade?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_accolade_successor', description: 'Is the given character the Successor of an Accolade?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_activity_type_on_cooldown', description: 'Is the given activity type on cooldown for the current character.', supportedScopes: ['character'], supportedTargets: ['activity_type'], syntax: "is_activity_type_on_cooldown = activity_type_key" },
  { name: 'is_adult', description: 'Is the scope character adult?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_agent_exposed_in_scheme', description: 'Is the scope character an exposed agent in the target scheme?', supportedScopes: ['character'], supportedTargets: ['scheme'] },
  { name: 'is_ai', description: 'is the character played by AI?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_alive', description: 'is the character alive or dead?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_allied_in_war', description: 'Is the scope character allied to the target character in a war?', supportedScopes: ['character'] },
  { name: 'is_allied_to', description: 'Is the scope character allied to the target character?', supportedScopes: ['character'] },
  { name: 'is_at_home', description: 'is the character at home?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_at_location', description: 'Is the character currently in the target province?', supportedScopes: ['character'], supportedTargets: ['province'] },
  { name: 'is_at_same_location', description: 'Is the character currently in the same province as the target character?', supportedScopes: ['character'] },
  { name: 'is_at_war', description: 'is the character at war? Does not consider your lieges\' wars', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_at_war_as_attacker', description: 'is the character at war as an attacker? Does not consider your lieges\' wars', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_at_war_as_defender', description: 'is the character at war as a defender? Does not consider your lieges\' wars', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_at_war_with', description: 'Is the character at war with the target? Does not consider your lieges\' wars', supportedScopes: ['character'] },
  { name: 'is_at_war_with_liege', description: 'is the character at war with their liege?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_attacker_in_war', description: 'is the scope character in the target war as an attacker?', supportedScopes: ['character'], supportedTargets: ['war'] },
  { name: 'is_attracted_to_gender_of', description: 'does the sexuality of the scope character make them attracted to the target character?', supportedScopes: ['character'] },
  { name: 'is_attracted_to_men', description: 'Is the character attracted to men?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_attracted_to_women', description: 'Is the character attracted to women?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_available_quick', description: 'A combined checks if a character is available', supportedScopes: ['character'], syntax: "All options are optional. If option is missing, it's set to \"any\" - it will have no effect on the outcome of the trigger\nscope:charater = {\nis_available_quick = {\nai = no\nalive = yes\nfemale = no\nadult = no\nincapable = no        # has any incapacitating trait\nimprisoned = no\nhostage = no\ntravel = no\nactivity = no\nruler = no\nadvanced_ruler = no   # rulers with playable data that have access to all game mechanics\n# barons, rebels, merc and holy order leaders fail this check\nlanded = no\nin_army = no          # commander or knight in the army on the map\nat_war = no\n}\n}", parameters: ['ai', 'alive', 'female', 'adult', 'incapable', 'imprisoned', 'hostage', 'travel', 'activity', 'ruler', 'advanced_ruler', 'landed', 'in_army', 'at_war'] },
  { name: 'is_away_from_court', description: 'Is the character away from the court?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_betrothed', description: 'Is the scope character betrothed?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_bloc_leader_or_bloc_leader_heir_of', description: 'is this character the bloc leader or bloc leader player heir of (target character)', supportedScopes: ['character'] },
  { name: 'is_causing_raid_hostility_towards', description: 'Is the scoped character making the target hostile due to having raided their (top-liege\'s) realm?', supportedScopes: ['character'], supportedTargets: ['character'], syntax: "is_causing_raid_hostility_towards = scope:character" },
  { name: 'is_character_interaction_potentially_accepted', description: 'Is the character interaction specified available and potentially accepted for the target character?', supportedScopes: ['character'], syntax: "is_character_interaction_potentially_accepted = {\nrecipient = character\ninteraction = interaction_name\nsecondary_actor = character <optional>\nsecondary_recipient = character <optional>\ntarget_title = title <optional>\nrequired_response = yes/maybe <optional>\nai_accept = min acceptance value <optional>\n}", parameters: ['recipient', 'interaction', 'secondary_actor', 'secondary_recipient', 'target_title', 'required_response', 'ai_accept'] },
  { name: 'is_character_interaction_shown', description: 'Is the character interaction specified shown for the target character?', supportedScopes: ['character'], syntax: "is_character_interaction_shown = {\nrecipient = character\ninteraction = interaction_name\n}", parameters: ['recipient', 'interaction'] },
  { name: 'is_character_interaction_valid', description: 'Is the character interaction specified valid (shown and usable) for the target character?', supportedScopes: ['character'], syntax: "is_character_interaction_valid = {\nrecipient = character\ninteraction = interaction_name\n}", parameters: ['recipient', 'interaction'] },
  { name: 'is_character_window_main_character', description: 'Is the local player the main character in the character window?', supportedScopes: ['character'], valueType: 'boolean', syntax: "An interface trigger, can only be used in specific places" },
  { name: 'is_child_of', description: 'Is the character a child of the target character?', supportedScopes: ['character'] },
  { name: 'is_claimant', description: 'is the character a claimant to any landed titles?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_clergy', description: 'Is the scoped character a clergy?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_close_family_of', description: 'Is the character a close family [parents, children, siblings, grandparents, grandchildren] of the target character?', supportedScopes: ['character'] },
  { name: 'is_close_or_extended_family_of', description: 'Is the character a close or extended family [parents, children, siblings, grandparents, grandchildren, cousins, uncles, aunts, nephews, nieces] of the target character?', supportedScopes: ['character'] },
  { name: 'is_commanding_army', description: 'is the character a commanding an army?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_concubine', description: 'Is the scope character a concubine?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_concubine_of', description: 'Is the target character a concubine of the scope character?', supportedScopes: ['character'] },
  { name: 'is_confederation_member', description: 'Is the scoped character a member of a confederation?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_consort_of', description: 'Is the character a spouse or concubine of the target character?', supportedScopes: ['character'] },
  { name: 'is_contact_of', description: 'Check if character is employer of laamp', supportedScopes: ['character'], supportedTargets: ['character'], syntax: "scope:actor = { is_contact_of = SCOPE_CHARACTER }" },
  { name: 'is_council_task_valid', description: 'Check if the task of the scope councillor is valid.', supportedScopes: ['character'], syntax: "character = {\nis_council_task_valid {\ntask_type = council_position_type_key\ntarget = for_targeted_tasks\n}\n}", parameters: ['character', 'task_type', 'target'] },
  { name: 'is_councillor', description: 'Is the scoped character a councillor?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_councillor_of', description: 'Is the scoped character a councillor for the specified character?', supportedScopes: ['character'] },
  { name: 'is_court_position_employer', description: 'is the scoped character employed in the target position by target character', supportedScopes: ['character'] },
  { name: 'is_courtier', description: 'Is the scope character a courtier?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_courtier_of', description: 'Is the scope character a courtier of the target character?', supportedScopes: ['character'] },
  { name: 'is_cousin_of', description: 'Is the character a cousin of the target character?', supportedScopes: ['character'] },
  { name: 'is_decision_on_cooldown', description: 'Is the given decision on cooldown for the current character.', supportedScopes: ['character'], supportedTargets: ['decision'], syntax: "is_decision_on_cooldown = decision_key" },
  { name: 'is_defender_in_war', description: 'is the scope character in the target war as a defender?', supportedScopes: ['character'], supportedTargets: ['war'] },
  { name: 'is_designated_diarch', description: 'Is the scoped character was diesignated as diarch by their liege?', supportedScopes: ['character'], valueType: 'boolean', syntax: "scope:character = { is_designated_diarch = yes/no }" },
  { name: 'is_diarch', description: 'Is the scoped character currently an active diarch of anyone?', supportedScopes: ['character'], valueType: 'boolean', syntax: "scope:character = { is_diarch = yes/no }" },
  { name: 'is_diarch_of_target', description: 'Is the scoped character currently an active diarch of the target?', supportedScopes: ['character'], supportedTargets: ['character'], syntax: "scope:character = { is_diarch_of_target = scope:liege }" },
  { name: 'is_diarchy_successor', description: 'Is the scoped character next in the line of succession for diarchy?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_employer_of', description: 'Is the target character a courtier of the scope character?', supportedScopes: ['character'] },
  { name: 'is_extended_family_of', description: 'Is the character a extended family [cousins, uncles, aunts, nephews, nieces] of the target character?', supportedScopes: ['character'] },
  { name: 'is_favorite_child', description: 'is the character their liege\'s favorite child?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_female', description: 'Is the scope character female?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_forbidden_from_scheme', description: 'Is the scope character forbidden from the target scheme?', supportedScopes: ['character'], supportedTargets: ['scheme'] },
  { name: 'is_forced_into_faction', description: 'Is the scope character forced to be part of a faction?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_forced_into_scheme', description: 'Checks if the scope character is forced into the target scheme', supportedScopes: ['character'], supportedTargets: ['scheme'] },
  { name: 'is_foreign_court_guest', description: 'Is the character a guest from another a court? In contrast to is_pool_guest the character has a liege', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_foreign_court_guest_of', description: 'Is the character a guest from another a court, visiting the target character\'s court? In contrast to is_pool_guest_of the character has a liege', supportedScopes: ['character'] },
  { name: 'is_foreign_court_or_pool_guest', description: 'Is the character a guest? (is_pool_guest or is_foreign_court_guest)', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_foreign_court_or_pool_guest_of', description: 'Is the character a guest? (is_pool_guest_of or is_foreign_court_guest_of)', supportedScopes: ['character'] },
  { name: 'is_from_ruler_designer', description: 'Was this character made from the ruler designer', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_grandchild_of', description: 'Is the character a grandchild of the target character?', supportedScopes: ['character'] },
  { name: 'is_grandparent_of', description: 'Is the character a grandparent of the target character?', supportedScopes: ['character'] },
  { name: 'is_great_grandchild_of', description: 'Is the character a great grandchild of the target character?', supportedScopes: ['character'] },
  { name: 'is_great_grandparent_of', description: 'Is the character a great grandparent of the target character?', supportedScopes: ['character'] },
  { name: 'is_heir_of', description: 'Is the character an heir of the target [placeholder]?', supportedScopes: ['character'] },
  { name: 'is_hostage', description: 'Is the scoped character a Hostage?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_hostage_from', description: 'Is the scope character a Hostage with target character as their original Liege? is_hostage_from = TARGET', supportedScopes: ['character'] },
  { name: 'is_hostage_of', description: 'Is the scope character a Hostage with target character as their Warden? is_hostage_of = TARGET', supportedScopes: ['character'] },
  { name: 'is_hostage_warden', description: 'Is the scoped character a Warden with Hostages?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_immortal', description: 'Is the character immortal?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_important_decision', description: 'Is the scoped decision an important decision for the target character?', supportedScopes: ['character'], supportedTargets: ['decision'] },
  { name: 'is_imprisoned', description: 'is the character imprisoned?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_imprisoned_by', description: 'Is the scope character imprisoned by the target character? is_imprisoned_by = TARGET', supportedScopes: ['character'] },
  { name: 'is_in_army', description: 'is the character in an army (a commander or a knight)?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_in_civil_war', description: 'is the character at war with their liege, or one or more of their vassals?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_in_debt', description: 'Is the scoped character in debt? If the character also uses Treasury this will return true if it is negative.', supportedScopes: ['character'], valueType: 'boolean', syntax: "character = { is_in_debt = yes }", parameters: ['character'] },
  { name: 'is_in_guest_subset', description: 'Is the scoped character in the specified guest subset in the activity they are', supportedScopes: ['character'], syntax: "involved in?\nis_in_guest_subset = {\nname = <subset_key>\nphase = <phase_key> #Optional\n}\nIf phase is not specified, it will check the current phase, otherwise it will\ncheck all phases matching the phase key.", parameters: ['name', 'phase'] },
  { name: 'is_in_ongoing_great_holy_war', description: 'is the character in an ongoing (i.e. the war has started) great holy war?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_in_pool_at', description: 'Is the character in the pool the target province is a part of', supportedScopes: ['character'], supportedTargets: ['province'] },
  { name: 'is_in_prison_type', description: 'is the character imprisoned in a prison of the specified type? Accepts any static modifier (see also imprison effect).', supportedScopes: ['character'], syntax: "is_in_prison_type = house_arrest" },
  { name: 'is_in_the_same_court_as', description: 'Is the character in the same court as the target character (they have the same court owner or one is a courtier of the other)?', supportedScopes: ['character'] },
  { name: 'is_in_the_same_court_as_or_guest', description: 'Is the character in the same court as the target character (they have the same court owner or one is a courtier of the other)? Includes guests in the court.', supportedScopes: ['character'] },
  { name: 'is_incapable', description: 'is the character incapable?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_independent_ruler', description: 'is the character an independent ruler?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_knight', description: 'Is the scoped character a knight', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_knight_of', description: 'Is the scoped character a knight of the target character', supportedScopes: ['character'] },
  { name: 'is_landed', description: 'Is the scope character landed (holds a county or barony)?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_landless_ruler', description: 'Is the scope character a landless ruler (holds any title, but no on-map land)?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_leader_in_war', description: 'is the scope character leading one of the sides in the target war?', supportedScopes: ['character'], supportedTargets: ['war'] },
  { name: 'is_leading_faction_type', description: 'Is the character leading a faction of the specified type?', supportedScopes: ['character'] },
  { name: 'is_liege_or_above_of', description: 'is the scope character a liege or above of the target character?', supportedScopes: ['character'] },
  { name: 'is_local_player', description: 'is the character the local player?', supportedScopes: ['character'], valueType: 'boolean', syntax: "An interface trigger, can only be used in specific places" },
  { name: 'is_lowborn', description: 'Is the character a lowborn?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_male', description: 'Is the scope character male?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_married', description: 'Is the scope character married?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_member_of_confederation', description: 'Is the scoped character a member of the target confederation?', supportedScopes: ['character'], supportedTargets: ['confederation'] },
  { name: 'is_migrating', description: 'Is the character currently migrating?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_nibling_of', description: 'Is the character a nibling (niece/nephew) of the target character?', supportedScopes: ['character'] },
  { name: 'is_no_men_enabled', description: 'is the character the player and the no men cheat currently enabled?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_normal_councillor', description: 'Is the scoped character a regular councillor?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_obedient', description: 'Is the scope character obedient?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_obedient_to', description: 'Is the scope character obedient to the target character?', supportedScopes: ['character'] },
  { name: 'is_overriding_designated_winner', description: 'Is the scoped character overriding the winner in the GHW they\'re pledged to (will put their beneficiary on the throne if they\'re top participant)?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_parent_of', description: 'Is the character a parent of the target character?', supportedScopes: ['character'] },
  { name: 'is_participant_in_activity', description: 'is_participant_in_activity = target_activity', supportedScopes: ['character'], supportedTargets: ['activity'], syntax: "Is the scoped character a participant in the target activity" },
  { name: 'is_participant_in_war', description: 'is the scope character participating in the target war as an attacker or defender?', supportedScopes: ['character'], supportedTargets: ['war'] },
  { name: 'is_performing_council_task', description: 'Is the scoped character performing the given task? This will only check for the exact task.', supportedScopes: ['character'], syntax: "character = {\nis_performing_council_task = task_kurultai_fertility_2\n}", parameters: ['character'] },
  { name: 'is_performing_council_task_or_clone', description: 'Is the scoped character performing the given task?', supportedScopes: ['character'], syntax: "This will check for any cloned task as well: the given example will yield yes even if the character is performing task_kurultai_fertility_2.\ncharacter = {\nis_performing_council_task_or_clone = task_kurultai_fertility_1\n}", parameters: ['character'] },
  { name: 'is_planning_great_project', description: 'Checks if the given Character is currently planning a Great Project with the given key. Use the key from the DB to refer to the project.', supportedScopes: ['character'], syntax: "Will fail if the planner or project type are invalid.\nusage:\n<scope:character> = {\nis_planning_great_project = great_project:key\n}" },
  { name: 'is_player_heir_of', description: 'Is the scope character the player heir of the target character?', supportedScopes: ['character'] },
  { name: 'is_player_tutorial_character', description: 'Is player a tutorial character?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_pledged_ghw_attacker', description: 'Is the scoped character a pledged attacker in the current GHW (it\'s an error to check this if there\'s no GHW around)', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_pool_character', description: 'Is the character in the pool? (not a ruler, courtier or guest at any court)', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_pool_guest', description: 'Is the character a guest from the pool? In contrast to is_foreign_court_guest the character has no liege', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_pool_guest_of', description: 'Is the character a guest from the pool, visiting the target character\'s court? In contrast to is_foreign_court_guest_of the character has no liege', supportedScopes: ['character'] },
  { name: 'is_potential_knight', description: 'Is the scoped character a POTENTIAL knight to their liege?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_powerful_vassal', description: 'Is the character a powerful vassal?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_powerful_vassal_of', description: 'Is the character a powerful vassal of the target?', supportedScopes: ['character'] },
  { name: 'is_pregnant', description: 'is the character pregnant?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_primary_heir_of', description: 'Is the character the heir of the target\'s primary title?', supportedScopes: ['character'] },
  { name: 'is_ruler', description: 'Is the scope character a ruler (holds any title)?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_scheming_against', description: 'Checks whether the scope character is an owner or an owner agent in a scheme agains target. There are 3 possible ways to use it:', supportedScopes: ['character'], syntax: "is_scheming_against = { target = X type = Y } limits to schemes of type Y\nis_scheming_against = { target = X scheme_skill = Y } limits to schemes of Y skill category\nis_scheming_against = { target = X } considers all schemes" },
  { name: 'is_sibling_of', description: 'Is the character a sibling of the target character?', supportedScopes: ['character'] },
  { name: 'is_spouse_of', description: 'Is the character a spouse of the target character, and are both alive?', supportedScopes: ['character'] },
  { name: 'is_spouse_of_even_if_dead', description: 'Is the character a spouse of the target character, even if one or both are dead?', supportedScopes: ['character'] },
  { name: 'is_successor_of_accolade', description: 'Is the scoped character the successor of a given Accolade?', supportedScopes: ['character'], supportedTargets: ['accolade'], syntax: "is_successor_of_accolade = accolade" },
  { name: 'is_tax_collector', description: 'Is this scope character a tax collector?', supportedScopes: ['character'], valueType: 'boolean', syntax: "scope:character = { is_tax_collector = yes/no }" },
  { name: 'is_tax_collector_of', description: 'Is the scoped character a tax collector of the target character', supportedScopes: ['character'] },
  { name: 'is_theocratic_lessee', description: 'Is the scope character a theocratic lessee (bishop)?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_travel_entourage_character', description: 'Is the character travelling and part of the entourage? (travel leader is part of the entourage)', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_travel_leader', description: 'Is the character travelling and the active travel leader?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_travelling', description: 'Is the character currently travelling?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_tributary', description: 'Is the scoped character someone else\'s tributary?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_tributary_of', description: 'Is the scoped character a direct tributary of the target character?', supportedScopes: ['character'] },
  { name: 'is_tributary_of_suzerain_or_above', description: 'Is the scoped character a direct or indirect tributary of the target character due to cascading tributaries?', supportedScopes: ['character'] },
  { name: 'is_twin_of', description: 'Is the character a twin of the target character?', supportedScopes: ['character'] },
  { name: 'is_unborn_child_of_concubine', description: 'Is the unborn a child of a concubine?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_unborn_known_bastard', description: 'Is the unborn a known bastard?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_uncle_or_aunt_of', description: 'Is the character an uncle or aunt of the target character?', supportedScopes: ['character'] },
  { name: 'is_valid_agent_standard_trigger', description: 'Is the scoped character a valid scheme agent?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_valid_as_agent_in_any_slot', description: 'Is the scope character suitable as an agent for any slot in target scheme?', supportedScopes: ['character'], supportedTargets: ['scheme'] },
  { name: 'is_valid_as_agent_in_slot', description: 'Is the scope character suitable as an agent for the target agent slot?', supportedScopes: ['character'] },
  { name: 'is_valid_designated_heir', description: 'Is the target character a valid potential designated heir of the scoped character?', supportedScopes: ['character'], syntax: "(can they inherit one or more of the titles the scoped character holds?)\nis_valid_designated_heir = scope:target_character" },
  { name: 'is_valid_for_event_debug', description: 'is the scoped character valid for the given event, without checking event cooldown?', supportedScopes: ['character'], syntax: "NOTE: this is only for debug purposes and will not work in release mode!\nis_valid_for_event_debug = event_key" },
  { name: 'is_valid_for_event_debug_cooldown', description: 'is the scoped character valid for the given event, including a cooldown check?', supportedScopes: ['character'], syntax: "NOTE: this is only for debug purposes and will not work in release mode!\nis_valid_for_event_debug_cooldown = event_key" },
  { name: 'is_valid_successor_for_accolade', description: 'Is the scoped character a valid candidate to take over as successor of this Accolade?', supportedScopes: ['character'], supportedTargets: ['accolade'], syntax: "is_valid_successor_for_accolade = accolade" },
  { name: 'is_valid_to_hire_court_position_type', description: 'Does the scoped character fulfill the requirements for being employed as the targeted court position type?', supportedScopes: ['character'] },
  { name: 'is_vassal_of', description: 'Is the character a direct vassal of the target character?', supportedScopes: ['character'] },
  { name: 'is_vassal_or_below_of', description: 'is the scope character a vassal or below of the target character? Non-rulers are not considered vassals', supportedScopes: ['character'] },
  { name: 'is_visibly_fertile', description: 'Is the scoped character visibly fertile, that is: not too old if a woman, not too young and has no traits blocking having children', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'is_yes_men_enabled', description: 'is the character the player and the yes men cheat currently enabled?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'join_faction_chance', description: 'Check if the chance of the scope character to join the faction against the scripted value', supportedScopes: ['character'], valueType: 'comparison', syntax: "join_faction_chance = {\ntarget = faction_target #An ongoing faction\nvalue <|<=|>=|> 0\n}", parameters: ['target'] },
  { name: 'join_scheme_chance', description: 'Check if the chance of the scope character is between the given range (being min and max exclusive)', supportedScopes: ['character'], syntax: "join_scheme_chance = {\nscheme = scheme_target #An ongoing scheme\nmax = 0\nmin = -10\n}", parameters: ['scheme', 'max', 'min'] },
  { name: 'knows_court_language_of', description: 'Does the character know the court language of the target character?', supportedScopes: ['character'], supportedTargets: ['character'], syntax: "knows_court_language_of = scope:target_character" },
  { name: 'knows_language', description: 'Does the character know the language?', supportedScopes: ['character'], syntax: "knows_language = language_norwegian" },
  { name: 'knows_language_of_culture', description: 'Does the character know the language of the target culture?', supportedScopes: ['character'], supportedTargets: ['culture'], syntax: "knows_language_of_culture = scope:target_culture" },
  { name: 'learning', description: 'does the character have the required learning skill level?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'learning_diff', description: 'does the character have the required learning skill level difference against target?', supportedScopes: ['character'], valueType: 'comparison', syntax: "learning = { target = character value <= script_value abs = yes/no(optional, default no) }", parameters: ['learning'] },
  { name: 'learning_for_portrait', description: 'Learning skill scaled between 0.0 and 1.0 for portraits', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'learning_lifestyle_perk_points', description: 'How many perk points available does the character have?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'learning_lifestyle_perks', description: 'How many perks from this lifestyle does the character have?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'learning_lifestyle_unlockable_perks', description: 'How many perks from this lifestyle can the character currently unlock? This checks that they have the parent perks, and that the can_be_picked is met. It doesn\'t check perk points', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'learning_lifestyle_xp', description: 'How many perk points available does the character have?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'legitimacy', description: 'Gets the scoped character\'s current legitimacy', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'legitimacy_level', description: 'Gets the scoped character\'s current legitimacy level', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'levies_to_liege', description: 'The amount of levies a character sends to their liege', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'long_term_gold', description: 'does the character have the required gold? (AI category \'long term\')', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'long_term_gold_maximum', description: 'How big is the \'long term\' gold budget is supposed to get?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'long_term_treasury', description: 'does the character have the required treasury? (AI category \'long term\')', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'long_term_treasury_maximum', description: 'How big is the \'long term\' treasury budget is supposed to get?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'long_term_treasury_or_gold', description: 'does the character have the required treasury (or gold if they don\'t use treasury)? (AI category \'long term\')', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'lowest_skill', description: 'Is the skill the lowest skill (excluding Prowess) of the character? True even when there are multiple skills with the same lowest value.', supportedScopes: ['character'] },
  { name: 'lowest_skill_including_prowess', description: 'Is the skill the lowest skill (including Prowess) of the character? True even when there are multiple skills with the same lowest value.', supportedScopes: ['character'] },
  { name: 'maa_regiments_count', description: 'Current number of personal MaA regiments', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'maa_regiments_max_count', description: 'Max number of personal MaA regiment', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'main_administrative_tier', description: 'What is the main administrative title tier for ruler\'s government', supportedScopes: ['character'], valueType: 'comparison', syntax: "main_administrative_tier > tier_county" },
  { name: 'mandate_type_qualification', description: 'Diarch qualification for spefic mandate type', supportedScopes: ['character'], valueType: 'comparison', syntax: "value = {\nadd = mandate_type_qualification:fill_coffers\n}\nscope:character = {\nmandate_type_qualification = {\ntarget = fill_coffers\nvalue > 10\n}\n}", parameters: ['add', 'target'] },
  { name: 'martial', description: 'does the character have the required martial skill level?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'martial_diff', description: 'does the character have the required martial skill level difference against target?', supportedScopes: ['character'], valueType: 'comparison', syntax: "martial = { target = character value <= script_value abs = yes/no(optional, default no) }", parameters: ['martial'] },
  { name: 'martial_for_portrait', description: 'Martial skill scaled between 0.0 and 1.0 for portraits', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'martial_lifestyle_perk_points', description: 'How many perk points available does the character have?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'martial_lifestyle_perks', description: 'How many perks from this lifestyle does the character have?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'martial_lifestyle_unlockable_perks', description: 'How many perks from this lifestyle can the character currently unlock? This checks that they have the parent perks, and that the can_be_picked is met. It doesn\'t check perk points', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'martial_lifestyle_xp', description: 'How many perk points available does the character have?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'matrilinear_betrothal', description: 'Is this character\'s betrothal matrilinear? False if there\'s no betrothal.', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'matrilinear_marriage', description: 'Is the marriage with the spouse matrilinear?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'max_active_accolades', description: 'How many active accolades can this character have at most?', supportedScopes: ['character'], valueType: 'comparison', syntax: "max_active_accolades <= 3" },
  { name: 'max_domain_fertility', description: 'Get the max domain fertility of the scoped character', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'max_military_strength', description: 'Is the scoped character\'s max military strength this big?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'max_number_maa_soldiers_of_base_type', description: 'Does the scope character have value amount of max soldiers of MaA of the base type?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'max_number_maa_soldiers_of_type', description: 'Does the scope character have value amount of max soldiers of MaA of the type?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'max_number_of_concubines', description: 'The maximum number of concubines a character can have', supportedScopes: ['character'], valueType: 'comparison', syntax: "max_number_of_concubines > 2" },
  { name: 'max_number_of_knights', description: 'Check how many knights the scoped character can potentially have', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'merit', description: 'does the character have the required merit?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'merit_level', description: 'does the character have the required merit level?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'military_power', description: 'Is the scoped character\'s military power this big?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'min_appointment_tier', description: 'What is the minimum tier that allows appointment investment for ruler\'s government', supportedScopes: ['character'], valueType: 'comparison', syntax: "min_appointment_tier > tier_county" },
  { name: 'min_title_maa_tier', description: 'What is the minimum title tier to be able to have Title MaA?', supportedScopes: ['character'], valueType: 'comparison', syntax: "min_title_maa_tier > tier_county" },
  { name: 'monthly_character_balance', description: 'Is the scoped character\'s monthly gold balance this big?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'monthly_character_expenses', description: 'Is the scoped character\'s monthly expenses this big?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'monthly_character_income', description: 'Is the scoped character\'s monthly income this big?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'monthly_character_income_long_term', description: 'did the character allocate the required gold? (AI category long term)', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'monthly_character_income_reserved', description: 'did the character allocate the required gold? (AI category reserved)', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'monthly_character_income_short_term', description: 'did the character allocate the required gold? (AI category short term)', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'monthly_character_income_war_chest', description: 'did the character allocate the required gold? (AI category war chest)', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'monthly_character_men_at_arms_expense_gold', description: 'Is the scoped character\'s monthly military gold expenses this big? (unraised maa costs)', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'monthly_character_men_at_arms_expense_prestige', description: 'Is the scoped character\'s monthly military prestige expenses this big? (unraised maa costs)', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'monthly_character_men_at_arms_expense_treasury', description: 'Is the scoped character\'s monthly military treasury expenses this big? (unraised maa costs)', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'monthly_character_treasury_balance', description: 'Is the scoped character\'s monthly treasury balance this big?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'monthly_character_treasury_income', description: 'Is the scoped character\'s monthly treasury income this big?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'monthly_character_treasury_income_long_term', description: 'did the character allocate the required treasury? (AI category long term)', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'monthly_character_treasury_income_reserved', description: 'did the character allocate the required treasury? (AI category reserved)', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'monthly_character_treasury_income_short_term', description: 'did the character allocate the required treasury? (AI category short term)', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'monthly_character_treasury_income_war_chest', description: 'did the character allocate the required treasury? (AI category war chest)', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'monthly_character_treasury_variable_income', description: 'Is the scoped character\'s monthly treasury income (minus Vassal Development expenses) this big?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'months_as_ruler', description: 'Number of months this character has been a ruler, returns -1 if character isn\'t a ruler', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'morph_gene_attribute', description: 'Compare entity attribute from specific gene', supportedScopes: ['character'], valueType: 'comparison', syntax: "Example scope:character = {\nmorph_gene_attribute = {\ncategory = gene_height\nattribute = body_height\nvalue < 0.05\n}\n}\nAn interface trigger, can only be used in specific places", parameters: ['category', 'attribute'] },
  { name: 'morph_gene_value', description: 'Compare value of specific gene. Does NOT take into account trait modifiers', supportedScopes: ['character'], valueType: 'comparison', syntax: "scope:character = {\nmorph_gene_attribute = {\ncategory = gene_height\nvalue < 0.05\n}\n}\nscope:character = {\nmorph_gene_value:gene_baldness > 0.05\n0.05 < morph_gene_value:gene_baldness\n}\nAn interface trigger, can only be used in specific places", parameters: ['morph_gene_attribute', 'category'] },
  { name: 'num_active_accolades', description: 'How many active accolades does this character currently have?', supportedScopes: ['character'], valueType: 'comparison', syntax: "num_active_accolades < 4" },
  { name: 'num_inactive_accolades', description: 'How many inactive accolades does this character currently have?', supportedScopes: ['character'], valueType: 'comparison', syntax: "num_inactive_accolades > 0" },
  { name: 'num_of_bad_genetic_traits', description: 'Compare the number of bad genetic traits', supportedScopes: ['character'], valueType: 'comparison', syntax: "<charater> = { num_of_bad_genetic_traits = 0 }" },
  { name: 'num_of_good_genetic_traits', description: 'Compare the number of good genetic traits', supportedScopes: ['character'], valueType: 'comparison', syntax: "<charater> = { num_of_good_genetic_traits >= 2 }" },
  { name: 'num_of_known_languages', description: 'How many languages does the character know?', supportedScopes: ['character'], valueType: 'comparison', syntax: "num_of_known_languages > 1" },
  { name: 'num_of_relation_activity_recurrer', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'num_of_relation_antiquarian', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'num_of_relation_best_friend', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'num_of_relation_blood_brother', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'num_of_relation_bully', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'num_of_relation_court_physician', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'num_of_relation_crush', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'num_of_relation_disciple', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'num_of_relation_elder', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'num_of_relation_event_recurrer', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'num_of_relation_favorite_child', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'num_of_relation_fellow_disciple', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'num_of_relation_friend', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'num_of_relation_grudge', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'num_of_relation_guardian', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'num_of_relation_intrigue_mentor', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'num_of_relation_intrigue_student', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'num_of_relation_lover', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'num_of_relation_mentor', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'num_of_relation_nemesis', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'num_of_relation_nursed_child', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'num_of_relation_oaf', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'num_of_relation_old_flame', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'num_of_relation_potential_friend', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'num_of_relation_potential_hook', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'num_of_relation_potential_lover', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'num_of_relation_potential_rival', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'num_of_relation_rival', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'num_of_relation_soldier_friend', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'num_of_relation_soulmate', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'num_of_relation_student', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'num_of_relation_victim', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'num_of_relation_ward', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'num_of_relation_wedding_bad_fertility', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'num_of_relation_wedding_good_fertility', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'num_of_relation_wedding_very_bad_fertility', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'num_of_relation_wedding_very_good_fertility', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'num_of_relation_wet_nurse', description: 'Compares the number of scripted relations a character has of the type', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'num_offered_task_contracts', description: 'Count of active task contract offered', supportedScopes: ['character'], valueType: 'comparison', syntax: "scope:actor = { num_offered_task_contracts > 0 }" },
  { name: 'num_personal_legend_seeds', description: 'How many personal legend seeds are available to this character?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'num_scripted_legend_seeds', description: 'How many scripted legend seeds are available to this character? They do not need to be valid to start', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'num_sinful_traits', description: 'Does the scoped character have this number of sinful traits?', supportedScopes: ['character'], valueType: 'comparison', syntax: "num_sinful_traits > 5\nor to base it on what a specific faith considers sinful\nnum_sinful_traits = {\nvalue > 5\ntarget = scope:faith\n}", parameters: ['target'] },
  { name: 'num_taken_task_contracts', description: 'Amount of taken task contracts for character (accepted & not yet completed)', supportedScopes: ['character'], valueType: 'comparison', syntax: "scope:actor = { num_taken_task_contracts > 0 }" },
  { name: 'num_task_contracts', description: 'Amount of tas contracts for character', supportedScopes: ['character'], valueType: 'comparison', syntax: "scope:actor = { num_task_contracts > 0 }" },
  { name: 'num_triggered_legend_seeds', description: 'How many scripted legend seeds are available to this character and valid to start?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'num_virtuous_traits', description: 'Does the scoped character have this number of virtous traits?', supportedScopes: ['character'], valueType: 'comparison', syntax: "num_virtous_traits > 5\nor to base it on what a specific faith considers virtuous\nnum_virtous_traits = {\nvalue > 5\ntarget = scope:faith\n}", parameters: ['num_virtous_traits', 'target'] },
  { name: 'number_maa_regiments_of_base_type', description: 'Does the scope character have value amount of MaA of the base type?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'number_maa_regiments_of_type', description: 'Does the scope character have value amount of MaA of the type?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'number_maa_soldiers_of_base_type', description: 'Does the scope character have value amount of soldiers of MaA of the base type?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'number_maa_soldiers_of_type', description: 'Does the scope character have value amount of soldiers of MaA of the type?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'number_of_commander_traits', description: 'does the character have this many commander traits?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'number_of_commander_traits_in_common', description: 'does the character and the target have a number of commander traits in common?', supportedScopes: ['character'], syntax: "number_of_personality_traits_in_common = { target = X value >/</>=/<= Y }", parameters: ['number_of_personality_traits_in_common'] },
  { name: 'number_of_concubines', description: 'The number of concubines the scoped character has', supportedScopes: ['character'], valueType: 'comparison', syntax: "number_of_concubines > 2" },
  { name: 'number_of_desired_concubines', description: 'The number of fertile concubines the scoped character should have to not get penalties', supportedScopes: ['character'], valueType: 'comparison', syntax: "number_of_desired_concubines > 2" },
  { name: 'number_of_election_votes', description: 'Check the number of votes the scoped character has in the target title', supportedScopes: ['character'], valueType: 'comparison', syntax: "number_of_election_votes = { title = scope:actor.primary_title value = 0 }" },
  { name: 'number_of_fertile_concubines', description: 'The number of visibly fertile concubines the scoped character has', supportedScopes: ['character'], valueType: 'comparison', syntax: "number_of_fertile_concubines > 2" },
  { name: 'number_of_knights', description: 'Check how many knights the scoped character has at the moment', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'number_of_lifestyle_traits', description: 'does the character have this many lifestyle traits?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'number_of_maa_regiments', description: 'The number of men at arms the scoped character has', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'number_of_opposing_personality_traits', description: 'does the character and the target have a number of opposing personality traits?', supportedScopes: ['character'], syntax: "number_of_opposing_personality_traits = { target = X value >/</>=/<= Y }" },
  { name: 'number_of_opposing_traits', description: 'does the character and the target have a number of opposing traits?', supportedScopes: ['character'], syntax: "number_of_opposing_traits = { target = X value >/</>=/<= Y }" },
  { name: 'number_of_personality_traits', description: 'does the character have this many personality traits?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'number_of_personality_traits_in_common', description: 'does the character and the target have a number of personality traits in common?', supportedScopes: ['character'], syntax: "number_of_personality_traits_in_common = { target = X value >/</>=/<= Y }" },
  { name: 'number_of_powerful_vassals', description: 'Does the character have a specified number of powerful vassals?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'number_of_sinful_traits_in_common', description: 'do the two characters share a number of traits that is considered sinful by both of their respective faiths?', supportedScopes: ['character'], valueType: 'comparison', syntax: "number_of_sinful_traits_in_common = { target = X value >/</>=/<= Y }" },
  { name: 'number_of_stationed_maa_regiments', description: 'The number of stationed men at arms the scoped character has', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'number_of_traits', description: 'does the character have this many traits?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'number_of_traits_in_common', description: 'does the character and the target have a number of traits in common?', supportedScopes: ['character'], syntax: "number_of_traits_in_common = { target = X value >/</>=/<= Y }" },
  { name: 'number_of_tributaries', description: 'The number of tributaries the scoped character has', supportedScopes: ['character'], valueType: 'comparison', syntax: "number_of_tributaries > 2" },
  { name: 'number_of_virtue_traits_in_common', description: 'do the two characters share a number of traits that is considered virtuous by both of their respective faiths?', supportedScopes: ['character'], valueType: 'comparison', syntax: "number_of_virtue_traits_in_common = { target = X value >/</>=/<= Y }" },
  { name: 'number_title_maa_regiments_of_type', description: 'Does the scope character have value amount of MaA of the type for their controlled title troops?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'opinion', description: 'is the character\'s opinion of the target greater or equal than the value? opinion = { target = X [*value >/</>=/<= Y* or *value = { min max }*  }', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'owns_a_story', description: 'checks whether the scope character is the owner of any currently active story', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'owns_story_of_type', description: 'Does the character own a story of this type?', supportedScopes: ['character'] },
  { name: 'parent_relatedness', description: 'The percentage of shared DNA between the character\'s parents.', supportedScopes: ['character'], valueType: 'comparison', syntax: "Traverses the family tree for NDefines::NChildbirth::INBREEDING_ANCESTOR_GENERATIONS amount of generations to find common ancestors. By default this means that we're traversing 4 generations (62 ancestors) and report the relatedness between the two parents. (See https://relatednesscalculator.nolanlawson.com/ for some examples).\n`relatedness > 0.25` where 0.0 means not related at all and 1.0 means identical twins" },
  { name: 'participated_wars', description: 'Checks how many wars the character has been in during their lifetime. (Only for alive characters): scope:character = { participated_wars > 3 }', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'patrilinear_betrothal', description: 'Is this character\'s betrothal patrilinear? False if there\'s no betrothal.', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'patrilinear_marriage', description: 'Is the marriage with the spouse patrilinear?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'perk_points', description: 'Does the character have this many perk points across all lifestyles combined?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'perk_points_assigned', description: 'Does the character have this many perk points assigned across all lifestyles combined?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'perks_in_tree', description: 'Does the character have this many perk points assigned to this tree? perks_in_tree = { tree = tree_key value > 5 }', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'piety', description: 'does the character have the required piety?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'piety_level', description: 'does the character have the required piety level?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'player_heir_position', description: 'Check where the target character is in the scoped character\'s player heir list.', supportedScopes: ['character'], valueType: 'comparison', syntax: "player_heir_position = { target = scope:actor position = 0 }" },
  { name: 'pregnancy_days', description: 'How long has the character been pregnant? Counts from impregnation, not reveal', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'prestige', description: 'does the character have the required prestige?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'prestige_level', description: 'does the character have the required prestige level?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'provision_cost_to_domicile', description: 'What is the provision cost between the domicile owner and the domicile\'s current location."', supportedScopes: ['character'], valueType: 'comparison', syntax: "In order to calculate the cost we will operate in three stages:\n1. Check if the from and to provinces are direct neighbours.\n2. Check any travel plan the domicile owner might have and see if the from and\nto are part of the travel plan. This will require domicile's location to be\nthe first entry in the travel plan.\n3. Do a pathfind between the domicile and domicile owner's current location,\nusing that path for the cost.\nscope:character = {\nprovision_cost_to_domicile > 100\n}" },
  { name: 'prowess', description: 'does the character have the required prowess skill level?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'prowess_diff', description: 'does the character have the required prowess skill level difference against target?', supportedScopes: ['character'], valueType: 'comparison', syntax: "prowess = { target = character value <= script_value abs = yes/no(optional, default no) }", parameters: ['prowess'] },
  { name: 'prowess_for_portrait', description: 'Prowess skill scaled between 0.0 and 1.0 for portraits', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'prowess_no_portrait', description: 'does the character have the required prowess skill level (ignores the prowess_no_portrait modifier)?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'ransom_cost', description: 'what is the ransom cost of the character?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'realm_law_group_at_maximum_level', description: 'Does the scoped character have the maximum level of the realm law group given?', supportedScopes: ['character'] },
  { name: 'realm_law_group_at_minimum_level', description: 'Does the scoped character have the minimum level of the realm law group given?', supportedScopes: ['character'] },
  { name: 'realm_size', description: 'Is the scoped character\'s top liege\'s realm this big (# of counties)?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'realm_to_title_distance_squared', description: 'Is the character\'s realm within this distance of the title? Distance is in pixels, squared for performance reasons. realm_to_title_distance_squared = { target = some_title value > 10000 }', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'reserved_gold', description: 'does the character have the required gold? (AI category \'reserved\')', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'reserved_gold_maximum', description: 'How big is the \'reserved\' gold budget is supposed to get?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'reserved_treasury', description: 'does the character have the required treasury? (AI category \'reserved\')', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'reserved_treasury_maximum', description: 'How big is the \'reserved\' treasury budget is supposed to get?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'reserved_treasury_or_gold', description: 'does the character have the required treasury (or gold if they don\'t use treasury)? (AI category \'reserved\')', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'reverse_has_opinion_modifier', description: 'does the target have the specified opinion modifier on the character? (optional *value <|<=|=|>=|> X* or *value = { MIN MAX }* inclusive)', supportedScopes: ['character'] },
  { name: 'reverse_opinion', description: 'is the target character\'s opinion of the scope character greater or equal than the value? opinion = { target = X [*value >/</>=/<= Y* or *value = { min max }*  }', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'scriptedtests_can_marry_character', description: 'can the character marry the target character?', supportedScopes: ['character'] },
  { name: 'scriptedtests_dread_base', description: 'does the character have the specified dread baseline value?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'scriptedtests_gold_income_no_theocracy', description: 'does the character have the specified tax income, excluding income from the theocratic lessee?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'scriptedtests_piety_income', description: 'does the character have the specified piety income?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'sex_opposite_of', description: 'Are the scope character the target character of the opposite sex?', supportedScopes: ['character'] },
  { name: 'sex_same_as', description: 'Are the scope character the target character of the same sex?', supportedScopes: ['character'] },
  { name: 'short_term_gold', description: 'does the character have the required gold? (AI category \'short term\')', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'short_term_gold_maximum', description: 'How big is the \'short term\' gold budget is supposed to get?(It may exceed this if all other budgets are full)', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'short_term_treasury', description: 'does the character have the required treasury? (AI category \'short term\')', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'short_term_treasury_maximum', description: 'How big is the \'short term\' treasury budget is supposed to get?(It may exceed this if all other budgets are full)', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'short_term_treasury_or_gold', description: 'does the character have the required treasury (or gold if they don\'t use treasury)? (AI category \'short term\')', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'should_decision_create_alert', description: 'Is the scoped decision an important decision for the target character?', supportedScopes: ['character'], supportedTargets: ['decision'] },
  { name: 'should_notify_can_host_activity', description: 'should_notify_can_host_activity = target_activity', supportedScopes: ['character'], supportedTargets: ['activity_type'], syntax: "Should the scoped character be alerted that they can host the target activity type" },
  { name: 'should_notify_can_join_activity', description: 'should_notify_can_join_activity = target_activity', supportedScopes: ['character'], supportedTargets: ['activity_type'], syntax: "Should the scoped character be alerted that they can join the target activity type" },
  { name: 'starting_gold_by_income', description: 'Calculate starting gold based on income.', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'static_group_filter', description: 'Check if this character \'matches\' a group, with a certain match percentage.', supportedScopes: ['character'], syntax: "A match value can range from 0.0 to 1.0. (0% to 100%)\nA static group filter means: this character will always get the same result against the same group. (there is no 'random' involved beyond the name of the group)\nOn average (across all characters), an 0.1 match means you would get 'yes' for 10% of the characters to match this group, and it would always be the same characters for the same group.\nstatic_group_filter = {\ngroup = <a_group_id>\nmatch = 0.1\n}\nInstead of a group id, you can supply a scope, and it will use that scope's value as the group 'id'.\nstatic_group_filter = {\nscope = <any_scope>\nmatch = 0.1\n}", parameters: ['group', 'match'] },
  { name: 'stewardship', description: 'does the character have the required stewardship skill level?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'stewardship_diff', description: 'does the character have the required stewardship skill level difference against target?', supportedScopes: ['character'], valueType: 'comparison', syntax: "stewardship = { target = character value <= script_value abs = yes/no(optional, default no) }", parameters: ['stewardship'] },
  { name: 'stewardship_for_portrait', description: 'Stewardship skill scaled between 0.0 and 1.0 for portraits', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'stewardship_lifestyle_perk_points', description: 'How many perk points available does the character have?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'stewardship_lifestyle_perks', description: 'How many perks from this lifestyle does the character have?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'stewardship_lifestyle_unlockable_perks', description: 'How many perks from this lifestyle can the character currently unlock? This checks that they have the parent perks, and that the can_be_picked is met. It doesn\'t check perk points', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'stewardship_lifestyle_xp', description: 'How many perk points available does the character have?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'stress', description: 'does the character have the required stress?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'stress_level', description: 'does the character have the required stress level?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'strife_opinion', description: 'Strife opinion value accumulated by the character', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'sub_realm_size', description: 'Is the scoped character\'s sub-realm this big (# of counties)?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'subject_can_break_tributary', description: 'Can the scoped character break the tributary it is currently a subject in?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'subject_contract_has_flag', description: 'Do any of the current active obligations in the scoped character\'s subject contract have the given flag', supportedScopes: ['character'] },
  { name: 'subject_contract_has_modifiable_obligations', description: 'Can the scoped character\'s subject contract be modified at all, that is: they have one, they use obligation levels, and are count or above', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'subject_contract_is_blocked_from_modification', description: 'Has the scoped character\'s contract been blocked from modification by script via \'set_subject_contract_modification_blocked\'', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'subject_contract_obligation_level_can_be_decreased', description: 'Can the obligation level of the scoped character\'s named subject contract be decreased?', supportedScopes: ['character'] },
  { name: 'subject_contract_obligation_level_can_be_increased', description: 'Can the obligation level of the scoped character\'s named subject contract be increased?', supportedScopes: ['character'] },
  { name: 'subject_standing', description: 'Compares the subject standing a character\'s subject contract has accumulated', supportedScopes: ['character'], valueType: 'comparison', syntax: "subject_standing >= 50" },
  { name: 'succession_appointment_score_invested', description: 'How much has the scoped character invested in the target title towards the target candidate?', supportedScopes: ['character'], valueType: 'comparison', syntax: "scope:character = {\nsuccession_appointment_score_invested = {\ntitle = scope:title\ncandidate = scope:character\nvalue < 0\n}\n}", parameters: ['title', 'candidate'] },
  { name: 'target_is_liege_or_above', description: 'is the target character the liege or above the scope character?', supportedScopes: ['character'] },
  { name: 'target_is_same_character_or_above', description: 'is the target character the the same character or above (in the vassal hierarchy) the scope character?', supportedScopes: ['character'] },
  { name: 'target_is_vassal_or_below', description: 'is the target character a vassal or below of the scope character? Non-rulers are not considered vassals', supportedScopes: ['character'] },
  { name: 'target_weight', description: 'Target weight of the scoped character', supportedScopes: ['character'], valueType: 'comparison', syntax: "target_weight > 10" },
  { name: 'tax_collector_aptitude', description: 'What is the scoped character\'s Tax Collector aptitude in the target tax slot type? tax_collector_aptitude = { target = tax_slot_type value >= 1 }', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'tax_to_liege', description: 'The amount of tax a character sends to their liege', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'tier_difference', description: 'What is the difference in highest_held_title_tier between the scoped character and the target character (-5 to 5)', supportedScopes: ['character'], valueType: 'comparison', syntax: "For example, this is true:\nscope:a_baron = {\ntier_difference = {\ntarget = scope:a_king\nvalue = -3\n}\n}", parameters: ['target'] },
  { name: 'time_after_diarch_designated', description: 'How much time passed after diarch was designated?', supportedScopes: ['character'], syntax: "time_after_designated_diarch = { days/months/years =,>,< X }", parameters: ['time_after_designated_diarch', 'days', 'months', 'years'] },
  { name: 'time_in_prison', description: 'for how long has the character been imprisoned? time_in_prison = { days/months/years =,>,< X }', supportedScopes: ['character'] },
  { name: 'time_in_prison_type', description: 'for how long has the character been imprisoned with the current type? time_in_prison_type = { days/months/years =,>,< X }', supportedScopes: ['character'] },
  { name: 'time_since_death', description: 'for how long has the character is dead? time_since_death  = { days/months/years =,>,< X }', supportedScopes: ['character'] },
  { name: 'time_to_hook_expiry', description: 'The # of days until the scoped character\'s hook on the target expires', supportedScopes: ['character'], valueType: 'comparison', syntax: "time_to_hook_expiry = { target = someone value > 50 }" },
  { name: 'trait_compatibility', description: 'target = other character value >/</= sum of trait compatibility values', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'travel_leader_cost', description: 'What this character would cost as a travel leader', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'travel_leader_safety', description: 'The safety-aptitude of the current travel leader', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'travel_leader_speed', description: 'The speed-aptitude of the current travel leader', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'treasury', description: 'does the character have the required treasury?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'treasury_budget_allocation_excess', description: 'Was the scoped character\'s current budget allocation excess this big? Negative values indicate deficit allocation, positive values indicate unallocated budget.', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'treasury_budget_allocation_military', description: 'Was the scoped character\'s current military budget allocation this big? (value 0.0 - 1.0)', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'treasury_budget_allocation_ministries', description: 'Was the scoped character\'s current ministry budget allocation this big? (value 0.0 - 1.0)', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'treasury_budget_allocation_salaries', description: 'Was the scoped character\'s current salary budget allocation this big? (value 0.0 - 1.0)', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'treasury_budget_base_rate_military', description: 'Is the scoped character\'s military budget base rate this big?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'treasury_budget_base_rate_ministries', description: 'Is the scoped character\'s ministry budget base rate this big?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'treasury_budget_base_rate_salaries', description: 'Is the scoped character\'s salary budget base rate this big?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'treasury_budget_enact_date', description: 'Date when the current budget was enacted', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'treasury_days_since_budget_enact_date', description: 'Number of days since the current budget was enacted.', supportedScopes: ['character'], valueType: 'comparison', syntax: "treasury_days_since_budget_enact_date >= 20" },
  { name: 'treasury_debt_level', description: 'Is the scoped character\'s treasury debt level this value? -1 if not meeting any debt level threshold for treasury.', supportedScopes: ['character'], valueType: 'comparison', syntax: "0 for the first one, and so on.\nNote that this might not match exactly with the modifier in effect as it calculates what the modifier will be now, and the character's actual modifier can lag behind" },
  { name: 'treasury_months_since_budget_enact_date', description: 'Number of months since the current budget was enacted.', supportedScopes: ['character'], valueType: 'comparison', syntax: "treasury_months_since_budget_enact_date >= 20" },
  { name: 'treasury_or_gold', description: 'Does the character replace gold cost by treasury? Compare value against treasury, otherwise gold.', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'treasury_years_since_budget_enact_date', description: 'Number of years since the current budget was enacted.', supportedScopes: ['character'], valueType: 'comparison', syntax: "treasury_years_since_budget_enact_date >= 20" },
  { name: 'tributary_contract_obligation_level_can_be_decreased', description: 'Can the obligation level of the scoped character\'s named tributary contract be decreased?', supportedScopes: ['character'] },
  { name: 'tributary_contract_obligation_level_can_be_increased', description: 'Can the obligation level of the scoped character\'s named tributary contract be increased?', supportedScopes: ['character'] },
  { name: 'tyranny', description: 'does the character have the required tyranny?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'vassal_contract_has_flag', description: 'Do any of the current active obligations in the scoped character\'s vassal contract have the given flag', supportedScopes: ['character'] },
  { name: 'vassal_contract_has_modifiable_obligations', description: 'Can the scoped character\'s vassal contract be modified at all, that is: they have one, they use obligation levels, and are count or above', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'vassal_contract_liege_dynasty_reign_start_date', description: 'Date when this vassal\'s liege\'s dynasty started ruling over this vassal', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'vassal_contract_obligation_level', description: 'The level of the provided contract type in the scoped character\'s current vassal contract', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'vassal_contract_obligation_level_can_be_decreased', description: 'Can the obligation level of the scoped character\'s named vassal contract be decreased?', supportedScopes: ['character'] },
  { name: 'vassal_contract_obligation_level_can_be_increased', description: 'Can the obligation level of the scoped character\'s named vassal contract be increased?', supportedScopes: ['character'] },
  { name: 'vassal_contract_obligation_level_score', description: 'The score in favour of the vassal for the provided contract type in the scoped character\'s current vassal contract', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'vassal_count', description: 'Is the scoped character\'s number of vassals (excluding barons) this high?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'vassal_limit', description: 'Is the scoped character\'s vassal limit this big?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'vassal_limit_available', description: 'Is there this much space left in the character\'s vassal limit? Negative values also work for checking characters that are above their limit', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'vassal_limit_percentage', description: 'Is the scoped character\'s vassal count this big in comparison to their limit?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'wanderer_lifestyle_perk_points', description: 'How many perk points available does the character have?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'wanderer_lifestyle_perks', description: 'How many perks from this lifestyle does the character have?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'wanderer_lifestyle_unlockable_perks', description: 'How many perks from this lifestyle can the character currently unlock? This checks that they have the parent perks, and that the can_be_picked is met. It doesn\'t check perk points', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'wanderer_lifestyle_xp', description: 'How many perk points available does the character have?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'war_chest_gold', description: 'does the character have the required gold? (AI category \'war chest\')', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'war_chest_gold_maximum', description: 'How big is the \'war chest\' gold budget is supposed to get?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'war_chest_treasury', description: 'does the character have the required treasury? (AI category \'war chest\')', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'war_chest_treasury_maximum', description: 'How big is the \'war chest\' treasury budget is supposed to get?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'war_chest_treasury_or_gold', description: 'does the character have the required treasury (or gold if they don\'t use treasury)? (AI category \'war chest\')', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'was_hostage_child', description: 'Was the scoped character a Hostage as a Child?', supportedScopes: ['character'], valueType: 'boolean' },
  { name: 'would_be_valid_for_court_position', description: 'can the scoped character be employed as court position by the employer?', supportedScopes: ['character'], syntax: "scope:character = {\nwould_be_valid_for_court_position = {\nemployer = scope:employer\ncourt_position = court_physician_court_position\n}\n}", parameters: ['employer', 'court_position'] },
  { name: 'year_character_treasury_income', description: 'Is the scoped character\'s yearly treasury income this big?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'year_character_treasury_variable_income', description: 'Is the scoped character\'s yearly treasury income (minus Vassal Development expenses) this big?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'year_of_birth', description: 'Get character year_of_birth: scope:character = { year_of_birth > 1096 }', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'yearly_character_balance', description: 'Is the scoped character\'s yearly gold balance this big?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'yearly_character_expenses', description: 'Is the scoped character\'s yearly expenses this big?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'yearly_character_income', description: 'Is the scoped character\'s yearly income this big?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'yearly_character_men_at_arms_expense_gold', description: 'Is the scoped character\'s yearly military gold expenses this big? (unraised maa costs)', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'yearly_character_men_at_arms_expense_prestige', description: 'Is the scoped character\'s yearly military prestige expenses this big? (unraised maa costs)', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'yearly_character_men_at_arms_expense_treasury', description: 'Is the scoped character\'s yearly military treasury expenses this big? (unraised maa costs)', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'yearly_character_treasury_balance', description: 'Is the scoped character\'s yearly treasury balance this big?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'years_as_diarch', description: 'How many whole years has the character been an active diarch?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'years_as_ruler', description: 'Number of years this character has been a ruler, returns -1 if character isn\'t a ruler', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'years_in_diarchy', description: 'How many whole years has liege spent in a diarchy?', supportedScopes: ['character'], valueType: 'comparison' },
  { name: 'yields_alliance', description: 'Checks if the character would get an alliance with the target character through such a marriage.', supportedScopes: ['character'] },
  { name: 'any_killed_character', description: 'Iterate through all kills of a character', supportedScopes: ['character', 'artifact'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_killed_character = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
];

/**
 * Triggers for landed_title scope (122 triggers)
 */
export const landedtitleTriggers: TriggerDefinition[] = [
  { name: 'active_de_jure_drift_progress', description: 'task_current_value = scope:county.active_de_jure_drift_progress', supportedScopes: ['landed_title'], valueType: 'comparison' },
  { name: 'any_claimant', description: 'Iterate through all claimants to title. parameters: explicit = yes/no/all - default yes', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_claimant = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_connected_county', description: 'Iterate through all counties connected to this one. Is based on top liege', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any/every/whatever_connectec_county = {\nmax_naval_distance = 500\nallow_one_county_land_gap = yes\nany_connected_county = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['max_naval_distance', 'allow_one_county_land_gap', 'any', 'every', 'whatever_connectec_county', 'count', 'percent'] },
  { name: 'any_controlled_faith', description: 'Iterate through all faiths headed by a title', supportedScopes: ['landed_title'], supportedTargets: ['faith'], outputScope: 'faith', isIterator: true, valueType: 'block', syntax: "any_controlled_faith = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_controlled_title_maa_regiment', description: 'Iterate through controlled title regiments', supportedScopes: ['landed_title'], supportedTargets: ['regiment'], outputScope: 'regiment', isIterator: true, valueType: 'block', syntax: "any_controlled_title_maa_regiment = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_county_province', description: 'Iterate through all provinces in a county', supportedScopes: ['landed_title'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, valueType: 'block', syntax: "any_county_province = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_county_province_epidemic', description: 'Iterate through all epidemics affecting the provinces in a county', supportedScopes: ['landed_title'], supportedTargets: ['epidemic'], outputScope: 'epidemic', isIterator: true, valueType: 'block', syntax: "Optionally specify an outbreak intensity filter\nany_county_province_epidemic = { intensity = apocalyptic }\nany_county_province_epidemic = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_county_situation', description: 'Iterate through all situations that a county is involved in.', supportedScopes: ['landed_title'], supportedTargets: ['situation'], outputScope: 'situation', isIterator: true, valueType: 'block', syntax: "any_county_situation = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_county_situation_sub_region', description: 'Iterate through all situation sub-regions that a county is involved in.', supportedScopes: ['landed_title'], supportedTargets: ['situation_sub_region'], outputScope: 'situation_sub_region', isIterator: true, valueType: 'block', syntax: "any_county_situation_sub_region = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_county_struggle', description: 'Iterate through all struggles that a county is involved in.', supportedScopes: ['landed_title'], supportedTargets: ['struggle'], outputScope: 'struggle', isIterator: true, valueType: 'block', syntax: "any_county_struggle = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_de_jure_county', description: 'Iterate through all counties within this dejure title', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_de_jure_county = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_de_jure_county_holder', description: 'Iterate through all characters directly holding counties within this dejure title', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_de_jure_county_holder = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_de_jure_top_liege', description: 'Iterate through all top lieges of the counts within this dejure title', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_de_jure_top_liege = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_dejure_vassal_title_holder', description: 'Iterate through all the vassal holders of the title', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_dejure_vassal_title_holder = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_direct_de_facto_vassal_title', description: 'Iterate through all de facto vassal titles', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_direct_de_facto_vassal_title = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_direct_de_jure_vassal_title', description: 'Iterate through the all de jure vassals titles', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_direct_de_jure_vassal_title = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_election_candidate', description: 'Iterate through all characters who are valid candidates in an election for a title', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_election_candidate = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_elector', description: 'Iterate through all characters who are valid electors in an election for a title', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_elector = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_important_location_for_title', description: 'Iterate through all counties that are important for the scoped title', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_important_location_for_title = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_in_de_facto_hierarchy', description: 'Iterate through the title itself, all de facto vassals, and below. The continue trigger specifies whether to recursively iterate through the vassal\'s vassal', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "This is unrelated to the limit; if the limit is met it is added to the list, but its vassals will get checked even if the limit isn't met as long as the 'continue' trigger is\n..._de_jure_vassal_and_below = { continue = { conditions } }\nany_in_de_facto_hierarchy = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_in_de_jure_hierarchy', description: 'Iterate through the title itself, all de jure vassals, and below. The continue trigger specifies whether to recursively iterate through the vassal\'s vassal', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "This is unrelated to the limit; if the limit is met it is added to the list, but its vassals will get checked even if the limit isn't met as long as the 'continue' trigger is\n..._de_jure_vassal_and_below = { continue = { conditions } }\nany_in_de_jure_hierarchy = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_neighboring_county', description: 'Iterate through all neighboring counties. Can only be used in county scope', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_neighboring_county = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_owned_title_maa_regiment', description: 'Iterate through owned title MaA regiments', supportedScopes: ['landed_title'], supportedTargets: ['regiment'], outputScope: 'regiment', isIterator: true, valueType: 'block', syntax: "any_owned_title_maa_regiment = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_past_holder', description: 'Iterate through all past owners of a title from earliest to latest', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_past_holder = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_past_holder_reversed', description: 'Iterate through all past owners of a title from latest to earliest', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_past_holder_reversed = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_succession_appointment_investors', description: 'Iterate through all investors of target candidate within the scoped title. Optionally specify a value to filter by investment amount', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "scope:landed_title = {\nany/every/ordered/random_succession_appointment_investors = {\ncandidate = scope:character\nvalue > {\t\t\t# Optional compare value to\nvalue = 100\t\t# only have characters that\nadd = 10\t\t# have invested this much.\n}\n}\n}\nany_succession_appointment_investors = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['candidate', 'add', 'any', 'every', 'ordered', 'random_succession_appointment_investors', 'count', 'percent'] },
  { name: 'any_this_title_or_de_jure_above', description: 'Iterate through this title and all its dejure liege titles', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_this_title_or_de_jure_above = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_title_heir', description: 'Line of succession for the scoped title', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_title_heir = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_title_interested_in_location', description: 'Iterate through titles that consider scoped county an important location', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_title_interested_in_location = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_title_joined_faction', description: 'Iterate through all factions joined the scope landed title', supportedScopes: ['landed_title'], supportedTargets: ['faction'], outputScope: 'faction', isIterator: true, valueType: 'block', syntax: "any_title_joined_faction = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_title_maa_regiment', description: 'Iterate through title all MaA regiments', supportedScopes: ['landed_title'], supportedTargets: ['regiment'], outputScope: 'regiment', isIterator: true, valueType: 'block', syntax: "any_title_maa_regiment = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_title_to_title_neighboring_and_across_water_county', description: 'Scopes from a title to a neighboring county (incl. across water, looking trough the de Jure lieges)', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_title_to_title_neighboring_and_across_water_county = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_title_to_title_neighboring_and_across_water_duchy', description: 'Scopes from a title to a neighboring duchy (incl. across water, looking trough the de Jure lieges)', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_title_to_title_neighboring_and_across_water_duchy = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_title_to_title_neighboring_and_across_water_empire', description: 'Scopes from a title to a neighboring empire (incl. across water, looking trough the de Jure lieges)', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_title_to_title_neighboring_and_across_water_empire = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_title_to_title_neighboring_and_across_water_kingdom', description: 'Scopes from a title to a neighboring kingdom (incl. across water, looking trough the de Jure lieges)', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_title_to_title_neighboring_and_across_water_kingdom = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_title_to_title_neighboring_county', description: 'Scopes from a title to a neighboring county (looking trough the de Jure lieges)', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_title_to_title_neighboring_county = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_title_to_title_neighboring_duchy', description: 'Scopes from a title to a neighboring duchy (looking trough the de Jure lieges)', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_title_to_title_neighboring_duchy = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_title_to_title_neighboring_empire', description: 'Scopes from a title to a neighboring empire (looking trough the de Jure lieges)', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_title_to_title_neighboring_empire = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_title_to_title_neighboring_kingdom', description: 'Scopes from a title to a neighboring kingdom (looking trough the de Jure lieges)', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_title_to_title_neighboring_kingdom = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'can_be_leased_out', description: 'Can the scoped title be leased out?', supportedScopes: ['landed_title'], valueType: 'boolean' },
  { name: 'can_create_title_maa', description: 'Can create MaA of specified type for the scoped title', supportedScopes: ['landed_title'] },
  { name: 'can_title_create_faction', description: 'can the title create the faction of the specified type against the specified character?', supportedScopes: ['landed_title'], syntax: "can_title_create_faction = { type = X target = Y }" },
  { name: 'can_title_join_faction', description: 'Can the scope title join the faction? can_title_join_faction = faction', supportedScopes: ['landed_title'], supportedTargets: ['faction'] },
  { name: 'county_control', description: 'does the county title have the required county countrol?', supportedScopes: ['landed_title'], valueType: 'comparison' },
  { name: 'county_fertility', description: 'Does the county title have the required County Fertility value?', supportedScopes: ['landed_title'], valueType: 'comparison', syntax: "scope:county.county_fertility >= <value>" },
  { name: 'county_has_province_with_terrain', description: 'Checks if a county contains a province of a specific terrain type', supportedScopes: ['landed_title'], syntax: "county_has_province_with_terrain = {\nterrain = hills\nterrain = mountains\n}", parameters: ['terrain'] },
  { name: 'county_holder_opinion', description: 'Compares the county\'s opinion of its holder', supportedScopes: ['landed_title'], valueType: 'comparison' },
  { name: 'county_opinion', description: 'compares the county\'s opinion of the current count', supportedScopes: ['landed_title'], valueType: 'comparison' },
  { name: 'county_opinion_target', description: 'compares the county\'s opinion of the target character to the specified value, county_opinion_target = { target = X value >/</= Y }', supportedScopes: ['landed_title'], valueType: 'comparison' },
  { name: 'custom_title_name', description: 'Check if the scoped title uses the specified custom localization name key.', supportedScopes: ['landed_title'], syntax: "custom_title_name = my_title_localization_key" },
  { name: 'de_jure_drift_progress', description: 'Compare drift progress towards target with value<drifting_title> = { de_jure_drif_progress = {     target = <drift_target_title>    value > 50 } }', supportedScopes: ['landed_title'] },
  { name: 'de_jure_drifting_towards', description: 'Is the scoped landed title de jure drifts toward another title?<drifting_title> = { de_jure_drifting_towards = <drift_target_title> }', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'] },
  { name: 'development_level', description: 'does the county title have the required county development level?', supportedScopes: ['landed_title'], valueType: 'comparison' },
  { name: 'development_rate', description: 'how much development progress is the county gaining each month?', supportedScopes: ['landed_title'], valueType: 'comparison' },
  { name: 'development_rate_modifier', description: 'What\'s the multiplier to the development progress?', supportedScopes: ['landed_title'], valueType: 'comparison' },
  { name: 'development_towards_level_increase', description: 'does the county title have the required progress towards the next level of development? E.G., if level 1 is 100, level 2 is 300 (these are set in defines), and current total is 150, this would return 50', supportedScopes: ['landed_title'], valueType: 'comparison' },
  { name: 'fertility_equilibrium', description: 'Check the projected fertility equilibrium of a scoped county', supportedScopes: ['landed_title'], valueType: 'comparison', syntax: "This script is very heavy - and should only be used in script at your own risk, modders." },
  { name: 'has_character_nominiated', description: 'Has the target character nominated a successor for the scoped elective title', supportedScopes: ['landed_title'] },
  { name: 'has_coastal_province', description: 'does the county contain a coastal province?', supportedScopes: ['landed_title'], valueType: 'boolean' },
  { name: 'has_county_modifier', description: 'Does the scoped county have a given modifier', supportedScopes: ['landed_title'], syntax: "has_county_modifier = name" },
  { name: 'has_county_modifier_duration_remaining', description: 'Does the scoped county have the duration remaining on a given modifier', supportedScopes: ['landed_title'], syntax: "has_county_modifier_duration_remaining = name" },
  { name: 'has_custom_title_name', description: 'Check if the scoped title uses a custom localization name key. (set via \'set_title_name\' or \'set_random_dynasty_title_name\')', supportedScopes: ['landed_title'], valueType: 'boolean', syntax: "has_custom_title_name = yes" },
  { name: 'has_disabled_building', description: 'Is the scope landed title connected to a holding that contains at least one disabled building?', supportedScopes: ['landed_title'], valueType: 'boolean' },
  { name: 'has_holy_site_flag', description: 'Does the barony have a holy site with the given flag? has_holy_site_flag = some flag', supportedScopes: ['landed_title'] },
  { name: 'has_order_of_succession', description: 'Does the scoped title have a given order of succession', supportedScopes: ['landed_title'], syntax: "has_order_of_succession = election" },
  { name: 'has_province_with_epidemic', description: 'has_province_with_epidemic = { intensity < apocalyptic }', supportedScopes: ['landed_title'], syntax: "Does the scoped county have a province affected by a less than apocalyptic epidemic" },
  { name: 'has_revokable_lease', description: 'Is the title under a lease that can be revoked manually?', supportedScopes: ['landed_title'], valueType: 'boolean' },
  { name: 'has_title_law', description: 'Does the scoped title have the given title-specific-law?', supportedScopes: ['landed_title'] },
  { name: 'has_title_law_flag', description: 'Does the scoped title have a title-specific law with the given flag?', supportedScopes: ['landed_title'] },
  { name: 'has_user_set_coa', description: 'Has the user set a specific coat of arms for this title?', supportedScopes: ['landed_title'], valueType: 'boolean' },
  { name: 'has_wrong_holding_type', description: 'Is the scope landed title connected to a holding that cannot be governed by the current lessee or holder?', supportedScopes: ['landed_title'], valueType: 'boolean' },
  { name: 'is_capital_barony', description: 'Is title in the scope a capital barony?', supportedScopes: ['landed_title'], valueType: 'boolean' },
  { name: 'is_coastal_county', description: 'Is the county coastal (next to sea, not including lakes)?', supportedScopes: ['landed_title'], valueType: 'boolean' },
  { name: 'is_connected_to', description: 'Is the county connected to the other county? Is based on top liege', supportedScopes: ['landed_title'], syntax: "is_connected_to = {\nmax_naval_distance = 500\nallow_one_county_land_gap = yes\ntarget = some other county\n}", parameters: ['max_naval_distance', 'allow_one_county_land_gap', 'target'] },
  { name: 'is_contested', description: 'Is the scope landed title contested in any war?', supportedScopes: ['landed_title'], valueType: 'boolean' },
  { name: 'is_de_facto_liege_or_above_target', description: 'is the title de facto liege or above the target title?', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'] },
  { name: 'is_de_jure_liege_or_above_target', description: 'is the title de jure liege or above the target title?', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'] },
  { name: 'is_figurehead_title', description: 'Is this title considered a figurehead type title?', supportedScopes: ['landed_title'], valueType: 'boolean' },
  { name: 'is_head_of_faith', description: 'Is this title a head of faith title', supportedScopes: ['landed_title'], valueType: 'boolean' },
  { name: 'is_holy_order', description: 'Is the scope landed title a holy order?', supportedScopes: ['landed_title'], valueType: 'boolean' },
  { name: 'is_holy_site', description: 'Is the barony a holy site of any faith? is_holy_site = yes', supportedScopes: ['landed_title'], valueType: 'boolean' },
  { name: 'is_holy_site_controlled_by', description: 'Does the target character control a holy site of the scoped object', supportedScopes: ['landed_title'], supportedTargets: ['character'], syntax: "is_holy_site_controlled_by = root" },
  { name: 'is_holy_site_of', description: 'Is the barony a holy site of the given faith? is_holy_site_of = some faith', supportedScopes: ['landed_title'], supportedTargets: ['faith'] },
  { name: 'is_important_location', description: 'Is the scoped county important for target title?', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], syntax: "scope:county = { is_important_location = scope:title }" },
  { name: 'is_lakeside_county', description: 'Is the county next to a lake?', supportedScopes: ['landed_title'], valueType: 'boolean' },
  { name: 'is_landless_type_title', description: 'Is this title considered a landless type title?', supportedScopes: ['landed_title'], valueType: 'boolean' },
  { name: 'is_leased_out', description: 'Is the scoped title leased out?', supportedScopes: ['landed_title'], valueType: 'boolean' },
  { name: 'is_mercenary_company', description: 'Is the scope landed title a mercenary company?', supportedScopes: ['landed_title'], valueType: 'boolean' },
  { name: 'is_migration_target', description: 'Is the scoped Landed Title currently target of a migration? Is a nomadic ruler migrating in any county of this Title?', supportedScopes: ['landed_title'], valueType: 'boolean', syntax: "This trigger will evaluate as true if a Migration exists that either:\n* targets the title in scope\n* targets any of its De Jure Lieges\n* targets one of its De Jure Vassals\nusage:\n<scope:title> = {\nis_migration_target = yes/no\n}" },
  { name: 'is_neighbor_to_realm', description: 'Is this landed title adjacent to the character\'s realm', supportedScopes: ['landed_title'], supportedTargets: ['character'], syntax: "is_neighbor_to_realm = character" },
  { name: 'is_noble_family_title', description: 'Is this title used by noble family to allow landless playable', supportedScopes: ['landed_title'], valueType: 'boolean' },
  { name: 'is_nomad_title', description: 'Is this title used by a nomad to allow landless playable', supportedScopes: ['landed_title'], valueType: 'boolean' },
  { name: 'is_riverside_county', description: 'Is the county riverside?', supportedScopes: ['landed_title'], valueType: 'boolean' },
  { name: 'is_ruler_de_jure_liege_or_above', description: 'is the target ruler de jure liege or above the target title?', supportedScopes: ['landed_title'], supportedTargets: ['character'] },
  { name: 'is_target_of_council_task', description: 'Is the county currently affected by the specified council task? Needs to be in a county title scope.', supportedScopes: ['landed_title'], syntax: "landed_county_title = {\nis_target_of_council_task = task_kurultai_fertility_2\n}", parameters: ['landed_county_title'] },
  { name: 'is_target_of_council_task_or_clone', description: 'Is the county currently affected by the specified council task, or one of its clones? Needs to be in a county title scope.', supportedScopes: ['landed_title'], syntax: "The example will yield yes if the county is affected by task_kurultai_fertility_1.\nlanded_county_title = {\nis_target_of_council_task = task_kurultai_fertility_2\n}", parameters: ['landed_county_title', 'is_target_of_council_task'] },
  { name: 'is_title_created', description: 'Is title in the scope created?', supportedScopes: ['landed_title'], valueType: 'boolean' },
  { name: 'is_titular', description: 'Is this title titular (has no dejure counties in it, and is not a barony/county)?', supportedScopes: ['landed_title'], valueType: 'boolean' },
  { name: 'is_under_holy_order_lease', description: 'Is the scoped title leased out to any holy order?', supportedScopes: ['landed_title'], valueType: 'boolean' },
  { name: 'min_appointment_level', description: 'Required currency level for appointment for the title', supportedScopes: ['landed_title'], valueType: 'comparison', syntax: "\"scope:title.min_appointment_level > 2" },
  { name: 'monthly_county_control_change', description: 'How much county control is the county gaining/losing each month in total?', supportedScopes: ['landed_title'], valueType: 'comparison' },
  { name: 'monthly_county_control_decline', description: 'How much county control is the county declining each month? (ignoring any growth)', supportedScopes: ['landed_title'], valueType: 'comparison' },
  { name: 'monthly_county_control_decline_factor', description: 'What\'s the multiplier to the control decline rate? E.G., if there\'s just a +20% modifier, this would return 1.2', supportedScopes: ['landed_title'], valueType: 'comparison' },
  { name: 'monthly_county_control_growth', description: 'How much county control is the county gaining each month? (ignoring any decline)', supportedScopes: ['landed_title'], valueType: 'comparison' },
  { name: 'monthly_county_control_growth_factor', description: 'What\'s the multiplier to the control growth rate? E.G., if there\'s just a +20% modifier, this would return 1.2', supportedScopes: ['landed_title'], valueType: 'comparison' },
  { name: 'num_county_holdings', description: 'How many provinces in this county have holdings', supportedScopes: ['landed_title'], valueType: 'comparison' },
  { name: 'place_in_line_of_succession', description: 'what place in line of succession does the character hold?)', supportedScopes: ['landed_title'], valueType: 'comparison', syntax: "\"place_in_line_of_succession(scope:target)\" > 1\nplace_in_line_of_succession = {\ntarget = scope:title\nvalue < 3\n}", parameters: ['target'] },
  { name: 'recent_history', description: 'Does the scoped title have a history entry of the specified type in recent history?', supportedScopes: ['landed_title'], syntax: "recent_history = { type = X days/months/years = Y }\nThe type can be omitted, all history types are considered then\nPossible types:\nconquest\nconquest_holy_war\nconquest_claim\nconquest_populist\nelection\ninheritance\nabdication\ncreated\ndestroyed\nusurped\ngranted\nrevoked\nindependency\nleased_out\nlease_revoked\nreturned\nfaction_demand\nswear_fealty\nstepped_down\nappointment\nappointment_succession", parameters: ['days', 'months', 'years'] },
  { name: 'target_is_de_facto_liege_or_above', description: 'is the target title de facto liege or above?', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'] },
  { name: 'target_is_de_jure_liege_or_above', description: 'is the target title de jure liege or above?', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'] },
  { name: 'tier', description: 'What tier is the scoped title? barony = 1, empire = 5. Use the script values please, not raw numbers', supportedScopes: ['landed_title'], valueType: 'comparison' },
  { name: 'title_create_faction_type_chance', description: 'Check if the chance to create a faction against a target of the scope landed title is is true against the scripted value', supportedScopes: ['landed_title'], syntax: "title_create_faction_type_chance = {\ntype = faction_type #An ongoing faction\ntarget = target_character\nvalue <|<=|>=|> 0\n}", parameters: ['type', 'target'] },
  { name: 'title_held_years', description: 'Returns the number of years a title is held if valid (otherwise returns 0)', supportedScopes: ['landed_title'], valueType: 'comparison' },
  { name: 'title_is_a_faction_member', description: 'Is the scope title a member of a faction?', supportedScopes: ['landed_title'], valueType: 'boolean' },
  { name: 'title_join_faction_chance', description: 'Check if the chance of the scope landed title to join the faction against the scripted value', supportedScopes: ['landed_title'], valueType: 'comparison', syntax: "title_join_faction_chance = {\nfaction = faction_target #An ongoing faction\nvalue <|<=|>=|> 0\n}", parameters: ['faction'] },
  { name: 'title_law_group_at_maximum_level', description: 'Does the scoped title have the maximum level of the title law group given?', supportedScopes: ['landed_title'] },
  { name: 'title_law_group_at_minimum_level', description: 'Does the scoped title have the minimum level of the title law group given?', supportedScopes: ['landed_title'] },
  { name: 'title_will_leave_sub_realm_on_succession', description: 'Will the title leave the sub-realm of the character on the right-hand-side upon succession? That is, is the first heir in someone outside the sub-realm, and the highest tier title they\'ll inherit from the person holding the title is not higher than their current tier', supportedScopes: ['landed_title'] },
  { name: 'uses_county_fertility', description: 'Does the scoped county title use County Fertility?', supportedScopes: ['landed_title'], valueType: 'boolean', syntax: "uses_county_fertility = yes/no" },
  { name: 'building_levies', description: 'The amount of levies in a county or province from buildings', supportedScopes: ['landed_title', 'province'], valueType: 'comparison', syntax: "levies > 100" },
  { name: 'building_max_garrison', description: 'The max amount of garrison in a county or province from buildings', supportedScopes: ['landed_title', 'province'], valueType: 'comparison', syntax: "levies > 100" },
  { name: 'squared_distance', description: 'How far away is the province/barony/county from the target? Measured in map pixels. Squared for performance reasons (square root is expensive). squared_distance = { target = some province/barony/county value > 10000 }', supportedScopes: ['landed_title', 'province'], valueType: 'comparison' },
];

/**
 * Triggers for province scope (51 triggers)
 */
export const provinceTriggers: TriggerDefinition[] = [
  { name: 'any_army_in_location', description: 'Iterate through all armies currently located in the scoped province', supportedScopes: ['province'], supportedTargets: ['army'], outputScope: 'army', isIterator: true, valueType: 'block', syntax: "any_army_in_location = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_character_in_location', description: 'Iterate through all characters currently located in the scoped province', supportedScopes: ['province'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_character_in_location = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_great_project_in_province', description: 'Iterate through all active Great Projects in a Province.', supportedScopes: ['province'], supportedTargets: ['great_project'], outputScope: 'great_project', isIterator: true, valueType: 'block', syntax: "any_great_project_in_province = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_neighboring_province', description: 'Iterate through all neighboring provinces of a province', supportedScopes: ['province'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, valueType: 'block', syntax: "any_neighboring_province = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_province_domicile', description: 'Iterate through all domiciles of scoped province', supportedScopes: ['province'], supportedTargets: ['domicile'], outputScope: 'domicile', isIterator: true, valueType: 'block', syntax: "any_province_domicile = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_province_epidemic', description: 'Gets epidemics affecting the scoped province', supportedScopes: ['province'], supportedTargets: ['epidemic'], outputScope: 'epidemic', isIterator: true, valueType: 'block', syntax: "Optionally specify an outbreak intensity filter\nany_province_epidemic = { intensity = apocalyptic }\nany_province_epidemic = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_province_legend', description: 'Gets legends affecting the scoped province', supportedScopes: ['province'], supportedTargets: ['legend'], outputScope: 'legend', isIterator: true, valueType: 'block', syntax: "any_province_legend = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'available_loot', description: 'How much gold is available to loot for raiding/bartering armies?', supportedScopes: ['province'], valueType: 'comparison', syntax: "available_loot >= 7" },
  { name: 'building_slots', description: 'How many building slots exist (including occupied ones)?', supportedScopes: ['province'], valueType: 'comparison', syntax: "building_slots > 3" },
  { name: 'combined_building_level', description: 'How many levels of normal buildings are there? Duchy and such buildings do not count. Building under construction does not count. The capital building does count', supportedScopes: ['province'], valueType: 'comparison', syntax: "combined_building_level > 10" },
  { name: 'days_since_province_infection', description: 'Number of days since the target epidemic infected the scoped province', supportedScopes: ['province'], valueType: 'comparison', syntax: "days_since_province_infection = {\nvalue >= 20\ntarget = scope:epidemic\n}", parameters: ['target'] },
  { name: 'epidemic_resistance', description: 'Get the epidemic resistance of the scoped province.', supportedScopes: ['province'], valueType: 'comparison', syntax: "epidemic_resistance >= 20" },
  { name: 'fort_level', description: 'Compares the fort level of a province', supportedScopes: ['province'], valueType: 'comparison' },
  { name: 'free_building_slots', description: 'How many free building slots exist? A building in construction is considered to be taking a slot', supportedScopes: ['province'], valueType: 'comparison', syntax: "free_building_slots > 3" },
  { name: 'geographical_region', description: 'Checks if a province is in a certain geographical region', supportedScopes: ['province'], supportedTargets: ['geographical_region'] },
  { name: 'has_building', description: 'does the scope province have a particular building?', supportedScopes: ['province'], syntax: "has_building = temple_01" },
  { name: 'has_building_or_higher', description: 'does the scope province have a particular building or its successor?', supportedScopes: ['province'], syntax: "has_building_or_higher = temple_01" },
  { name: 'has_building_with_flag', description: 'does the scope province have a building with a certain flag?', supportedScopes: ['province'], syntax: "has_building_with_flag = { flag = temple count >= 2 }\nhas_building_with_flag = temple # count >= 1" },
  { name: 'has_construction_with_flag', description: 'does the scope province have a construction of a building with the specified flag?', supportedScopes: ['province'], syntax: "has_construction_with_flag = temple" },
  { name: 'has_free_building_slot', description: 'does the scope province have a free building slot? has_free_building_slot = yes', supportedScopes: ['province'], valueType: 'boolean' },
  { name: 'has_great_building', description: 'Does the province (holding) have a great building?', supportedScopes: ['province'], valueType: 'boolean' },
  { name: 'has_great_building_slot', description: 'Does the province (holding) have a great building slot?', supportedScopes: ['province'], valueType: 'boolean' },
  { name: 'has_holding', description: 'does the scope province have holding?', supportedScopes: ['province'], valueType: 'boolean', syntax: "has_holding = yes" },
  { name: 'has_holding_type', description: 'does the scope province have a holding of particular type?', supportedScopes: ['province'], syntax: "has_holding_type = castle_holding" },
  { name: 'has_ongoing_construction', description: 'does the scope province have a construction ongoing?', supportedScopes: ['province'], valueType: 'boolean', syntax: "has_ongoing_construction = yes" },
  { name: 'has_province_modifier', description: 'Does the scoped province have a given modifier', supportedScopes: ['province'], syntax: "has_province_modifier = name" },
  { name: 'has_province_modifier_duration_remaining', description: 'Does the scoped province have the duration remaining on a given modifier', supportedScopes: ['province'], syntax: "has_province_modifier_duration_remaining = name" },
  { name: 'has_ruined_great_building', description: 'Does this province have a ruined Great Building?', supportedScopes: ['province'], valueType: 'boolean' },
  { name: 'has_special_building', description: 'Does the province (holding) have a special building?', supportedScopes: ['province'], valueType: 'boolean' },
  { name: 'has_special_building_slot', description: 'Does the province (holding) have a special building slot?', supportedScopes: ['province'], valueType: 'boolean' },
  { name: 'has_stationed_regiment', description: 'Does this province have stationed regiments?', supportedScopes: ['province'], valueType: 'boolean' },
  { name: 'has_stationed_regiment_of_base_type', description: 'Does the province have stationed regiment of base type?', supportedScopes: ['province'] },
  { name: 'has_travel_point_of_interest', description: 'Checks if there is a travel point of interest of type X in the province.', supportedScopes: ['province'], syntax: "has_travel_point_of_interest = point_of_interest_type" },
  { name: 'is_coastal', description: 'Is the province a coastal province (next to sea, not including lakes)?', supportedScopes: ['province'], valueType: 'boolean' },
  { name: 'is_county_capital', description: 'Is the province the county capital?', supportedScopes: ['province'], valueType: 'boolean' },
  { name: 'is_lake_province', description: 'Is this a lake province?', supportedScopes: ['province'], valueType: 'boolean' },
  { name: 'is_lakeside_province', description: 'Is the province next to a lake?', supportedScopes: ['province'], valueType: 'boolean' },
  { name: 'is_occupied', description: 'Is this province currently being occupied?', supportedScopes: ['province'], valueType: 'boolean' },
  { name: 'is_raided', description: 'Is this province currently being raided?', supportedScopes: ['province'], valueType: 'boolean' },
  { name: 'is_river_province', description: 'Is the province a river?', supportedScopes: ['province'], valueType: 'boolean' },
  { name: 'is_riverside_province', description: 'Is the province riverside?', supportedScopes: ['province'], valueType: 'boolean' },
  { name: 'is_ruined_building_being_reconstructed', description: 'does the scope province have a ruined building that is currently being reconstructed? Only Great Buildings can be Ruined and be Reconstructed.', supportedScopes: ['province'], valueType: 'boolean', syntax: "is_ruined_building_being_reconstructed = yes" },
  { name: 'is_sea_province', description: 'Is this a sea province?', supportedScopes: ['province'], valueType: 'boolean' },
  { name: 'monthly_income', description: 'Check the income of the scoped province', supportedScopes: ['province'], valueType: 'comparison', syntax: "monthly_income > 10" },
  { name: 'num_buildings', description: 'How many normal buildings are there? Duchy and such buildings do not count. Building under construction does count', supportedScopes: ['province'], valueType: 'comparison', syntax: "num_buildings > 3" },
  { name: 'number_of_characters_in_pool', description: 'Check the number of characters in the pool the scoped province is a part of', supportedScopes: ['province'], valueType: 'comparison' },
  { name: 'province_infection_date', description: 'Date when the target epidemic infected the scoped province.', supportedScopes: ['province'], valueType: 'comparison' },
  { name: 'province_infection_rate', description: 'Infection rate of target epidemic in the scoped province', supportedScopes: ['province'], valueType: 'comparison', syntax: "province_infection_rate = {\nvalue >= 20\ntarget = scope:epidemic\n}", parameters: ['target'] },
  { name: 'terrain', description: 'Checks if a province is of a specific terrain type', supportedScopes: ['province'] },
  { name: 'travel_danger_type', description: 'Checks if a province\'s danger type is of a specific type for a specific travel plan', supportedScopes: ['province'], syntax: "travel_danger_type = { travel_plan = scope:some_travel_plan type = name_of_danger_type }\ntravel_danger_type = { travel_plan = scope:some_travel_plan terrain = terrain type }" },
  { name: 'travel_danger_value', description: 'What is the province\'s danger value for a specific travel plan? travel_danger_value = { target = scope:some_travel_plan value > 1 }', supportedScopes: ['province'], valueType: 'comparison' },
];

/**
 * Triggers for dynasty scope (30 triggers)
 */
export const dynastyTriggers: TriggerDefinition[] = [
  { name: 'any_dynasty_house', description: 'Iterate through all houses in dynasty', supportedScopes: ['dynasty'], supportedTargets: ['dynasty_house'], outputScope: 'dynasty_house', isIterator: true, valueType: 'block', syntax: "any_dynasty_house = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_dynasty_member', description: 'Iterate through all dynasty members', supportedScopes: ['dynasty'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_dynasty_member = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'blood_legacy_track_perks', description: 'How many perks in the lifestyle does this dynasty have?', supportedScopes: ['dynasty'], valueType: 'comparison' },
  { name: 'ce1_heroic_track_perks', description: 'How many perks in the lifestyle does this dynasty have?', supportedScopes: ['dynasty'], valueType: 'comparison' },
  { name: 'ce1_legitimacy_legacy_track_perks', description: 'How many perks in the lifestyle does this dynasty have?', supportedScopes: ['dynasty'], valueType: 'comparison' },
  { name: 'dynasty_can_unlock_relevant_perk', description: 'Can the scoped dynasty unlock a \'relevant\' perk? Relevant meaning one that isn\'t the first in its track unless the dynasty has no partially filled tracks', supportedScopes: ['dynasty'], valueType: 'boolean' },
  { name: 'dynasty_num_unlocked_perks', description: 'does the dynasty has the required number of unlocked dynasty perks?', supportedScopes: ['dynasty'], valueType: 'comparison' },
  { name: 'dynasty_prestige', description: 'does the dynasty have the required prestige?', supportedScopes: ['dynasty'], valueType: 'comparison' },
  { name: 'dynasty_prestige_level', description: 'does the dynasty have the required prestige level?', supportedScopes: ['dynasty'], valueType: 'comparison' },
  { name: 'ep1_culture_legacy_track_perks', description: 'How many perks in the lifestyle does this dynasty have?', supportedScopes: ['dynasty'], valueType: 'comparison' },
  { name: 'ep2_activities_legacy_track_perks', description: 'How many perks in the lifestyle does this dynasty have?', supportedScopes: ['dynasty'], valueType: 'comparison' },
  { name: 'ep3_administrative_legacy_track_perks', description: 'How many perks in the lifestyle does this dynasty have?', supportedScopes: ['dynasty'], valueType: 'comparison' },
  { name: 'erudition_legacy_track_perks', description: 'How many perks in the lifestyle does this dynasty have?', supportedScopes: ['dynasty'], valueType: 'comparison' },
  { name: 'fp1_adventure_legacy_track_perks', description: 'How many perks in the lifestyle does this dynasty have?', supportedScopes: ['dynasty'], valueType: 'comparison' },
  { name: 'fp1_pillage_legacy_track_perks', description: 'How many perks in the lifestyle does this dynasty have?', supportedScopes: ['dynasty'], valueType: 'comparison' },
  { name: 'fp2_coterie_legacy_track_perks', description: 'How many perks in the lifestyle does this dynasty have?', supportedScopes: ['dynasty'], valueType: 'comparison' },
  { name: 'fp2_urbanism_legacy_track_perks', description: 'How many perks in the lifestyle does this dynasty have?', supportedScopes: ['dynasty'], valueType: 'comparison' },
  { name: 'fp3_khvarenah_legacy_track_perks', description: 'How many perks in the lifestyle does this dynasty have?', supportedScopes: ['dynasty'], valueType: 'comparison' },
  { name: 'glory_legacy_track_perks', description: 'How many perks in the lifestyle does this dynasty have?', supportedScopes: ['dynasty'], valueType: 'comparison' },
  { name: 'guile_legacy_track_perks', description: 'How many perks in the lifestyle does this dynasty have?', supportedScopes: ['dynasty'], valueType: 'comparison' },
  { name: 'has_dynasty_modifier', description: 'Does the scoped dynasty have a given modifier', supportedScopes: ['dynasty'], syntax: "has_dynasty_modifier = name" },
  { name: 'has_dynasty_modifier_duration_remaining', description: 'Does the scoped dynasty have the duration remaining on a given modifier', supportedScopes: ['dynasty'], syntax: "has_dynasty_modifier_duration_remaining = name" },
  { name: 'has_dynasty_perk', description: 'Does the dynasty have this dynasty perk? has_dynasty_perk = key', supportedScopes: ['dynasty'] },
  { name: 'kin_legacy_track_perks', description: 'How many perks in the lifestyle does this dynasty have?', supportedScopes: ['dynasty'], valueType: 'comparison' },
  { name: 'law_legacy_track_perks', description: 'How many perks in the lifestyle does this dynasty have?', supportedScopes: ['dynasty'], valueType: 'comparison' },
  { name: 'mpo_nomad_legacy_track_perks', description: 'How many perks in the lifestyle does this dynasty have?', supportedScopes: ['dynasty'], valueType: 'comparison' },
  { name: 'tgp_china_legacy_track_perks', description: 'How many perks in the lifestyle does this dynasty have?', supportedScopes: ['dynasty'], valueType: 'comparison' },
  { name: 'tgp_japan_legacy_track_perks', description: 'How many perks in the lifestyle does this dynasty have?', supportedScopes: ['dynasty'], valueType: 'comparison' },
  { name: 'tgp_southeast_asia_legacy_track_perks', description: 'How many perks in the lifestyle does this dynasty have?', supportedScopes: ['dynasty'], valueType: 'comparison' },
  { name: 'warfare_legacy_track_perks', description: 'How many perks in the lifestyle does this dynasty have?', supportedScopes: ['dynasty'], valueType: 'comparison' },
];

/**
 * Triggers for dynasty_house scope (24 triggers)
 */
export const dynastyhouseTriggers: TriggerDefinition[] = [
  { name: 'any_house_claimed_artifact', description: 'Iterate through all claimed artifacts of the scoped house', supportedScopes: ['dynasty_house'], supportedTargets: ['artifact'], outputScope: 'artifact', isIterator: true, valueType: 'block', syntax: "any_house_claimed_artifact = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_house_member', description: 'Iterate through all house members', supportedScopes: ['dynasty_house'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_house_member = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_house_relation', description: 'Iterate over all house relations of the given house', supportedScopes: ['dynasty_house'], supportedTargets: ['house_relation'], outputScope: 'house_relation', isIterator: true, valueType: 'block', syntax: "any_house_relation = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_house_unity_member', description: 'Iterate through all valid house unity members', supportedScopes: ['dynasty_house'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_house_unity_member = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'can_change_house_aspiration', description: 'Can the scoped Dynasty House change/upgrade their House Aspiration?', supportedScopes: ['dynasty_house'], valueType: 'boolean', syntax: "scope:house = { can_change_house_aspiration = yes/no }" },
  { name: 'has_base_name', description: 'Does the given house have the given base name? Remember that characters can be lowborn and have no house.', supportedScopes: ['dynasty_house'], syntax: "usage:\nscope:character = {\nhouse ?= { has_base_name = \"dynn_name_key\" }\n}" },
  { name: 'has_default_house_aspiration', description: 'does the house have a default House Aspiration?', supportedScopes: ['dynasty_house'], valueType: 'boolean' },
  { name: 'has_house_artifact_claim', description: 'Does the scoped dynasty house have a personal claim on the target artifact', supportedScopes: ['dynasty_house'], supportedTargets: ['artifact'] },
  { name: 'has_house_head_parameter', description: 'Does the given house a house head with the given parameter?', supportedScopes: ['dynasty_house'], syntax: "Can only check for boolean parameters.\nhas_house_head_parameter = parameter_key" },
  { name: 'has_house_modifier', description: 'Does the scoped house have a given modifier', supportedScopes: ['dynasty_house'], syntax: "has_house_modifier = name" },
  { name: 'has_house_modifier_duration_remaining', description: 'Does the scoped house have the duration remaining on a given modifier', supportedScopes: ['dynasty_house'], syntax: "has_house_modifier_duration_remaining = name" },
  { name: 'has_house_power_parameter', description: 'Does the given house a house power/aspiration with the given parameter?', supportedScopes: ['dynasty_house'], syntax: "Can only check for boolean parameters.\nhas_house_power_parameter = parameter_key" },
  { name: 'has_house_relation_with', description: 'Is there a House Relation between the two houses?', supportedScopes: ['dynasty_house'], supportedTargets: ['dynasty_house'], syntax: "usage:\n<some_house> = {\nhas_house_relation_with = <other_house>\n}" },
  { name: 'has_house_unity', description: 'Is the given dynasty house has house unity', supportedScopes: ['dynasty_house'], valueType: 'boolean' },
  { name: 'has_house_unity_modifier', description: 'Does the scoped house with unity have a given modifier', supportedScopes: ['dynasty_house'], syntax: "has_house_unity_modifier = name" },
  { name: 'has_house_unity_modifier_duration_remaining', description: 'Does the scoped house have the duration remaining on a given modifier', supportedScopes: ['dynasty_house'], syntax: "has_house_unity_modifier_duration_remaining = name" },
  { name: 'has_house_unity_parameter', description: 'Does the given house unity have the given parameter? Can only check for bool parameters. has_house_unity_parameter = parameter_key', supportedScopes: ['dynasty_house'] },
  { name: 'has_house_unity_stage', description: 'Is the given house unity the given stage?.', supportedScopes: ['dynasty_house'], syntax: "has_house_unity_stage = house_unity_stage_key" },
  { name: 'has_same_house_power_as', description: 'Does this house have the same house power/aspiration as the target house?', supportedScopes: ['dynasty_house'], supportedTargets: ['dynasty_house'], syntax: "usage:\n<house> = {\nhas_same_house_power_as = scope:target_house\n}" },
  { name: 'house_land_share_in_realm', description: 'Calculate the percentage of counties held in the target top liege\'s realm by the house.', supportedScopes: ['dynasty_house'], valueType: 'comparison', syntax: "Only the direct vassals of the top liege are counted - if a house member holds land but is not a direct vassal it's as if they had none for this calculation.\nOnly rulers with the same government type as the top liege's are counted.\nscope:house = {\nhouse_land_share_in_realm = {\ntarget = scope:liege\nvalue > 0.5\n}\n}", parameters: ['target'] },
  { name: 'house_power', description: 'Compare house power: scope:house = { house_power >= value }', supportedScopes: ['dynasty_house'], valueType: 'comparison' },
  { name: 'house_unity_value', description: 'does the dynasty house have the required house unity value?', supportedScopes: ['dynasty_house'], valueType: 'comparison' },
  { name: 'is_dominant_family', description: 'Is the given house considered dominant: scope:house = { is_dominant_family = yes }', supportedScopes: ['dynasty_house'], valueType: 'boolean' },
  { name: 'is_powerful_family', description: 'Is the given house considered powerful: scope:house = { is_powerful_family = yes }', supportedScopes: ['dynasty_house'], valueType: 'boolean' },
];

/**
 * Triggers for culture scope (37 triggers)
 */
export const cultureTriggers: TriggerDefinition[] = [
  { name: 'any_culture_county', description: 'Iterate through all counties of the culture', supportedScopes: ['culture'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_culture_county = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_culture_duchy', description: 'Iterate through all duchies of the culture (duchies with at least one county of the culture', supportedScopes: ['culture'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_culture_duchy = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_culture_empire', description: 'Iterate through all empires of the culture (empires with at least one county of the culture', supportedScopes: ['culture'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_culture_empire = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_culture_kingdom', description: 'Iterate through all kingdoms of the culture (kingdoms with at least one county of the culture', supportedScopes: ['culture'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_culture_kingdom = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_known_innovation', description: 'Iterate through all innovations known to the given culture', supportedScopes: ['culture'], supportedTargets: ['culture_innovation'], outputScope: 'culture_innovation', isIterator: true, valueType: 'block', syntax: "any_known_innovation = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_parent_culture', description: 'Iterate through all parent cultures', supportedScopes: ['culture'], supportedTargets: ['culture'], outputScope: 'culture', isIterator: true, valueType: 'block', syntax: "any_parent_culture = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_parent_culture_or_above', description: 'Iterate through all parent cultures or above', supportedScopes: ['culture'], supportedTargets: ['culture'], outputScope: 'culture', isIterator: true, valueType: 'block', syntax: "any_parent_culture_or_above = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_tradition', description: 'Iterate through all traditions of the given culture', supportedScopes: ['culture'], supportedTargets: ['culture_tradition'], outputScope: 'culture_tradition', isIterator: true, valueType: 'block', syntax: "any_tradition = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'can_get_innovation_from', description: 'Get random applicable innovation from another culture', supportedScopes: ['culture'] },
  { name: 'cultural_acceptance', description: 'The cultural acceptance of the scoped culture with the target culture', supportedScopes: ['culture'], valueType: 'comparison', syntax: "cultural_acceptance = { target = culture value > 50 }" },
  { name: 'culture_age', description: 'Checks the age of the scope culture in years. If the culture has no creation date set, this will simply return the current year', supportedScopes: ['culture'], valueType: 'comparison', syntax: "culture_age >= 200" },
  { name: 'culture_has_any_fascination', description: 'Is the culture currently Fascinated by an innovation?', supportedScopes: ['culture'], valueType: 'boolean', syntax: "usage:\n<culture> = {\nculture_has_any_fascination = yes\n}" },
  { name: 'culture_number_of_counties', description: 'How many counties are there of this culture?', supportedScopes: ['culture'], valueType: 'comparison', syntax: "culture_number_of_counties > 10" },
  { name: 'culture_overlaps_geographical_region', description: 'Checks if any county with this culture is in the given geographical region', supportedScopes: ['culture'], supportedTargets: ['geographical_region'] },
  { name: 'free_tradition_slot', description: 'How many free tradition slot are in the scoped culturescope:culture = { free_tradition_slot > 1 }', supportedScopes: ['culture'], valueType: 'comparison' },
  { name: 'has_all_innovations', description: 'Has the culture discovered all innovations matching the filter?', supportedScopes: ['culture'], syntax: "has_all_innovations = {\nwith_flag = flag_name # innovation matches if it has the flag; optional\nwithout_flag = flag_name # innovation matches if it does not have the flag; optional\nculture_era = era_key # innovation matches if it is from the era; optional\n}", parameters: ['with_flag', 'without_flag', 'culture_era'] },
  { name: 'has_building_gfx', description: 'Does the culture have this building gfx?', supportedScopes: ['culture'], syntax: "<culture> = { has_building_gfx = mena_building_gfx }" },
  { name: 'has_clothing_gfx', description: 'Does the culture have this clothing gfx?', supportedScopes: ['culture'], syntax: "<culture> = { has_building_gfx = mena_clothing_gfx }" },
  { name: 'has_coa_gfx', description: 'Does the culture have this CoA gfx?', supportedScopes: ['culture'], syntax: "<culture> = { has_building_gfx = mena_coa_gfx }" },
  { name: 'has_cultural_era_or_later', description: 'Has this culture achieved specified era<culture> = { has_cultural_era_or_later = culture_era_early_medieval }', supportedScopes: ['culture'] },
  { name: 'has_cultural_parameter', description: 'Does the culture have this cultural parameter?', supportedScopes: ['culture'], syntax: "<culture> = { has_cultural_parameter = name }" },
  { name: 'has_cultural_pillar', description: 'Does the culture have this cultural pillar?', supportedScopes: ['culture'], syntax: "<culture> = { has_cultural_pillar = name }" },
  { name: 'has_cultural_tradition', description: 'Does the culture have this cultural tradition scope?', supportedScopes: ['culture'], supportedTargets: ['culture_tradition'], syntax: "<culture> = { has_cultural_tradition = scope:traditon }" },
  { name: 'has_innovation', description: 'Have the culture discovered this innovation?', supportedScopes: ['culture'], supportedTargets: ['culture_innovation'] },
  { name: 'has_innovation_flag', description: 'Has the culture discovered an innovation with this flag? has_innovation_flag = flag', supportedScopes: ['culture'] },
  { name: 'has_name_list', description: 'Does the culture have this name list?', supportedScopes: ['culture'], syntax: "<culture> = { has_name_list = name }" },
  { name: 'has_primary_name_list', description: 'Does the culture have this name list as its first name list?', supportedScopes: ['culture'], syntax: "<culture> = { has_primary_name_list = name }" },
  { name: 'has_same_culture_ethos', description: 'Does the culture have the same ethos as the target?', supportedScopes: ['culture'], supportedTargets: ['culture'] },
  { name: 'has_same_culture_head_determination', description: 'Does the culture have the same head determination as the target?', supportedScopes: ['culture'], supportedTargets: ['culture'] },
  { name: 'has_same_culture_heritage', description: 'Does the culture have the same heritage as the target?', supportedScopes: ['culture'], supportedTargets: ['culture'] },
  { name: 'has_same_culture_language', description: 'Does the culture have the same language as the target?', supportedScopes: ['culture'], supportedTargets: ['culture'] },
  { name: 'has_same_culture_martial_tradition', description: 'Does the culture have the same martial tradition as the target?', supportedScopes: ['culture'], supportedTargets: ['culture'] },
  { name: 'has_unit_gfx', description: 'Does the culture have this unit gfx?', supportedScopes: ['culture'], syntax: "<culture> = { has_unit_gfx = mena_unit_gfx }" },
  { name: 'is_divergent_culture', description: 'Checks if the scope culture was created by diverging from a single parent culture and returns yes if true or no if false.', supportedScopes: ['culture'], valueType: 'boolean', syntax: "is_divergent_culture = yes" },
  { name: 'is_hybrid_culture', description: 'Checks if the scope culture was created from a hybridization of two cultures and returns yes if true or no if false.', supportedScopes: ['culture'], valueType: 'boolean', syntax: "is_hybrid_culture = yes" },
  { name: 'num_discovered_innovations', description: 'Does the culture have the required number of discovered innovations?', supportedScopes: ['culture'], valueType: 'comparison', syntax: "num_discovered_innovations > 20" },
  { name: 'num_discovered_innovations_in_era', description: 'Does the scoped culture have the required number of active discovered innovations in the specified era?', supportedScopes: ['culture'], valueType: 'comparison', syntax: "num_discovered_innovations_in_era = {\ntarget = culture_era_early_medieval\nvalue > 5\n}\nnum_discovered_innovations_in_era:culture_era_early_medieval > 15\nnum_discovered_innovations_in_era:culture_era_early_medieval >\n\"scope:target_culture.num_discovered_innovations_in_era:culture_era_early_medieval", parameters: ['target'] },
];

/**
 * Triggers for culture_innovation scope (7 triggers)
 */
export const cultureinnovationTriggers: TriggerDefinition[] = [
  { name: 'culture_can_know_innovation', description: 'Can the culture gain progress towards this innovation?', supportedScopes: ['culture_innovation'], supportedTargets: ['culture'], syntax: "usage:\n<innovation> = {\nculture_can_know_innovation = scope:target_culture\n}" },
  { name: 'has_innovation_parameter', description: 'Does the innovation type have this parameter?', supportedScopes: ['culture_innovation'], syntax: "<innovation> = { has_innovation_parameter = name }" },
  { name: 'innovation_era', description: 'Does the scoped innovation belong to the specified era?', supportedScopes: ['culture_innovation'], syntax: "scope:innovation = { innovation_era = culture_era_early_medieval }" },
  { name: 'innovation_is_regional', description: 'Is the scoped innovation regional?', supportedScopes: ['culture_innovation'], valueType: 'boolean', syntax: "scope:innovation = { innovation_is_regional = yes }" },
  { name: 'innovation_key', description: 'Is the scoped innovation the same as the specified one?', supportedScopes: ['culture_innovation'], syntax: "scope:innovation = { innovation_key = gunpowder }" },
  { name: 'is_ahead_of_time_for_culture', description: 'Is scoped innovation ahead of time for the specified culture? same as checking if innovation era > current culture era.', supportedScopes: ['culture_innovation'], supportedTargets: ['culture'], syntax: "scope:innovation = { is_ahead_of_time_for_culture = scope:culture }" },
  { name: 'is_known_by_culture', description: 'Is scoped innovation known by the specified culture?', supportedScopes: ['culture_innovation'], supportedTargets: ['culture'], syntax: "scope:innovation = { is_known_by_culture = scope:culture }" },
];

/**
 * Triggers for faith scope (26 triggers)
 */
export const faithTriggers: TriggerDefinition[] = [
  { name: 'is_in_family', description: 'Is the scoped faith/religion in a given religious family', supportedScopes: ['faith', 'religion'], syntax: "is_in_family = abrhamic" },
  { name: 'any_defensive_great_holy_wars', description: 'Iterate through all great holy wars this faith is defending against', supportedScopes: ['faith'], supportedTargets: ['ghw'], outputScope: 'ghw', isIterator: true, valueType: 'block', syntax: "any_defensive_great_holy_wars = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_faith_character', description: 'Iterate through characters of the scoped faith', supportedScopes: ['faith'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_faith_character = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_faith_holy_order', description: 'Iterate through all holy orders of the faith', supportedScopes: ['faith'], supportedTargets: ['holy_order'], outputScope: 'holy_order', isIterator: true, valueType: 'block', syntax: "any_faith_holy_order = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_faith_playable_ruler', description: 'Iterate through playable rulers of the scoped faith', supportedScopes: ['faith'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_faith_playable_ruler = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_faith_ruler', description: 'Iterate through rulers of the scoped faith', supportedScopes: ['faith'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_faith_ruler = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_holy_site', description: 'Iterate through all holy site baronies of a faith', supportedScopes: ['faith'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_holy_site = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'controls_holy_site', description: 'Does the faith control a holy site? controls_holy_site = key_of_holy_site', supportedScopes: ['faith'] },
  { name: 'controls_holy_site_with_flag', description: 'Does the faith control a holy site with the given flag? controls_holy_site_with_flag = some flag', supportedScopes: ['faith'] },
  { name: 'estimated_faith_strength', description: 'How strong is the scoped faith? *Expensive*, if you\'re gonna use the value repeatedly, save it to a scope first! This is scaled by a factor of 1000, so \'1\' means 1000 men. This is due to the cap of ~2 million, which would be too low in many cases', supportedScopes: ['faith'], valueType: 'comparison' },
  { name: 'faith_hostility_level', description: 'What is the faith\'s hostility level towards the target faith? faith_hostility_level { target = scope:some_faith value > 1 }', supportedScopes: ['faith'], valueType: 'comparison' },
  { name: 'faith_hostility_level_comparison', description: 'Compares the scoped faith\'s hostility level towards two other faiths. faith_hostility_level_comparison { faith1 > faith2 }', supportedScopes: ['faith'] },
  { name: 'fervor', description: 'What is the faith\'s fervor?', supportedScopes: ['faith'], valueType: 'comparison' },
  { name: 'has_allowed_gender_for_clergy', description: 'Is the target character of the allowed gender to be clergy of the faith?', supportedScopes: ['faith'] },
  { name: 'has_doctrine', description: 'Does the given faith have the given doctrine?? has_doctrine = doctrine_key', supportedScopes: ['faith'], supportedTargets: ['doctrine'] },
  { name: 'has_doctrine_parameter', description: 'Does the given faith have the given doctrine parameter? Can only check for bool parameters. has_doctrine_parameter = parameter_key', supportedScopes: ['faith'] },
  { name: 'has_dominant_ruling_gender', description: 'Is the target character\'s gender a dominant ruling gender of the faith? Also evaluates to true if there\'s no dominant ruling gender', supportedScopes: ['faith'] },
  { name: 'has_graphical_faith', description: 'Does the faith have this graphical faith?', supportedScopes: ['faith'], syntax: "<faith> = { has_graphical_faith = orthodoxgfx }" },
  { name: 'has_icon', description: 'Does the faith have the given icon', supportedScopes: ['faith'], syntax: "has_icon = some_cool_custom_icon" },
  { name: 'has_preferred_gender_for_clergy', description: 'Is the target character of the preferred gender to be clergy of the faith?', supportedScopes: ['faith'] },
  { name: 'holy_sites_controlled', description: 'How many holy sites does the faith control? holy_sites_controlled > 1', supportedScopes: ['faith'], valueType: 'comparison' },
  { name: 'num_character_followers', description: 'Returns how many characters follow the given faith', supportedScopes: ['faith'], valueType: 'comparison', syntax: "num_character_followers > 0" },
  { name: 'num_county_followers', description: 'Returns how many counties follow the given faith', supportedScopes: ['faith'], valueType: 'comparison', syntax: "num_county_followers > 0" },
  { name: 'religion_tag', description: 'checks the tag of the religion of the current faith', supportedScopes: ['faith'] },
  { name: 'trait_is_sin', description: 'Does the scoped faith consider the given trait a sin?', supportedScopes: ['faith'], supportedTargets: ['trait'], syntax: "trait_is_sin = lustful" },
  { name: 'trait_is_virtue', description: 'Does the scoped faith consider the given trait a virtue?', supportedScopes: ['faith'], supportedTargets: ['trait'], syntax: "trait_is_virtue = lustful" },
];

/**
 * Triggers for religion scope (1 triggers)
 */
export const religionTriggers: TriggerDefinition[] = [
  { name: 'any_faith', description: 'Iterate through all faiths within a religion', supportedScopes: ['religion'], supportedTargets: ['faith'], outputScope: 'faith', isIterator: true, valueType: 'block', syntax: "any_faith = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
];

/**
 * Triggers for army scope (20 triggers)
 */
export const armyTriggers: TriggerDefinition[] = [
  { name: 'any_army_maa_regiment', description: 'Iterate through all MaA regiments in the army', supportedScopes: ['army'], supportedTargets: ['regiment'], outputScope: 'regiment', isIterator: true, valueType: 'block', syntax: "scope:army = {\nany_army_maa_regiment = {\ninclude_hired = yes # should it include merc and holy order regiments (yes by default)\n}\n}\nany_army_maa_regiment = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['include_hired', 'count', 'percent'] },
  { name: 'army_is_moving', description: 'is this army moving?', supportedScopes: ['army'], valueType: 'boolean' },
  { name: 'army_max_size', description: 'what size is this army\'s max size?', supportedScopes: ['army'], valueType: 'comparison' },
  { name: 'army_size', description: 'what size is this army?', supportedScopes: ['army'], valueType: 'comparison' },
  { name: 'army_supply', description: 'Can we disband this army?', supportedScopes: ['army'], valueType: 'comparison' },
  { name: 'barter_loot', description: 'How much barter loot is the army carrying?', supportedScopes: ['army'], valueType: 'comparison' },
  { name: 'can_disband_army', description: 'Can we disband this army?', supportedScopes: ['army'], valueType: 'boolean' },
  { name: 'is_army_in_combat', description: 'Is the scoped army in combat?', supportedScopes: ['army'], valueType: 'boolean' },
  { name: 'is_army_in_raid', description: 'Is the scoped army in a raid (this includes a raid interrupted by combat)?', supportedScopes: ['army'], valueType: 'boolean' },
  { name: 'is_army_in_siege', description: 'Is the scoped army in a siege (this includes a siege interrupted by combat)?', supportedScopes: ['army'], valueType: 'boolean' },
  { name: 'is_army_in_siege_relevant_for', description: 'Is the scoped army in a siege that is relevant to the target character?', supportedScopes: ['army'], supportedTargets: ['character'], syntax: "is_army_in_siege_relevant_for = scope:character" },
  { name: 'is_barter_army', description: 'Is the scoped army a barter army?', supportedScopes: ['army'], valueType: 'boolean' },
  { name: 'is_raid_army', description: 'Is the scoped army a raid army?', supportedScopes: ['army'], valueType: 'boolean' },
  { name: 'raid_intent', description: 'Does the Army have the given raid intent?', supportedScopes: ['army'], syntax: "raid_intent = key" },
  { name: 'raid_loot', description: 'How much raid loot is the army carrying?', supportedScopes: ['army'], valueType: 'comparison' },
  { name: 'total_army_damage', description: 'What is the army\'s total damage stat in its current location?', supportedScopes: ['army'], valueType: 'comparison' },
  { name: 'total_army_pursuit', description: 'What is the army\'s total pursuit stat in its current location?', supportedScopes: ['army'], valueType: 'comparison' },
  { name: 'total_army_screen', description: 'What is the army\'s total screen stat in its current location?', supportedScopes: ['army'], valueType: 'comparison' },
  { name: 'total_army_siege_value', description: 'What is the army\'s total siege value stat in its current location?', supportedScopes: ['army'], valueType: 'comparison' },
  { name: 'total_army_toughness', description: 'What is the army\'s total toughness stat in its current location?', supportedScopes: ['army'], valueType: 'comparison' },
];

/**
 * Triggers for scheme scope (24 triggers)
 */
export const schemeTriggers: TriggerDefinition[] = [
  { name: 'any_scheme_agent_character', description: 'Iterate through all characters in agent slots in the scheme', supportedScopes: ['scheme'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_scheme_agent_character = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_scheme_agent_slot', description: 'Iterate through all agent slots in the scheme', supportedScopes: ['scheme'], supportedTargets: ['agent_slot'], outputScope: 'agent_slot', isIterator: true, valueType: 'block', syntax: "any_scheme_agent_slot = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'has_scheme_modifier', description: 'Is the scheme currently affected by the specified modifier? has_scheme_modifier = X', supportedScopes: ['scheme'] },
  { name: 'is_hostile', description: 'Is the scoped scheme a hostile scheme?', supportedScopes: ['scheme'], valueType: 'boolean', syntax: "is_hostile = bool" },
  { name: 'is_scheme_agent_exposed', description: 'Is the target character an exposed agent in the scope scheme?', supportedScopes: ['scheme'] },
  { name: 'is_scheme_category', description: 'Does the scheme have the given category?', supportedScopes: ['scheme'], syntax: "Supported categories: 'hostile', 'contract', and 'personal'.\nis_scheme_category = <category>" },
  { name: 'is_scheme_exposed', description: 'Is the scheme exposed?', supportedScopes: ['scheme'], valueType: 'boolean' },
  { name: 'is_scheme_target_type', description: 'Does the scheme have a target of the given type?', supportedScopes: ['scheme'], syntax: "Supported types: character, title, faith, culture\nis_scheme_target_type = <type>" },
  { name: 'is_type_basic', description: 'Is the scoped scheme\'s type a basic type?', supportedScopes: ['scheme'], valueType: 'boolean', syntax: "is_type_basic = bool" },
  { name: 'is_type_secret', description: 'Is the scoped scheme\'s type a secret type?', supportedScopes: ['scheme'], valueType: 'boolean', syntax: "is_type_secret = bool" },
  { name: 'max_scheme_success_chance', description: 'Max Scheme Success Chance', supportedScopes: ['scheme'], valueType: 'comparison' },
  { name: 'maximum_scheme_breaches', description: 'The maximum number of breaches the scheme can have', supportedScopes: ['scheme'], valueType: 'comparison' },
  { name: 'scheme_agent_charges', description: 'The number of the scheme\'s currently available agent charges', supportedScopes: ['scheme'], valueType: 'comparison' },
  { name: 'scheme_breaches', description: 'The number of breaches the scheme currently has', supportedScopes: ['scheme'], valueType: 'comparison' },
  { name: 'scheme_duration_days', description: 'The number of days since scheme was started', supportedScopes: ['scheme'], valueType: 'comparison' },
  { name: 'scheme_is_character_agent', description: 'Is the target character part of this scheme?', supportedScopes: ['scheme'] },
  { name: 'scheme_number_of_exposed_agents', description: 'The number of exposed agents in a scheme', supportedScopes: ['scheme'], valueType: 'comparison' },
  { name: 'scheme_number_of_filled_agent_slots', description: 'The number of agents in a scheme', supportedScopes: ['scheme'], valueType: 'comparison' },
  { name: 'scheme_phase_duration', description: 'Scheme phase duration', supportedScopes: ['scheme'], valueType: 'comparison' },
  { name: 'scheme_progress', description: 'Scheme progress (0 - 10 (defined))', supportedScopes: ['scheme'], valueType: 'comparison' },
  { name: 'scheme_secrecy', description: 'Scheme secrecy', supportedScopes: ['scheme'], valueType: 'comparison' },
  { name: 'scheme_skill', description: 'Is the scheme currently affected by the specified modifier? has_scheme_modifier = X', supportedScopes: ['scheme'] },
  { name: 'scheme_success_chance', description: 'Scheme success chance', supportedScopes: ['scheme'], valueType: 'comparison' },
  { name: 'scheme_type', description: 'Is the scheme of the specified type? scheme_type = X', supportedScopes: ['scheme'] },
];

/**
 * Triggers for war scope (17 triggers)
 */
export const warTriggers: TriggerDefinition[] = [
  { name: 'any_war_attacker', description: 'Iterate through all attackers in the war', supportedScopes: ['war'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_war_attacker = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_war_defender', description: 'Iterate through all defenders in the war', supportedScopes: ['war'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_war_defender = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_war_participant', description: 'Iterate through all participants in the war', supportedScopes: ['war'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_war_participant = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'attacker_war_score', description: 'compares the attacker war score', supportedScopes: ['war'], valueType: 'comparison' },
  { name: 'days_since_max_war_score', description: 'Number of days since the war score has been at max (+100 or -100). Returns -1 if the war score is not +100 or -100', supportedScopes: ['war'], valueType: 'comparison' },
  { name: 'defender_war_score', description: 'compares the defender war score', supportedScopes: ['war'], valueType: 'comparison' },
  { name: 'has_valid_casus_belli', description: 'does the war interaction still have a valid casus belli (those should be automatically removed on daily tick, but can exist for a tick)', supportedScopes: ['war'], valueType: 'boolean' },
  { name: 'is_attacker', description: 'is the target character in the scope war as an attacker?', supportedScopes: ['war'] },
  { name: 'is_civil_war', description: 'Check if the scope war is a civil war or not', supportedScopes: ['war'], valueType: 'boolean' },
  { name: 'is_defender', description: 'is the target character in the scope war as a defender?', supportedScopes: ['war'] },
  { name: 'is_participant', description: 'is the target character participating in the scope war as an attacker or defender?', supportedScopes: ['war'] },
  { name: 'is_war_leader', description: 'is the target character leading one of the sides in the scope war?', supportedScopes: ['war'] },
  { name: 'is_white_peace_possible', description: 'Check if the scoped war\'s CB has is_white_peace_possible = yes', supportedScopes: ['war'], valueType: 'boolean' },
  { name: 'using_cb', description: 'is the scope war using the specified CB? using_cb = religious_war', supportedScopes: ['war'] },
  { name: 'war_contribution', description: 'Checks how much a character has contributed to the scoped war', supportedScopes: ['war'], valueType: 'comparison', syntax: "war_contribution = {\ntarget = some character\nvalue > 5\n}", parameters: ['target'] },
  { name: 'war_days', description: 'compares the number of days the war is going on for', supportedScopes: ['war'], valueType: 'comparison' },
  { name: 'was_called', description: 'has the target character been called to the scope war already?', supportedScopes: ['war'] },
];

/**
 * Triggers for activity scope (23 triggers)
 */
export const activityTriggers: TriggerDefinition[] = [
  { name: 'any_activity_phase_location', description: 'Iterate through all province locations of the phases of the activity, optionally limited to unique locations.', supportedScopes: ['activity'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, valueType: 'block', syntax: "any/every/random_activity_phase_location {\nunique = yes/no\n}\nany_activity_phase_location = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['unique', 'count', 'percent'] },
  { name: 'any_activity_phase_location_future', description: 'Iterate through all future province locations of the phases of the activity, optionally limited to unique locations. (\'future\' does not include any started phase)', supportedScopes: ['activity'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, valueType: 'block', syntax: "any/every/random_activity_phase_location_future {\nunique = yes/no\n}\nany_activity_phase_location_future = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['unique', 'count', 'percent'] },
  { name: 'any_activity_phase_location_past', description: 'Iterate through all past province locations of the phases of the activity, optionally limited to unique locations. (\'past\' only includes ended phases)', supportedScopes: ['activity'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, valueType: 'block', syntax: "any/every/random_activity_phase_location_future {\nunique = yes/no\n}\nany_activity_phase_location_past = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['unique', 'count', 'percent'] },
  { name: 'any_attending_character', description: 'Iterate through all characters attending an activity.', supportedScopes: ['activity'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "Invited guests that have not accepted/declined yet are not part of this list.\nSupports an optional state the character must be in.\nany_attending_character = { state = travel/passive/active }\nany_attending_character = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_guest_subset', description: 'any/every/random_guest_subset = {', supportedScopes: ['activity'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "name = <subset_key>\nphase = <phase_key> # Optional\n}\nIterates through characteres within the specified subset for past, current and\nfuture phases. If phase is specified it will only iterate through characters\nsubsets of that particular phase type.\nany_guest_subset = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['name', 'phase', 'count', 'percent'] },
  { name: 'any_guest_subset_current_phase', description: 'any/every/random_guest_subset_current_phase = {', supportedScopes: ['activity'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "name = <subset_key>\n}\nIterates through characteres within the specified subset of the current phase.\nany_guest_subset_current_phase = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['name', 'count', 'percent'] },
  { name: 'any_invited_character', description: 'Iterate through all characters invited to an activity. Once they accept/decline, they are removed from this list.', supportedScopes: ['activity'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_invited_character = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_special_guest', description: 'Iterate through all special guests of an activity.', supportedScopes: ['activity'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_special_guest = { ... }\nany_special_guest = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'has_active_locale', description: 'Does the scoped activity have the designated locale active?', supportedScopes: ['activity'], syntax: "has_active_locale = locale_key" },
  { name: 'has_activity_option', description: 'has_activity_option = { category = key option = key }', supportedScopes: ['activity'], syntax: "Does the scoped activity have the option in the given category active" },
  { name: 'has_activity_type', description: 'has_activity_type = key', supportedScopes: ['activity'], supportedTargets: ['activity_type'], syntax: "Does the scoped activity have the given activity type" },
  { name: 'has_current_phase', description: 'has_current_phase = key', supportedScopes: ['activity'], syntax: "Does the scoped activity have the given phase active" },
  { name: 'has_phase', description: 'Check if a phase exists on this activity. You can search for just a type directly, or a complex trigger with  only `type`, `location` or both.', supportedScopes: ['activity'], syntax: "has_phase = name_of_phase\nhas_phase = {\ntype = name_of_phase\nlocation = scope:province\n}", parameters: ['type', 'location'] },
  { name: 'has_phase_future', description: 'Check if a past phase exists on this activity. You can search for just a type directly, or a complex trigger with  only `type`, `location` or both.', supportedScopes: ['activity'], syntax: "has_phase = name_of_phase\nhas_phase = {\ntype = name_of_phase\nlocation = scope:province\n}", parameters: ['has_phase', 'type', 'location'] },
  { name: 'has_phase_past', description: 'Check if a past phase exists on this activity. You can search for just a type directly, or a complex trigger with  only `type`, `location` or both.', supportedScopes: ['activity'], syntax: "has_phase = name_of_phase\nhas_phase = {\ntype = name_of_phase\nlocation = scope:province\n}", parameters: ['has_phase', 'type', 'location'] },
  { name: 'is_activity_complete', description: 'Check if the current activity is completed or not, this doesn\'t have much use for content since we delete an activity as soon as we can, but in multiplayer it exists until everyone stops viewing it so we use this to cancel some delayed events', supportedScopes: ['activity'], valueType: 'boolean', syntax: "is_activity_complete = yes/no" },
  { name: 'is_current_phase_active', description: 'Check if the current activity phase is in the active state (else it is in the passive state)', supportedScopes: ['activity'], valueType: 'boolean', syntax: "is_current_phase_active = yes/no" },
  { name: 'is_open_invite_activity', description: 'Check if the scoped activity is an open invite activity', supportedScopes: ['activity'], valueType: 'boolean', syntax: "is_open_invite_activity = yes/no" },
  { name: 'is_required_special_guest', description: 'Is the target character a required special guest in the scoped activity.', supportedScopes: ['activity'], syntax: "is_required_special_guest = character" },
  { name: 'is_special_guest', description: 'Is the target character a special guest in the scoped activity, optionally for a specific type.', supportedScopes: ['activity'], syntax: "is_special_guest = character\nis_special_guest = { target = character type = key }" },
  { name: 'num_future_phases', description: 'The number of future phases for the scoped activity.', supportedScopes: ['activity'], valueType: 'comparison', syntax: "num_future_phases > 5" },
  { name: 'num_past_phases', description: 'The number of past phases for the scoped activity.', supportedScopes: ['activity'], valueType: 'comparison', syntax: "num_past_phases > 5" },
  { name: 'num_phases', description: 'The number total number of planned phases for the scoped activity.', supportedScopes: ['activity'], valueType: 'comparison', syntax: "num_phases > 5" },
];

/**
 * Triggers for artifact scope (16 triggers)
 */
export const artifactTriggers: TriggerDefinition[] = [
  { name: 'any_artifact_claimant', description: 'Iterate through all characters with a claim on the scoped artifact', supportedScopes: ['artifact'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_artifact_claimant = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_artifact_house_claimant', description: 'Iterate through all dynasty houses with a claim on the scoped artifact', supportedScopes: ['artifact'], supportedTargets: ['dynasty_house'], outputScope: 'dynasty_house', isIterator: true, valueType: 'block', syntax: "any_artifact_house_claimant = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'artifact_durability', description: 'does this artifact have the required durability?', supportedScopes: ['artifact'], valueType: 'comparison' },
  { name: 'artifact_max_durability', description: 'does this artifact have the required max durability?', supportedScopes: ['artifact'], valueType: 'comparison' },
  { name: 'artifact_slot_type', description: 'is the artifact of the given inventory slot type?', supportedScopes: ['artifact'] },
  { name: 'artifact_type', description: 'is the artifact of the given type?', supportedScopes: ['artifact'] },
  { name: 'can_be_claimed_by', description: 'Can the scoped artifact be claimed by the given character?', supportedScopes: ['artifact'], supportedTargets: ['character'] },
  { name: 'category', description: 'is the scoped artifact of given category?', supportedScopes: ['artifact'] },
  { name: 'has_artifact_feature', description: 'Does the artifact have the given feature?', supportedScopes: ['artifact'], syntax: "has_artifact_feature = key" },
  { name: 'has_artifact_feature_group', description: 'Does the artifact have the given feature group?', supportedScopes: ['artifact'], syntax: "has_artifact_feature_group = key" },
  { name: 'has_artifact_modifier', description: 'Does the artifact have the given modifier?', supportedScopes: ['artifact'], syntax: "has_artifact_modifier  = key" },
  { name: 'is_equipped', description: 'is the scoped artifact currently equipped in its owners inventory?', supportedScopes: ['artifact'], valueType: 'boolean' },
  { name: 'is_unique', description: 'Is the scoped artifact unique', supportedScopes: ['artifact'], valueType: 'boolean', syntax: "defined in the scripted template of the artifact" },
  { name: 'num_artifact_kills', description: 'How many kills has this artifact been used in?', supportedScopes: ['artifact'], valueType: 'comparison' },
  { name: 'rarity', description: 'is the scoped artifact of given rarity?', supportedScopes: ['artifact'] },
  { name: 'should_decay', description: 'should the scoped artifact decay with time?', supportedScopes: ['artifact'], valueType: 'boolean' },
];

/**
 * Triggers for secret scope (11 triggers)
 */
export const secretTriggers: TriggerDefinition[] = [
  { name: 'any_secret_knower', description: 'Iterate through all characters who know the secret', supportedScopes: ['secret'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_secret_knower = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_secret_participant', description: 'Iterate through participants in a secret', supportedScopes: ['secret'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_secret_participant = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'can_be_exposed_by', description: 'can the scope secret be exposed by the target character? can_be_exposed_by = target', supportedScopes: ['secret'] },
  { name: 'is_criminal_for', description: 'is this secret criminal for the target participant? is_criminal_for = <character>', supportedScopes: ['secret'], supportedTargets: ['character'] },
  { name: 'is_known_by', description: 'is the scope secret known by the target character?', supportedScopes: ['secret'] },
  { name: 'is_shunned_for', description: 'is this secret shunned for the target participant? is_shunned_for = <character>', supportedScopes: ['secret'], supportedTargets: ['character'] },
  { name: 'is_shunned_or_criminal_for', description: 'is this secret shunned or criminal for the target participant? is_shunned_or_illegal_for = <character>', supportedScopes: ['secret'], supportedTargets: ['character'] },
  { name: 'is_spent_by', description: 'has the scope secret been spent by the target character? is_spent_by = target', supportedScopes: ['secret'] },
  { name: 'local_player_knows_this_secret', description: 'Does the local player have knowledge about the secret?', supportedScopes: ['secret'], valueType: 'boolean', syntax: "An interface trigger, can only be used in specific places" },
  { name: 'same_secret_type_as', description: 'Is the scope secret of the same type as the target secret?', supportedScopes: ['secret'], supportedTargets: ['secret'], syntax: "same_secret_type_as = scope:some_secret" },
  { name: 'secret_type', description: 'Is the scope secret of the specified type?', supportedScopes: ['secret'] },
];

/**
 * Triggers for faction scope (16 triggers)
 */
export const factionTriggers: TriggerDefinition[] = [
  { name: 'any_faction_county_member', description: 'Iterate through all faction county members', supportedScopes: ['faction'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_faction_county_member = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_faction_member', description: 'Iterate through all faction character members', supportedScopes: ['faction'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_faction_member = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'average_faction_opinion', description: 'Average opinion of all the characters of the faction scope target', supportedScopes: ['faction'], valueType: 'comparison' },
  { name: 'average_faction_opinion_not_powerful_vassal', description: 'Average opinion of the character that are NOT powerful vassals of the faction scope target', supportedScopes: ['faction'], valueType: 'comparison' },
  { name: 'average_faction_opinion_powerful_vassal', description: 'Average opinion of the character that are powerful vassals of the faction scope target', supportedScopes: ['faction'], valueType: 'comparison' },
  { name: 'discontent_per_month', description: 'How much is the Faction\'s Discontent increasing each month?', supportedScopes: ['faction'], valueType: 'comparison' },
  { name: 'faction_can_press_demands', description: 'Can the scope faction press demands?', supportedScopes: ['faction'], valueType: 'boolean' },
  { name: 'faction_discontent', description: 'Current discontent of the faction', supportedScopes: ['faction'], valueType: 'comparison' },
  { name: 'faction_is_at_war', description: 'Is the scope faction at war?', supportedScopes: ['faction'], valueType: 'boolean' },
  { name: 'faction_is_type', description: 'Is the faction of this type?', supportedScopes: ['faction'] },
  { name: 'faction_power', description: 'Current power of the faction', supportedScopes: ['faction'], valueType: 'comparison' },
  { name: 'faction_power_threshold', description: 'Current power threshold of the faction', supportedScopes: ['faction'], valueType: 'comparison' },
  { name: 'has_special_character', description: 'Has the faction a special character assigned?', supportedScopes: ['faction'], valueType: 'boolean' },
  { name: 'has_special_title', description: 'Has the faction a special title assigned?', supportedScopes: ['faction'], valueType: 'boolean' },
  { name: 'months_until_max_discontent', description: 'How many months until Discontent is max (100)?', supportedScopes: ['faction'], valueType: 'comparison' },
  { name: 'number_of_faction_members_in_council', description: 'Current number of faction members in faction', supportedScopes: ['faction'], valueType: 'comparison' },
];

/**
 * Triggers for holy_order scope (2 triggers)
 */
export const holyorderTriggers: TriggerDefinition[] = [
  { name: 'any_leased_title', description: 'Iterate through all titles leased to a holy order', supportedScopes: ['holy_order'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_leased_title = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'num_leased_titles', description: 'How many holdings the holy order has under lease', supportedScopes: ['holy_order'], valueType: 'comparison' },
];

/**
 * Triggers for mercenary_company scope (1 triggers)
 */
export const mercenarycompanyTriggers: TriggerDefinition[] = [
  { name: 'mercenary_company_expiration_days', description: 'How many days are left in the mercenary contract. 0 if not hired.', supportedScopes: ['mercenary_company'], valueType: 'comparison' },
];

/**
 * Triggers for inspiration scope (6 triggers)
 */
export const inspirationTriggers: TriggerDefinition[] = [
  { name: 'base_inspiration_gold_cost', description: 'base_inspiration_gold_cost > 5', supportedScopes: ['inspiration'], valueType: 'comparison', syntax: "Gets the base gold cost of the scoped inspiration" },
  { name: 'days_since_creation', description: 'days_since_creation > 5', supportedScopes: ['inspiration'], valueType: 'comparison', syntax: "Gets the days since creation of the scoped inspiration" },
  { name: 'days_since_sponsorship', description: 'days_since_sponsorship > 5', supportedScopes: ['inspiration'], valueType: 'comparison', syntax: "Gets the days since sponsorship started of the scoped inspiration" },
  { name: 'has_inspiration_type', description: 'has_inspiration_type = type', supportedScopes: ['inspiration'], syntax: "Checks if the scoped inspiration has the given inspiration database type" },
  { name: 'inspiration_gold_invested', description: 'inspiration_gold_invested > 5', supportedScopes: ['inspiration'], valueType: 'comparison', syntax: "Gets the amount of gold invested in the scoped inspiration" },
  { name: 'inspiration_progress', description: 'inspiration_progress > 5', supportedScopes: ['inspiration'], valueType: 'comparison', syntax: "Gets the progress of the scoped inspiration" },
];

/**
 * Triggers for story scope (1 triggers)
 */
export const storyTriggers: TriggerDefinition[] = [
  { name: 'story_type', description: 'Is the story in scope of this type?', supportedScopes: ['story'] },
];

/**
 * Triggers for casus_belli scope (1 triggers)
 */
export const casusbelliTriggers: TriggerDefinition[] = [
  { name: 'any_target_title', description: 'Iterate through all casus belli\'s target titles', supportedScopes: ['casus_belli'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_target_title = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
];

/**
 * Triggers for travel_plan scope (27 triggers)
 */
export const travelplanTriggers: TriggerDefinition[] = [
  { name: 'any_entourage_character', description: 'Iterate through all characters travelling along with the travel plan owner. Includes travel leader, but not the travel plan owner.', supportedScopes: ['travel_plan'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_entourage_character = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_future_path_location', description: 'Iterate through all provinces this travel plan has in its route.', supportedScopes: ['travel_plan'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, valueType: 'block', syntax: "any_future_path_location = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_visited_location', description: 'Iterate through all provinces this travel plan has arrived at so far.', supportedScopes: ['travel_plan'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, valueType: 'block', syntax: "any_visited_location = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'can_cancel', description: 'Can this travel plan be cancelled? (associated activity might disallow it)', supportedScopes: ['travel_plan'], valueType: 'boolean' },
  { name: 'current_danger_value', description: 'Danger value of the current province the travel plan is in (-100.0 to +100.0).', supportedScopes: ['travel_plan'], valueType: 'comparison' },
  { name: 'days_travelled', description: 'Total number of days since this travel plan started.', supportedScopes: ['travel_plan'], valueType: 'comparison' },
  { name: 'departure_date', description: 'Compare the date the travel plan started.', supportedScopes: ['travel_plan'], valueType: 'comparison' },
  { name: 'final_destination_arrival_date', description: 'Estimation date of arrival at the final destination', supportedScopes: ['travel_plan'], valueType: 'comparison' },
  { name: 'final_destination_arrival_days', description: 'Estimation of days until we arrive at the final destination?', supportedScopes: ['travel_plan'], valueType: 'comparison' },
  { name: 'final_destination_progress', description: 'Time progress (0.0 - 1.0) towards the final destination of the travel plan, compared to departure date from the very start of the Travel Plan.', supportedScopes: ['travel_plan'], valueType: 'comparison' },
  { name: 'has_travel_option', description: 'Does the travel plan have this travel option active?', supportedScopes: ['travel_plan'], syntax: "<travel_plan> = { has_travel_option = name }" },
  { name: 'has_travel_plan_modifier', description: 'Does the scoped travel plan have a given modifier', supportedScopes: ['travel_plan'], syntax: "has_travel_plan_modifier = name" },
  { name: 'has_travel_plan_modifier_duration_remaining', description: 'Does the scoped travel plan have the duration remaining on a given modifier', supportedScopes: ['travel_plan'], syntax: "nhas_county_modifier_duration_remaining = name", parameters: ['nhas_county_modifier_duration_remaining'] },
  { name: 'is_aborted', description: 'Is this travel plan aborted?', supportedScopes: ['travel_plan'], valueType: 'boolean' },
  { name: 'is_cancelled', description: 'Is this travel plan cancelled? (manually stopped, and rerouted home)', supportedScopes: ['travel_plan'], valueType: 'boolean' },
  { name: 'is_completed', description: 'Is this travel plan completed? (finished by arrival at final destination)', supportedScopes: ['travel_plan'], valueType: 'boolean' },
  { name: 'is_paused', description: 'Is this travel plan paused?', supportedScopes: ['travel_plan'], valueType: 'boolean' },
  { name: 'is_travel_with_domicile', description: 'Is character travelling with a domicile?', supportedScopes: ['travel_plan'], valueType: 'boolean', syntax: "<travel_plan> = { is_travel_with_domicile = yes }" },
  { name: 'next_destination_arrival_date', description: 'Estimation date of arrival at the next destination', supportedScopes: ['travel_plan'], valueType: 'comparison' },
  { name: 'next_destination_arrival_days', description: 'Estimation of days until we arrive at the next destination', supportedScopes: ['travel_plan'], valueType: 'comparison' },
  { name: 'next_destination_progress', description: 'Time progress (0.0 - 1.0) towards the next destination of the travel plan, compared to departure date of the previous destination.', supportedScopes: ['travel_plan'], valueType: 'comparison' },
  { name: 'num_entourage_characters', description: 'Size of the travel plan entourage.', supportedScopes: ['travel_plan'], valueType: 'comparison' },
  { name: 'num_options', description: 'Number of travel options selected.', supportedScopes: ['travel_plan'], valueType: 'comparison' },
  { name: 'travel_safety', description: 'Gets the current travel safety for travel', supportedScopes: ['travel_plan'], valueType: 'comparison' },
  { name: 'travel_speed', description: 'Gets the current travel speed for travel (percentage points above 100%)', supportedScopes: ['travel_plan'], valueType: 'comparison' },
  { name: 'was_activity_completed', description: 'If there is/was an activity attached to this travel plan, was it completed?', supportedScopes: ['travel_plan'], valueType: 'boolean' },
  { name: 'was_activity_invalidated', description: 'If there is/was an activity attached to this travel plan, was it invalidated?', supportedScopes: ['travel_plan'], valueType: 'boolean' },
];

/**
 * Triggers for council_task scope (1 triggers)
 */
export const counciltaskTriggers: TriggerDefinition[] = [
  { name: 'can_fire_position', description: 'Check if the scope task\'s councillor can be fired. Will check both can_fire and things like it being illegal to reassing the position', supportedScopes: ['council_task'], valueType: 'boolean', syntax: "scope:task = { position_can_be_fired = yes }" },
];

/**
 * Triggers for struggle scope (9 triggers)
 */
export const struggleTriggers: TriggerDefinition[] = [
  { name: 'any_interloper_ruler', description: 'Iterate through all characters that are interloper in a struggle.', supportedScopes: ['struggle'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_interloper_ruler = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_involved_county', description: 'Iterate through all counties that are involved in a struggle', supportedScopes: ['struggle'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_involved_county = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_involved_ruler', description: 'Iterate through all characters that are involved in a struggle.', supportedScopes: ['struggle'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_involved_ruler = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'has_struggle_phase_parameter', description: 'Does the given struggle\'s current phase have the given parameter? Can only check for bool parameters. has_struggle_phase_parameter = parameter_key', supportedScopes: ['struggle'] },
  { name: 'is_culture_involved_in_struggle', description: 'is the culture involved in struggle?', supportedScopes: ['struggle'], supportedTargets: ['culture'], syntax: "is_culture_involved_in_struggle = culture:english" },
  { name: 'is_faith_involved_in_struggle', description: 'is the faith involved in struggle?', supportedScopes: ['struggle'], supportedTargets: ['faith'], syntax: "is_faith_involved_in_struggle  = faith:baltic_pagan" },
  { name: 'is_struggle_phase', description: 'is the scope struggle\'s current phase particular phase?', supportedScopes: ['struggle'], syntax: "is_struggle_phase = struggle_iberia_phase_opportunity" },
  { name: 'is_struggle_type', description: 'is the scope struggle\'s type particular type?', supportedScopes: ['struggle'], syntax: "is_struggle_type = iberian_struggle" },
  { name: 'phase_has_catalyst', description: 'Is any of the future phases affected by the given catalyst?phase_has_catalyst = catalyst_key', supportedScopes: ['struggle'] },
];

/**
 * Triggers for legend scope (16 triggers)
 */
export const legendTriggers: TriggerDefinition[] = [
  { name: 'any_legend_promoter', description: 'Gets all promoters of the scoped legend', supportedScopes: ['legend'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_legend_promoter = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_spread_province', description: 'Gets all provinces the scoped legend has spread into', supportedScopes: ['legend'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, valueType: 'block', syntax: "any_spread_province = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'days_since_legend_completion', description: 'Days since when the legend was completed.', supportedScopes: ['legend'], valueType: 'comparison' },
  { name: 'days_since_legend_start_date', description: 'Days since when the legend was created.', supportedScopes: ['legend'], valueType: 'comparison' },
  { name: 'has_legend_chapter', description: 'Does the legend have the given localization key set for the named chapter.', supportedScopes: ['legend'], syntax: "has_legend_chapter = { name = opening localization_key = default_legend_opening }\nhas_legend_chapter = opening" },
  { name: 'has_legend_chronicle', description: 'Does the scoped legend have the specified legend chronicle.', supportedScopes: ['legend'], syntax: "has_legend_chronicle = beast_slayer" },
  { name: 'has_legend_county_modifier', description: 'Does the scoped legend have a given modifier affecting the counties', supportedScopes: ['legend'], syntax: "has_legend_county_modifier = name" },
  { name: 'has_legend_county_modifier_duration_remaining', description: 'Does the scoped legend have the duration remaining on a given modifier affecting the counties', supportedScopes: ['legend'], syntax: "has_legend_county_modifier_duration_remaining = name" },
  { name: 'has_legend_owner_modifier', description: 'Does the scoped legend have a given modifier affecting the owner', supportedScopes: ['legend'], syntax: "has_legend_owner_modifier = name" },
  { name: 'has_legend_owner_modifier_duration_remaining', description: 'Does the scoped legend have the duration remaining on a given modifier affecting the owner', supportedScopes: ['legend'], syntax: "has_legend_owner_modifier_duration_remaining = name" },
  { name: 'has_legend_province_modifier', description: 'Does the scoped legend have a given modifier affecting the provinces', supportedScopes: ['legend'], syntax: "has_legend_province_modifier = name" },
  { name: 'has_legend_province_modifier_duration_remaining', description: 'Does the scoped legend have the duration remaining on a given modifier affecting the provinces', supportedScopes: ['legend'], syntax: "has_legend_province_modifier_duration_remaining = name" },
  { name: 'is_legend_completed', description: 'Is the scoped legend completed?.', supportedScopes: ['legend'], valueType: 'boolean', syntax: "scope:legend = {\nis_legend_completed = yes\n}" },
  { name: 'legend_completion_date', description: 'Date when the legend was completed.', supportedScopes: ['legend'], valueType: 'comparison' },
  { name: 'legend_quality', description: 'Get the quality of this legend.', supportedScopes: ['legend'], syntax: "legend_quality = famed" },
  { name: 'legend_start_date', description: 'Date when the legend was created.', supportedScopes: ['legend'], valueType: 'comparison' },
];

/**
 * Triggers for accolade scope (8 triggers)
 */
export const accoladeTriggers: TriggerDefinition[] = [
  { name: 'accolade_rank', description: 'How many ranks does this Accolade have unlocked?', supportedScopes: ['accolade'], valueType: 'comparison', syntax: "accolade_rank > 2" },
  { name: 'has_accolade_category', description: 'Does any of the Accolades types have the given category flag?', supportedScopes: ['accolade'], syntax: "has_accolade_category = flag" },
  { name: 'has_accolade_parameter', description: 'Does any of the Accolades unlocked ranks have the given parameter flag?', supportedScopes: ['accolade'], syntax: "has_accolade_parameter = flag" },
  { name: 'has_accolade_type', description: 'Does the Accolade have the given type?', supportedScopes: ['accolade'], syntax: "has_accolade_type = key" },
  { name: 'has_potential_accolade_successors', description: 'Does the given Accolade\'s Owner have any character in their court ( including guests ) that could act as Successor of this Accolade if made into a Knight?', supportedScopes: ['accolade'], valueType: 'boolean' },
  { name: 'is_accolade_active', description: 'Is the scoped Accolade active, i.e. assinged by their Liege?', supportedScopes: ['accolade'], valueType: 'boolean' },
  { name: 'primary_tier', description: 'Is the scoped Accolade\'s primary type tier equal to?', supportedScopes: ['accolade'] },
  { name: 'secondary_tier', description: 'Is the scoped Accolade\'s secondary type tier equal to?', supportedScopes: ['accolade'] },
];

/**
 * Triggers for epidemic scope (5 triggers)
 */
export const epidemicTriggers: TriggerDefinition[] = [
  { name: 'any_infected_province', description: 'Gets all provinces infected by the scoped epidemic', supportedScopes: ['epidemic'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, valueType: 'block', syntax: "any_infected_province = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'days_since_outbreak_start', description: 'Number of days since the epidemic outbreak started.', supportedScopes: ['epidemic'], valueType: 'comparison', syntax: "days_since_outbreak_start >= 20" },
  { name: 'outbreak_intensity', description: 'Get the outbreak intensity of this epidemic.', supportedScopes: ['epidemic'], syntax: "outbreak_intensity = major" },
  { name: 'outbreak_start_date', description: 'Date when the epidemic outbreak began.', supportedScopes: ['epidemic'], valueType: 'comparison' },
  { name: 'total_infected_provinces', description: 'Get the total number of provinces infected over the lifetime of this epidemic.', supportedScopes: ['epidemic'], valueType: 'comparison', syntax: "total_infected_provinces >= 20" },
];

/**
 * Triggers for task_contract scope (6 triggers)
 */
export const taskcontractTriggers: TriggerDefinition[] = [
  { name: 'has_task_contract_group', description: 'Has task contract of the group', supportedScopes: ['task_contract'], syntax: "scope:character = { has_task_contract_group = group }" },
  { name: 'has_task_contract_type', description: 'has task contract with type', supportedScopes: ['task_contract'], syntax: "scope:task_contract = { has_task_contract_type = type_name }" },
  { name: 'is_criminal', description: 'Is the contract type of criminal nature?', supportedScopes: ['task_contract'], valueType: 'boolean' },
  { name: 'is_valid_to_keep', description: 'Is contract valid to keep?', supportedScopes: ['task_contract'], valueType: 'boolean' },
  { name: 'task_contract_tier', description: 'Tier value for task contract', supportedScopes: ['task_contract'], valueType: 'comparison', syntax: "scope:task_contract = { task_contract_tier = num }" },
  { name: 'time_since_contract_taken', description: 'Days since the task contract was accepted.', supportedScopes: ['task_contract'], valueType: 'comparison' },
];

/**
 * Triggers for situation scope (21 triggers)
 */
export const situationTriggers: TriggerDefinition[] = [
  { name: 'any_participant_group', description: 'Iterate through all participant groups of the situation (in all sub-regions)', supportedScopes: ['situation'], supportedTargets: ['situation_participant_group'], outputScope: 'situation_participant_group', isIterator: true, valueType: 'block', syntax: "any_participant_group = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_situation_county', description: 'Iterate through all counties that are involved in a situation', supportedScopes: ['situation'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_situation_county = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_situation_participant', description: 'Iterate through all characters that are participating in a situation.', supportedScopes: ['situation'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_situation_participant = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_situation_sub_region', description: 'Iterate through all sub-regions of a situation', supportedScopes: ['situation'], supportedTargets: ['situation_sub_region'], outputScope: 'situation_sub_region', isIterator: true, valueType: 'block', syntax: "any_situation_sub_region = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'has_situation_top_phase_parameter', description: 'Checks if top sub-region has phase parameter or not', supportedScopes: ['situation'], syntax: "has_situation_top_phase_parameter = parameter_key" },
  { name: 'is_manual_participant', description: 'Is this character considered a manual participant candidate in this situation?', supportedScopes: ['situation'], supportedTargets: ['character'], syntax: "is_manual_participant = yes/no" },
  { name: 'is_situation_unique', description: 'Is the type of scoped situation unique.', supportedScopes: ['situation'], valueType: 'boolean', syntax: "is_situation_unique = yes/no" },
  { name: 'situation_current_phase', description: 'Checks if situation current phase equals phase_type_key (will take first sub-region)', supportedScopes: ['situation'], syntax: "situation_current_phase = phase_type_key" },
  { name: 'situation_days_since_end_date', description: 'Days since when the situation was completed.', supportedScopes: ['situation'], valueType: 'comparison' },
  { name: 'situation_days_since_start_date', description: 'Days since the situation started.', supportedScopes: ['situation'], valueType: 'comparison' },
  { name: 'situation_end_date', description: 'Date when the situation was completed.', supportedScopes: ['situation'], valueType: 'comparison' },
  { name: 'situation_has_catalyst', description: 'Checks if any sub-region of the situation has any of their future phases affected by the given catalyst.', supportedScopes: ['situation'], syntax: "has_situation_top_catalyst = situation_catalyst_key", parameters: ['has_situation_top_catalyst'] },
  { name: 'situation_start_date', description: 'Date when the situation started.', supportedScopes: ['situation'], valueType: 'comparison' },
  { name: 'situation_top_has_catalyst', description: 'Checks if top sub-region of situation has any of the future phases affected by the given catalyst', supportedScopes: ['situation'], syntax: "has_situation_top_catalyst = situation_catalyst_key", parameters: ['has_situation_top_catalyst'] },
  { name: 'situation_top_has_county', description: 'Checks if top sub-region of situation contains county', supportedScopes: ['situation'], supportedTargets: ['province'], syntax: "situation_top_has_county = scope:county" },
  { name: 'situation_top_has_province', description: 'Checks if top sub-region of situation contains province', supportedScopes: ['situation'], supportedTargets: ['province'], syntax: "situation_top_has_province = scope:province" },
  { name: 'situation_top_phase_days_since_start_date', description: 'Days since the situation top phase started.', supportedScopes: ['situation'], valueType: 'comparison' },
  { name: 'situation_top_phase_days_until_end_date', description: 'Days until the situation top phase completes.', supportedScopes: ['situation'], valueType: 'comparison' },
  { name: 'situation_top_phase_end_date', description: 'Date when the situation top phase Ended.', supportedScopes: ['situation'], valueType: 'comparison' },
  { name: 'situation_top_phase_start_date', description: 'Date when the situation top phase started.', supportedScopes: ['situation'], valueType: 'comparison' },
  { name: 'situation_type', description: 'Is the scoped situation of a specific situation type?', supportedScopes: ['situation'], syntax: "situation_type = situation_key" },
];

/**
 * Triggers for situation_sub_region scope (15 triggers)
 */
export const situationsubregionTriggers: TriggerDefinition[] = [
  { name: 'any_situation_sub_region_county', description: 'Iterate through all counties of a situation sub-region (warning: not fast)', supportedScopes: ['situation_sub_region'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_situation_sub_region_county = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_situation_sub_region_geographical_region', description: 'Iterate through all geographical regions of a situation sub-region', supportedScopes: ['situation_sub_region'], supportedTargets: ['geographical_region'], outputScope: 'geographical_region', isIterator: true, valueType: 'block', syntax: "any_situation_sub_region_geographical_region = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_situation_sub_region_participant', description: 'Iterate through all characters that are participating in a situation, in a specific subregion', supportedScopes: ['situation_sub_region'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_situation_sub_region_participant = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_situation_sub_region_participant_group', description: 'Iterate through all participant groups of the situation sub-region', supportedScopes: ['situation_sub_region'], supportedTargets: ['situation_participant_group'], outputScope: 'situation_participant_group', isIterator: true, valueType: 'block', syntax: "any_situation_sub_region_participant_group = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'has_sub_region_phase_parameter', description: 'Checks if sub-region has phase parameter or not', supportedScopes: ['situation_sub_region'], syntax: "has_sub_region_phase_parameter = parameter_key" },
  { name: 'phase_takeover_duration_days', description: 'Checks the takeover days left of a future phase in this sub-region.', supportedScopes: ['situation_sub_region'], valueType: 'comparison', syntax: "phase_takeover_duration_days:future_phase_key <= scripted_value" },
  { name: 'phase_takeover_points', description: 'Checks the takeover points of a future phase in this sub-region.', supportedScopes: ['situation_sub_region'], valueType: 'comparison', syntax: "phase_takeover_points:future_phase_key <= scripted_value" },
  { name: 'situation_sub_region_has_county', description: 'Checks if scoped sub-region of a situation contains county', supportedScopes: ['situation_sub_region'], supportedTargets: ['landed_title'], syntax: "situation_sub_region_has_county = scope:county" },
  { name: 'situation_sub_region_has_geographical_region', description: 'Is geographical region part of situation sub-region?', supportedScopes: ['situation_sub_region'], supportedTargets: ['geographical_region'], syntax: "situation_sub_region_has_geographical_region = scope:geographical_region" },
  { name: 'situation_sub_region_has_province', description: 'Checks if scoped sub-region of a situation contains province', supportedScopes: ['situation_sub_region'], supportedTargets: ['province'], syntax: "situation_sub_region_has_province = scope:province" },
  { name: 'sub_region_current_phase', description: 'Checks if sub-region current phase equals phase_type', supportedScopes: ['situation_sub_region'], syntax: "sub_region_current_phase = phase_type" },
  { name: 'sub_region_current_phase_days_since_start_date', description: 'Days since the sub region current situation phase started.', supportedScopes: ['situation_sub_region'], valueType: 'comparison' },
  { name: 'sub_region_current_phase_days_until_end_date', description: 'Days until the sub region current situation phase ends.', supportedScopes: ['situation_sub_region'], valueType: 'comparison' },
  { name: 'sub_region_current_phase_end_date', description: 'Date when the sub region current situation phase ends.', supportedScopes: ['situation_sub_region'], valueType: 'comparison' },
  { name: 'sub_region_current_phase_start_date', description: 'Date when the sub region current situation phase started.', supportedScopes: ['situation_sub_region'], valueType: 'comparison' },
];

/**
 * Triggers for tax_slot scope (4 triggers)
 */
export const taxslotTriggers: TriggerDefinition[] = [
  { name: 'any_tax_slot_vassal', description: 'Iterates through all Vassals assigned to the scoped Tax Slot', supportedScopes: ['tax_slot'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_tax_slot_vassal = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'available_taxpayer_slots', description: 'How many slots for taxpayers are available in scoped tax slot?', supportedScopes: ['tax_slot'], valueType: 'comparison', syntax: "scope:tax_slot = { available_tax_player_slots > 2 }" },
  { name: 'has_tax_collector', description: 'has_tax_collector = yes', supportedScopes: ['tax_slot'], valueType: 'boolean', syntax: "Does the scoped Tax Slot have any Tax Collector employed?" },
  { name: 'is_active_obligation', description: 'Is this the current active tax obligation?', supportedScopes: ['tax_slot'], syntax: "scope:tax_slot = { is_active_obligation = obligation_key }" },
];

/**
 * Triggers for domicile scope (18 triggers)
 */
export const domicileTriggers: TriggerDefinition[] = [
  { name: 'domicile_building_has_free_internal_slot', description: 'Does scoped domicile have building with any free internal building slots?', supportedScopes: ['domicile'], syntax: "scope:domicile = { domicile_building_has_free_internal_slot = domicile building key }" },
  { name: 'domicile_uses_culture_and_faith', description: 'Does the scoped domicile use culture and faith?', supportedScopes: ['domicile'], valueType: 'boolean' },
  { name: 'domicile_uses_provisions', description: 'Does the scoped domicile use provisions?', supportedScopes: ['domicile'], valueType: 'boolean' },
  { name: 'external_domicile_building_slots', description: 'Total amount of external building slots for scoped domicile', supportedScopes: ['domicile'], valueType: 'comparison', syntax: "scope:domicile = { external_domicile_building_slots == 5 }" },
  { name: 'free_external_domicile_building_slots', description: 'Amount of free external building slots for scoped domicile', supportedScopes: ['domicile'], valueType: 'comparison', syntax: "scope:domicile = { free_external_domicile_building_slots < 1 }" },
  { name: 'has_domicile_building', description: 'Does scoped domicile have building of specified type?', supportedScopes: ['domicile'], syntax: "scope:domicile = { has_domicile_building = domicile building key }" },
  { name: 'has_domicile_building_or_higher', description: 'Does scoped domicile have building or one of its upgrades?', supportedScopes: ['domicile'], syntax: "scope:domicile = { has_domicile_building_or_higher = domicile building key }" },
  { name: 'has_domicile_construction', description: 'Is the scoped domicile currently constructing the specified building?', supportedScopes: ['domicile'], syntax: "scope:domicile = { has_domicile_construction = domicile building key }" },
  { name: 'has_domicile_parameter', description: 'Does scoped domicile have parameter in one or more of its buildings?', supportedScopes: ['domicile'], syntax: "scope:domicile = { has_domicile_parameter = parameter_name }" },
  { name: 'has_ongoing_domicile_construction', description: 'Does the scoped domicile have an ongoing construction?)', supportedScopes: ['domicile'], valueType: 'boolean', syntax: "scope:domicile = {\nhas_ongoing_domicile_construction = yes/no\n}" },
  { name: 'herd', description: 'does the scoped domicile have the required herd?', supportedScopes: ['domicile'], valueType: 'comparison' },
  { name: 'horde', description: 'what is the amount of currently raised horde (or potential horde if none are raised) of the scoped domicile?', supportedScopes: ['domicile'], valueType: 'comparison' },
  { name: 'is_domicile_type', description: 'Is the scoped domicile of domicile type?', supportedScopes: ['domicile'], syntax: "scope:domicile = { is_domicile_type = domicile_type_key }" },
  { name: 'max_herd', description: 'what is the herd limit of the scoped domicile?', supportedScopes: ['domicile'], valueType: 'comparison' },
  { name: 'max_provisions', description: 'does the scoped domicile have the required max provisions?', supportedScopes: ['domicile'], valueType: 'comparison' },
  { name: 'num_domicile_buildings', description: 'Amount of buildings constructed for scoped domicile', supportedScopes: ['domicile'], valueType: 'comparison', syntax: "scope:domicile = { num_domicile_buildings > 0 }" },
  { name: 'provision_cost_to_owner', description: 'Is the provision cost from the domicile\'s current location to it\'s owner.', supportedScopes: ['domicile'], valueType: 'comparison', syntax: "In order to calculate the cost we will operate in three stages:\n1. Check if the from and to provinces are direct neighbours.\n2. Check any travel plan the domicile owner might have and see if the from and\nto are part of the travel plan. This will require domicile's location to be\nthe first entry in the travel plan.\n3. Do a pathfind between the domicile and domicile owner's current location,\nusing that path for the cost.\nscope:domicile = {\nprovision_cost_to_owner < 100\n}" },
  { name: 'provisions', description: 'does the scoped domicile have the required provisions?', supportedScopes: ['domicile'], valueType: 'comparison' },
];

/**
 * Triggers for great_project scope (5 triggers)
 */
export const greatprojectTriggers: TriggerDefinition[] = [
  { name: 'any_contribution', description: 'Iterate through all Contributions of a given Great Project, regardless of whether they were funded or not.', supportedScopes: ['great_project'], supportedTargets: ['project_contribution'], outputScope: 'project_contribution', isIterator: true, valueType: 'block', syntax: "any_contribution = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'great_project_build_progress', description: 'The project\'s build progress in percentage (from 0 to 1). If the project is not being built this is 0.', supportedScopes: ['great_project'], valueType: 'comparison', syntax: "usage:\n<scope:great_project> = {\ngreat_project_build_progress > 0.5\n}" },
  { name: 'great_project_construction_phase_is', description: 'Compare against the current construction phase of this project.', supportedScopes: ['great_project'], syntax: "Possible values are:\n* planned = the project is gathering funds\n* in_progress = the project has started\n* completed = the project was completed\nusage:\n<scope:great_project> = {\ngreat_project_construction_phase = in_progress\n}", parameters: ['great_project_construction_phase'] },
  { name: 'great_project_days_to_completion', description: 'The number of days until the project is built, taking into account the current province holder for progress bonuses. If the project is not being built this is -1.', supportedScopes: ['great_project'], valueType: 'comparison', syntax: "usage:\n<scope:great_project> = {\ngreat_project_days_to_completion > 365\n}" },
  { name: 'great_project_type', description: 'Check if the project is of the given type. Use the key from the project definition to compare.', supportedScopes: ['great_project'], syntax: "usage:\n<scope:great_project> = {\ngreat_project_type = great_wall\n}" },
];

/**
 * Triggers for confederation scope (9 triggers)
 */
export const confederationTriggers: TriggerDefinition[] = [
  { name: 'any_confederation_member', description: 'Iterates through all member characters of the scoped confederation', supportedScopes: ['confederation'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_confederation_member = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_confederation_member_house', description: 'Iterates through all member houses of the scoped confederation', supportedScopes: ['confederation'], supportedTargets: ['dynasty_house'], outputScope: 'dynasty_house', isIterator: true, valueType: 'block', syntax: "any_confederation_member_house = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'cohesion', description: 'Current total cohesion of the confederation/bloc.', supportedScopes: ['confederation'], valueType: 'comparison' },
  { name: 'combined_military_strength', description: 'Current combined military power of the confederation/bloc.', supportedScopes: ['confederation'], valueType: 'comparison' },
  { name: 'has_cohesion', description: 'Does the confederation/bloc have a cohesion?', supportedScopes: ['confederation'], valueType: 'boolean' },
  { name: 'has_cohesion_level_parameter', description: 'Does current cohesion level of the given confederation/bloc have the given parameter?', supportedScopes: ['confederation'], syntax: "usage:\n<bloc> = {\nhas_house_power_parameter = <parameter_key>\n}", parameters: ['has_house_power_parameter'] },
  { name: 'has_leading_house', description: 'Does the confederation have a leading house?', supportedScopes: ['confederation'], valueType: 'boolean' },
  { name: 'is_house_based', description: 'Is the confederation house based? i.e bloc', supportedScopes: ['confederation'], valueType: 'boolean' },
  { name: 'member_count', description: 'Number of members in the scoped confederation', supportedScopes: ['confederation'], valueType: 'comparison' },
];

/**
 * Triggers for house_relation scope (3 triggers)
 */
export const houserelationTriggers: TriggerDefinition[] = [
  { name: 'any_relation_house', description: 'Iterate over both houses in the given relation', supportedScopes: ['house_relation'], supportedTargets: ['dynasty_house'], outputScope: 'dynasty_house', isIterator: true, valueType: 'block', syntax: "any_relation_house = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'has_house_relation_level', description: 'Does this house relation have the given level?', supportedScopes: ['house_relation'], syntax: "usage:\n<house_relation> = {\nhas_house_relation_level = <level>\n}" },
  { name: 'has_house_relation_parameter', description: 'Does this house relation have the given parameter?', supportedScopes: ['house_relation'], syntax: "usage:\n<house_relation> = {\nhas_house_relation_parameter = <parameter>\n}" },
];

/**
 * Triggers for agent_slot scope (4 triggers)
 */
export const agentslotTriggers: TriggerDefinition[] = [
  { name: 'agent_slot_contribution', description: 'The contribution value given by the scoped filled agent slot.', supportedScopes: ['agent_slot'], valueType: 'comparison' },
  { name: 'agent_slot_has_contribution_type', description: 'Does the agent slot have provide the given type of contribution?', supportedScopes: ['agent_slot'], syntax: "Supported types: 'secrecy', 'success_chance', 'success_chance_growth', 'success_chance_max' and 'speed'\nagent_slot_has_contribution_type = <type>" },
  { name: 'is_agent_slot_type', description: 'Does the Agent Slot have the given type?', supportedScopes: ['agent_slot'], syntax: "is_agent_slot_type = key" },
  { name: 'is_filled', description: 'Is this agent slot filled?', supportedScopes: ['agent_slot'], valueType: 'boolean' },
];

/**
 * Triggers for none scope (156 triggers)
 */
export const generalTriggers: TriggerDefinition[] = [
  { name: 'add_to_temporary_list', description: 'Saves a temporary target for use during the trigger execution', supportedScopes: ['none'], syntax: "This is used to build lists in triggers.\nIf used within an any-trigger, placement within the trigger is quite important. The game will iterate through every instance of the any-trigger until it finds a single instance that fulfills the requirements, and then it will stop.\nIn order to add every instance of a scope that fulfills certain conditions, use \"count = all\" while also placing this \"effect\" at the very end of the any-trigger (so that every condition is evaluated for every iteration)." },
  { name: 'all_false', description: 'true if all children are false (equivalent to NOR)', supportedScopes: ['none'] },
  { name: 'always', description: 'checks if the assigned yes/no value is true', supportedScopes: ['none'], valueType: 'boolean', syntax: "always = yes # always succeeds\nalways = no  # always fails\nalways = scope:a_boolean_value # evaluated at runtime" },
  { name: 'and', description: 'all inside trigger must be true', supportedScopes: ['none'] },
  { name: 'any_accolade_type', description: 'Iterate through every accolade_type in the database', supportedScopes: ['none'], supportedTargets: ['accolade_type'], outputScope: 'accolade_type', isIterator: true, valueType: 'block', syntax: "any_accolade_type = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_active_dynasty', description: 'Iterate through all dynasties with dynasty head', supportedScopes: ['none'], supportedTargets: ['dynasty'], outputScope: 'dynasty', isIterator: true, valueType: 'block', syntax: "any_active_dynasty = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_activity', description: 'Iterate through all activities in the world', supportedScopes: ['none'], supportedTargets: ['activity'], outputScope: 'activity', isIterator: true, valueType: 'block', syntax: "any_activity = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_activity_type', description: 'Iterate through every activity_type in the database', supportedScopes: ['none'], supportedTargets: ['activity_type'], outputScope: 'activity_type', isIterator: true, valueType: 'block', syntax: "any_activity_type = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_artifact', description: 'Iterate through all existing artifacts', supportedScopes: ['none'], supportedTargets: ['artifact'], outputScope: 'artifact', isIterator: true, valueType: 'block', syntax: "any_artifact = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_barony', description: 'Iterate through all baronies in the game', supportedScopes: ['none'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_barony = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_casus_belli_type', description: 'Iterate through every casus_belli_type in the database', supportedScopes: ['none'], supportedTargets: ['casus_belli_type'], outputScope: 'casus_belli_type', isIterator: true, valueType: 'block', syntax: "any_casus_belli_type = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_character_with_royal_court', description: 'Iterate through all characters with a royal court', supportedScopes: ['none'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_character_with_royal_court = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_completed_legend', description: 'Gets all legends in the world that have been completed', supportedScopes: ['none'], supportedTargets: ['legend'], outputScope: 'legend', isIterator: true, valueType: 'block', syntax: "any_completed_legend = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_confederation', description: 'List all confederations', supportedScopes: ['none'], supportedTargets: ['confederation'], outputScope: 'confederation', isIterator: true, valueType: 'block', syntax: "any_confederation = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_confederation_type', description: 'Iterate through every confederation_type in the database', supportedScopes: ['none'], supportedTargets: ['confederation_type'], outputScope: 'confederation_type', isIterator: true, valueType: 'block', syntax: "any_confederation_type = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_county', description: 'Iterate through all counties in the game', supportedScopes: ['none'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_county = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_county_in_region', description: 'Iterate through all counties in the region. Put \'region = region_name\' inside it', supportedScopes: ['none'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_county_in_region = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_court_position_type', description: 'Iterate through every court_position_type in the database', supportedScopes: ['none'], supportedTargets: ['court_position_type'], outputScope: 'court_position_type', isIterator: true, valueType: 'block', syntax: "any_court_position_type = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_culture_global', description: 'Iterate through all cultures in the game', supportedScopes: ['none'], supportedTargets: ['culture'], outputScope: 'culture', isIterator: true, valueType: 'block', syntax: "any_culture_global = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_culture_innovation', description: 'Iterate through every culture_innovation in the database', supportedScopes: ['none'], supportedTargets: ['culture_innovation'], outputScope: 'culture_innovation', isIterator: true, valueType: 'block', syntax: "any_culture_innovation = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_culture_pillar', description: 'Iterate through every culture_pillar in the database', supportedScopes: ['none'], supportedTargets: ['culture_pillar'], outputScope: 'culture_pillar', isIterator: true, valueType: 'block', syntax: "any_culture_pillar = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_culture_tradition', description: 'Iterate through every culture_tradition in the database', supportedScopes: ['none'], supportedTargets: ['culture_tradition'], outputScope: 'culture_tradition', isIterator: true, valueType: 'block', syntax: "any_culture_tradition = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_decision', description: 'Iterate through every decision in the database', supportedScopes: ['none'], supportedTargets: ['decision'], outputScope: 'decision', isIterator: true, valueType: 'block', syntax: "any_decision = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_doctrine', description: 'Iterate through every doctrine in the database', supportedScopes: ['none'], supportedTargets: ['doctrine'], outputScope: 'doctrine', isIterator: true, valueType: 'block', syntax: "any_doctrine = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_domicile', description: 'Iterate through all domiciles', supportedScopes: ['none'], supportedTargets: ['domicile'], outputScope: 'domicile', isIterator: true, valueType: 'block', syntax: "any_domicile = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_duchy', description: 'Iterate through all duchies in the game', supportedScopes: ['none'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_duchy = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_dynasty', description: 'Iterate through all dynasties (even those without head)', supportedScopes: ['none'], supportedTargets: ['dynasty'], outputScope: 'dynasty', isIterator: true, valueType: 'block', syntax: "any_dynasty = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_empire', description: 'Iterate through all empires in the game', supportedScopes: ['none'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_empire = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_epidemic', description: 'Gets all epidemics in the world', supportedScopes: ['none'], supportedTargets: ['epidemic'], outputScope: 'epidemic', isIterator: true, valueType: 'block', syntax: "any_epidemic = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_epidemic_type', description: 'Iterate through every epidemic_type in the database', supportedScopes: ['none'], supportedTargets: ['epidemic_type'], outputScope: 'epidemic_type', isIterator: true, valueType: 'block', syntax: "any_epidemic_type = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_false', description: 'true if any child is false (equivalent to NAND)', supportedScopes: ['none'], isIterator: true },
  { name: 'any_geographical_region', description: 'Iterate through every geographical_region in the database', supportedScopes: ['none'], supportedTargets: ['geographical_region'], outputScope: 'geographical_region', isIterator: true, valueType: 'block', syntax: "any_geographical_region = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_government_type', description: 'Iterate through every government_type in the database', supportedScopes: ['none'], supportedTargets: ['government_type'], outputScope: 'government_type', isIterator: true, valueType: 'block', syntax: "any_government_type = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_great_project', description: 'Iterate through all active Great Projects.', supportedScopes: ['none'], supportedTargets: ['great_project'], outputScope: 'great_project', isIterator: true, valueType: 'block', syntax: "any_great_project = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_great_project_type', description: 'Iterate through every great_project_type in the database', supportedScopes: ['none'], supportedTargets: ['great_project_type'], outputScope: 'great_project_type', isIterator: true, valueType: 'block', syntax: "any_great_project_type = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_hegemony', description: 'Iterate through all hegemonies in the game', supportedScopes: ['none'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_hegemony = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_holding_type', description: 'Iterate through every holding_type in the database', supportedScopes: ['none'], supportedTargets: ['holding_type'], outputScope: 'holding_type', isIterator: true, valueType: 'block', syntax: "any_holding_type = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_house_aspiration', description: 'Iterate through every house_aspiration in the database', supportedScopes: ['none'], supportedTargets: ['house_aspiration'], outputScope: 'house_aspiration', isIterator: true, valueType: 'block', syntax: "any_house_aspiration = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_house_relation_level', description: 'Iterate through every house_relation_level in the database', supportedScopes: ['none'], supportedTargets: ['house_relation_level'], outputScope: 'house_relation_level', isIterator: true, valueType: 'block', syntax: "any_house_relation_level = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_house_relation_type', description: 'Iterate through every house_relation_type in the database', supportedScopes: ['none'], supportedTargets: ['house_relation_type'], outputScope: 'house_relation_type', isIterator: true, valueType: 'block', syntax: "any_house_relation_type = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_important_location', description: 'Iterate through all counties that are important for at least some title', supportedScopes: ['none'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_important_location = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_in_global_list', description: 'Iterate through all items in global list. list = name or variable = name', supportedScopes: ['none'], isIterator: true, valueType: 'block', syntax: "any_in_global_list = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_in_list', description: 'Iterate through all items in list. list = name or variable = name', supportedScopes: ['none'], isIterator: true, valueType: 'block', syntax: "any_in_list = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_in_local_list', description: 'Iterate through all items in local list. list = name or variable = name', supportedScopes: ['none'], isIterator: true, valueType: 'block', syntax: "any_in_local_list = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_independent_ruler', description: 'Independent rulers list with a COUNT tier or above who hold land', supportedScopes: ['none'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_independent_ruler = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_inspiration', description: 'Iterate through all inspirations in the world', supportedScopes: ['none'], supportedTargets: ['inspiration'], outputScope: 'inspiration', isIterator: true, valueType: 'block', syntax: "any_inspiration = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_inspired_character', description: 'Iterate through all characters with an inspirations in the world', supportedScopes: ['none'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_inspired_character = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_interested_title', description: 'Iterate through all titles that are interested in any county', supportedScopes: ['none'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_interested_title = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_kingdom', description: 'Iterate through all kingdoms in the game', supportedScopes: ['none'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, valueType: 'block', syntax: "any_kingdom = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_legend', description: 'Gets all legends in the world that have not been completed', supportedScopes: ['none'], supportedTargets: ['legend'], outputScope: 'legend', isIterator: true, valueType: 'block', syntax: "any_legend = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_legend_type', description: 'Iterate through every legend_type in the database', supportedScopes: ['none'], supportedTargets: ['legend_type'], outputScope: 'legend_type', isIterator: true, valueType: 'block', syntax: "any_legend_type = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_living_character', description: 'Iterate through all living characters', supportedScopes: ['none'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_living_character = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_mercenary_company', description: 'Iterate through all mercenary companies', supportedScopes: ['none'], supportedTargets: ['mercenary_company'], outputScope: 'mercenary_company', isIterator: true, valueType: 'block', syntax: "any_mercenary_company = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_open_invite_activity', description: 'Iterate through all open invite activities in the world', supportedScopes: ['none'], supportedTargets: ['activity'], outputScope: 'activity', isIterator: true, valueType: 'block', syntax: "any_open_invite_activity = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_player', description: 'Iterate through all player characters', supportedScopes: ['none'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_player = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_pool_character', description: 'Iterate through all characters in the pool of the given province', supportedScopes: ['none'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_pool_character = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_province', description: 'Iterate through all provinces (skips non-land and impassable provinces)', supportedScopes: ['none'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, valueType: 'block', syntax: "any_province = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_religion_global', description: 'Iterate through all religions in the game', supportedScopes: ['none'], supportedTargets: ['religion'], outputScope: 'religion', isIterator: true, valueType: 'block', syntax: "any_religion_global = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_ruler', description: 'Rulers list with a COUNT tier o above', supportedScopes: ['none'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, valueType: 'block', syntax: "any_ruler = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_special_building_province', description: 'Iterate through all provinces with a special building slot (built or un-built)', supportedScopes: ['none'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, valueType: 'block', syntax: "any_special_building_province = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_task_contract', description: 'Gets all available and accepted task contracts.', supportedScopes: ['none'], supportedTargets: ['task_contract'], outputScope: 'task_contract', isIterator: true, valueType: 'block', syntax: "Optionally specify a contract type filter\nany_task_contract = { task_contract_type = laamp_raid_contract }\nany_task_contract = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_task_contract_type', description: 'Iterate through every task_contract_type in the database', supportedScopes: ['none'], supportedTargets: ['task_contract_type'], outputScope: 'task_contract_type', isIterator: true, valueType: 'block', syntax: "any_task_contract_type = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_trait', description: 'Iterate through every trait in the database', supportedScopes: ['none'], supportedTargets: ['trait'], outputScope: 'trait', isIterator: true, valueType: 'block', syntax: "any_trait = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_trait_in_category', description: 'Iterate through all traits in a given category', supportedScopes: ['none'], supportedTargets: ['trait'], outputScope: 'trait', isIterator: true, valueType: 'block', syntax: "any_trait_in_category = { category = fame/health/etc }\nany_trait_in_category = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'any_vassal_contract', description: 'Iterate through every vassal_contract in the database', supportedScopes: ['none'], supportedTargets: ['vassal_contract'], outputScope: 'vassal_contract', isIterator: true, valueType: 'block', syntax: "any_vassal_contract = { <count=num/all> / <percent=fixed_point> <triggers> }", parameters: ['count', 'percent'] },
  { name: 'assert_if', description: 'Conditionally cause an assert during run time', supportedScopes: ['none'], syntax: "assert_if = { limit = { X } text = Y }, where X is a trigger and Y is an optional string" },
  { name: 'assert_read', description: 'Conditionally cause an assert during read time', supportedScopes: ['none'], syntax: "assert_read = X, where X is yes or the string to be printed in the assert" },
  { name: 'calc_true_if', description: 'Returns true if the specified number of sub-triggers return true', supportedScopes: ['none'], syntax: "calc_true_if = { amount = 2 <trigger> <trigger> <trigger> }" },
  { name: 'can_start_tutorial_lesson', description: 'Can the specified tutorial lesson be started?', supportedScopes: ['none'], syntax: "can_start_tutorial_lesson = reactive_advice_succession\nAn interface trigger, can only be used in specific places" },
  { name: 'current_computer_date', description: 'Compare the current computer date.', supportedScopes: ['none'], valueType: 'comparison', syntax: "An interface trigger, can only be used in specific places" },
  { name: 'current_computer_date_day', description: 'Compare the current computer day.', supportedScopes: ['none'], valueType: 'comparison', syntax: "An interface trigger, can only be used in specific places" },
  { name: 'current_computer_date_month', description: 'Compare the current computer month.', supportedScopes: ['none'], valueType: 'comparison', syntax: "An interface trigger, can only be used in specific places" },
  { name: 'current_computer_date_year', description: 'Compare the current computer year.', supportedScopes: ['none'], valueType: 'comparison', syntax: "An interface trigger, can only be used in specific places" },
  { name: 'current_date', description: 'Compare the current ingame date.', supportedScopes: ['none'], valueType: 'comparison' },
  { name: 'current_day', description: 'Compare the current ingame day [1, 31]', supportedScopes: ['none'], valueType: 'comparison' },
  { name: 'current_month', description: 'Compare the current ingame month [1..12]', supportedScopes: ['none'], valueType: 'comparison' },
  { name: 'current_tooltip_depth', description: 'What is number of tooltips open rigth now?', supportedScopes: ['none'], valueType: 'comparison', syntax: "An interface trigger, can only be used in specific places" },
  { name: 'current_year', description: 'Compare the current ingame year', supportedScopes: ['none'], valueType: 'comparison' },
  { name: 'custom_description', description: 'Wraps triggers that get a custom description instead of the auto-generated one', supportedScopes: ['none'], syntax: "custom_description = {\ntext = <trigger_localization_key>\nsubject = <optional subject scope> #defaults to current scope\nobject = <optional object scope>\nvalue = <optional script value>\n... triggers ...\n}", parameters: ['text', 'subject', 'object'] },
  { name: 'custom_tooltip', description: 'Replaces the tooltips for the enclosed triggers with a custom text', supportedScopes: ['none'], syntax: "custom_tooltip = {\ntext = <text>\nsubject = <scope> (optional)\n<trigger>\n}", parameters: ['text', 'subject'] },
  { name: 'debug_log', description: 'Log whether the parent trigger succeeded or failed', supportedScopes: ['none'] },
  { name: 'debug_log_details', description: 'Log whether the parent trigger succeeded or failed. Log which children succeeded or failed', supportedScopes: ['none'] },
  { name: 'debug_only', description: 'Checks if the game is in debug mode or not.', supportedScopes: ['none'], valueType: 'boolean' },
  { name: 'exists', description: 'Checks whether the specified scope target exists (check for not being the null object)', supportedScopes: ['none'], syntax: "exists = from.owner.var:cool_var.mother" },
  { name: 'game_start_date', description: 'Compare the date of the bookmarked game launched.', supportedScopes: ['none'], valueType: 'comparison' },
  { name: 'global_variable_list_size', description: 'Checks the size of a variable list', supportedScopes: ['none'], syntax: "variable_list_size = { name = X target >= Y }\nWhere X is the name of the variable\nWhere Y is a script value or number", parameters: ['variable_list_size'] },
  { name: 'has_all_variables', description: 'Checks whether the current scope has all of the specified variables set', supportedScopes: ['none'], syntax: "has_all_variables = {\nname = variable_name1\nname = variable_name2\nname = variable_name3\n}", parameters: ['name'] },
  { name: 'has_dlc', description: 'Does the host have this DLC', supportedScopes: ['none'] },
  { name: 'has_dlc_feature', description: 'Does the host have DLC that enables this particular feature', supportedScopes: ['none'] },
  { name: 'has_game_rule', description: 'Is the given game rule setting enabled?', supportedScopes: ['none'], syntax: "has_game_rule = faster_conversion" },
  { name: 'has_global_variable', description: 'Checks whether the current scope has the specified variable set', supportedScopes: ['none'], syntax: "has_global_variable = name" },
  { name: 'has_global_variable_list', description: 'Checks whether the current scope has the specified variable list set', supportedScopes: ['none'], syntax: "has_variable_list = name", parameters: ['has_variable_list'] },
  { name: 'has_local_player_open_court_event', description: 'Has the local player opened a court event in the royal court view?', supportedScopes: ['none'], valueType: 'boolean', syntax: "An interface trigger, can only be used in specific places" },
  { name: 'has_local_player_seen_unopened_court_event', description: 'Has the local player seen the unopened court event(s) waiting in the royal court view?', supportedScopes: ['none'], valueType: 'boolean', syntax: "An interface trigger, can only be used in specific places" },
  { name: 'has_local_player_unopened_court_event', description: 'Has the local player an unopened court event waiting in the royal court view?', supportedScopes: ['none'], valueType: 'boolean', syntax: "An interface trigger, can only be used in specific places" },
  { name: 'has_local_variable', description: 'Checks whether the current scope has the specified variable set', supportedScopes: ['none'], syntax: "has_local_variable = name" },
  { name: 'has_local_variable_list', description: 'Checks whether the current scope has the specified variable list set', supportedScopes: ['none'], syntax: "has_variable_list = name", parameters: ['has_variable_list'] },
  { name: 'has_map_mode', description: 'Checks if the current map mode is the specified one', supportedScopes: ['none'], syntax: "has_map_mode = realms\nAn interface trigger, can only be used in specific places" },
  { name: 'has_multiple_players', description: 'Does the game have at least two players currently connected?', supportedScopes: ['none'], valueType: 'boolean' },
  { name: 'has_none_of_variables', description: 'Checks whether the current scope has none of the specified variables set', supportedScopes: ['none'], syntax: "has_none_of_variables = {\nname = variable_name1\nname = variable_name2\nname = variable_name3\n}", parameters: ['name'] },
  { name: 'has_reward_item', description: 'Does the player have a reward item', supportedScopes: ['none'], syntax: "An interface trigger, can only be used in specific places" },
  { name: 'has_variable', description: 'Checks whether the current scope has any of the specified variables set', supportedScopes: ['none'], syntax: "has_variable = variable_name\nhas_variable = {\nname = variable_name1\nname = variable_name2\nname = variable_name3\n}", parameters: ['name'] },
  { name: 'has_variable_list', description: 'Checks whether the current scope has the specified variable list set', supportedScopes: ['none'], syntax: "has_variable_list = name" },
  { name: 'has_vassal_stance', description: 'Does the scoped vassal character have the given vassal stance', supportedScopes: ['none'], syntax: "has_vassal_stance = glory_hound" },
  { name: 'has_war_result_message_with_outcome', description: 'Is there a war result message with the specified outcome?', supportedScopes: ['none'], syntax: "has_war_result_message_with_outcome = victory/defeat/white_peace/invalidated/any\nAn interface trigger, can only be used in specific places" },
  { name: 'is_bad_nickname', description: 'Is the nickname bad?', supportedScopes: ['none'] },
  { name: 'is_frontend_character_selected', description: 'is the specified front end character selected (also can be used with "= yes" and "= no")?', supportedScopes: ['none'], syntax: "An interface trigger, can only be used in specific places" },
  { name: 'is_game_view_open', description: 'is the specified in-game view open?', supportedScopes: ['none'], syntax: "An interface trigger, can only be used in specific places" },
  { name: 'is_gamestate_tutorial_active', description: 'Is the gamestate tutorial active? See save_progress_in_gamestate in tutorial_lesson_chains documentation.', supportedScopes: ['none'], valueType: 'boolean', syntax: "An interface trigger, can only be used in specific places" },
  { name: 'is_in_list', description: 'Checks if a target in in a list', supportedScopes: ['none'] },
  { name: 'is_mercenary_in_hire_range', description: 'Is the mercenary company within the hiring range of the target character.', supportedScopes: ['none'], supportedTargets: ['character'], syntax: "is_mercenary_in_hire_range = scope:character" },
  { name: 'is_player_selected', description: 'is the player playing a character?', supportedScopes: ['none'], valueType: 'boolean', syntax: "An interface trigger, can only be used in specific places" },
  { name: 'is_rightful_liege_of', description: 'Was the target character the preferred heir of the scoped character', supportedScopes: ['none'], supportedTargets: ['character'], syntax: "was_preferred_heir = scope:character", parameters: ['was_preferred_heir'] },
  { name: 'is_set', description: 'Checks whether the specified scope target has been set (includes being the null object)', supportedScopes: ['none'], syntax: "is_set = from.owner.var:cool_var.mother" },
  { name: 'is_target_in_global_variable_list', description: 'Checks if a target is in a variable list', supportedScopes: ['none'], syntax: "is_target_in_variable_list = { name = X target = Y }\nWhere X is the name of the variable\nWhere Y is an event target", parameters: ['is_target_in_variable_list'] },
  { name: 'is_target_in_local_variable_list', description: 'Checks if a target is in a variable list', supportedScopes: ['none'], syntax: "is_target_in_variable_list = { name = X target = Y }\nWhere X is the name of the variable\nWhere Y is an event target", parameters: ['is_target_in_variable_list'] },
  { name: 'is_target_in_variable_list', description: 'Checks if a target is in a variable list', supportedScopes: ['none'], syntax: "is_target_in_variable_list = { name = X target = Y }\nWhere X is the name of the variable\nWhere Y is an event target" },
  { name: 'is_title_localization_key_used', description: 'Checks if any currently existing landed title uses the specified custom localization name key.', supportedScopes: ['none'], syntax: "is_custom_title_name_key_used = my_title_localization_key", parameters: ['is_custom_title_name_key_used'] },
  { name: 'is_tooltip_with_name_open', description: 'is the tooltip with the specified name open?', supportedScopes: ['none'], syntax: "An interface trigger, can only be used in specific places" },
  { name: 'is_tutorial_active', description: 'Is the tutorial active?', supportedScopes: ['none'], valueType: 'boolean', syntax: "An interface trigger, can only be used in specific places" },
  { name: 'is_tutorial_lesson_active', description: 'Is this the current tutorial lesson?', supportedScopes: ['none'], syntax: "is_tutorial_lesson_active = reactive_advice_succession\nAn interface trigger, can only be used in specific places" },
  { name: 'is_tutorial_lesson_chain_completed', description: 'Has the tutorial lesson chain with the specified key been finished?', supportedScopes: ['none'], syntax: "An interface trigger, can only be used in specific places" },
  { name: 'is_tutorial_lesson_completed', description: 'has the tutorial lesson with the specified name been finished?', supportedScopes: ['none'], syntax: "An interface trigger, can only be used in specific places" },
  { name: 'is_tutorial_lesson_step_completed', description: 'Has the tutorial lesson step been finished?', supportedScopes: ['none'], syntax: "is_tutorial_lesson_step_completed = lesson_key:step_key\nAn interface trigger, can only be used in specific places" },
  { name: 'is_war_overview_tab_open', description: 'is the war overview open at a specified tab (victory, defeat, white_peace)?', supportedScopes: ['none'], syntax: "An interface trigger, can only be used in specific places" },
  { name: 'is_widgetid_open', description: 'Is the widget with the specified `widgetid` open (visible and not animating)?', supportedScopes: ['none'], syntax: "The fastest and safest way to check. (replaces old `is_widget_open` functionality, which operated on names.)\nAn interface trigger, can only be used in specific places" },
  { name: 'list_size', description: 'Checks the size of a list', supportedScopes: ['none'], valueType: 'comparison', syntax: "list_size = { name = X value >= Y }\nWhere X is the name of the list\nWhere Y is a script value" },
  { name: 'local_variable_list_size', description: 'Checks the size of a variable list', supportedScopes: ['none'], syntax: "variable_list_size = { name = X target >= Y }\nWhere X is the name of the variable\nWhere Y is a script value or number", parameters: ['variable_list_size'] },
  { name: 'meets_legitimacy_expectation_of', description: 'Does the scoped character meet the legitimacy expectations of the target AI vassal', supportedScopes: ['none'], supportedTargets: ['character'], syntax: "meets_legitimacy_expectation_of = scope:some_vassal" },
  { name: 'months_from_game_start', description: 'How many months it has been since the start of the game', supportedScopes: ['none'], valueType: 'comparison', syntax: "months_from_game_start > 5" },
  { name: 'nand', description: 'a negated AND trigger', supportedScopes: ['none'] },
  { name: 'nor', description: 'a negated OR trigger', supportedScopes: ['none'] },
  { name: 'not', description: 'negates content of trigger', supportedScopes: ['none'] },
  { name: 'or', description: 'at least one entry inside trigger must be true', supportedScopes: ['none'] },
  { name: 'perks_in_diplomacy_lifestyle', description: 'How many perks does this lifestyle have?', supportedScopes: ['none'], valueType: 'comparison' },
  { name: 'perks_in_intrigue_lifestyle', description: 'How many perks does this lifestyle have?', supportedScopes: ['none'], valueType: 'comparison' },
  { name: 'perks_in_learning_lifestyle', description: 'How many perks does this lifestyle have?', supportedScopes: ['none'], valueType: 'comparison' },
  { name: 'perks_in_martial_lifestyle', description: 'How many perks does this lifestyle have?', supportedScopes: ['none'], valueType: 'comparison' },
  { name: 'perks_in_stewardship_lifestyle', description: 'How many perks does this lifestyle have?', supportedScopes: ['none'], valueType: 'comparison' },
  { name: 'perks_in_wanderer_lifestyle', description: 'How many perks does this lifestyle have?', supportedScopes: ['none'], valueType: 'comparison' },
  { name: 'release_only', description: 'Checks if the game is in release mode or not.', supportedScopes: ['none'], valueType: 'boolean' },
  { name: 'save_temporary_opinion_value_as', description: 'Saves the scoped character\'s opinion of the target character as an arbitrarily-named target to be referenced later in the in the same trigger', supportedScopes: ['none'], syntax: "save_temporary_opinion_value_as = { name = <string> target = x" },
  { name: 'save_temporary_scope_as', description: 'Saves a temporary target for use during the trigger execution', supportedScopes: ['none'] },
  { name: 'save_temporary_scope_value_as', description: 'Saves a numerical or bool value as an arbitrarily-named temporary target to be referenced later in the same effect', supportedScopes: ['none'], syntax: "save_temporary_scope_value_as = { name = <string> value = x }" },
  { name: 'scripted_tests', description: 'Checks if the game is currently running scripted tests.', supportedScopes: ['none'], valueType: 'boolean' },
  { name: 'should_show_disturbing_portrait_modifiers', description: 'can disturbing portrait modifiers be shown?', supportedScopes: ['none'], valueType: 'boolean', syntax: "An interface trigger, can only be used in specific places" },
  { name: 'should_show_nudity', description: 'can nudity be shown?', supportedScopes: ['none'], valueType: 'boolean', syntax: "An interface trigger, can only be used in specific places" },
  { name: 'switch', description: 'Switch on a trigger for the evaluation of another trigger with an optional fallback trigger.', supportedScopes: ['none'], valueType: 'block', syntax: "switch = {\ntrigger = simple_assign_trigger\ncase_1 = { <triggers> }\ncase_2 = { <triggers> }\ncase_n = { <triggers> }\nfallback = { <triggers> }", parameters: ['case_1', 'case_2', 'case_n', 'fallback'] },
  { name: 'time_of_year', description: 'Check if the current date is within the bounds', supportedScopes: ['none'], syntax: "time_of_year = {\nmin = 11.1 # default: beginning of year\nmax = 2.29 # default: end of year\n}\nDates are formatted as \"<month>.<day>\" or just \"<month>\".\nThe check includes the min and max dates.\nmin can be larger than max, in this case we wrap around to the next year (i.e., February is between October and March).", parameters: ['min', 'max'] },
  { name: 'trigger_else', description: 'Evaluates the triggers if the display_triggers of preceding \'trigger_if\' or \'trigger_else_if\' is not mettrigger_if = { limit = { <display_triggers> } <triggers> }', supportedScopes: ['none'], valueType: 'block', syntax: "trigger_else = { <triggers> }" },
  { name: 'trigger_else_if', description: 'Evaluates the enclosed triggers if the display_triggers of the preceding `trigger_if` or `trigger_else_if` is not met and its own display_trigger of the limit is mettrigger_if = { limit = { <display_triggers> } <triggers> }', supportedScopes: ['none'], valueType: 'block', syntax: "trigger_else_if = { limit = { <display_triggers> } <triggers> }" },
  { name: 'trigger_if', description: 'Evaluates the triggers if the display_triggers of the limit are met', supportedScopes: ['none'], valueType: 'block', syntax: "trigger_if = { limit = { <display_triggers> } <triggers> }" },
  { name: 'variable_list_size', description: 'Checks the size of a variable list', supportedScopes: ['none'], syntax: "variable_list_size = { name = X target >= Y }\nWhere X is the name of the variable\nWhere Y is a script value or number" },
  { name: 'was_preferred_heir', description: 'Was the target character the preferred heir of the scoped character', supportedScopes: ['none'], supportedTargets: ['character'], syntax: "was_preferred_heir = scope:character" },
  { name: 'weighted_calc_true_if', description: 'Returns true if the sum of weights of fulfilled sub-triggers amount to the specified sum', supportedScopes: ['none'], syntax: "weighted_calc_true_if = { amount = 10 5 = { <trigger> } 15 = { <trigger> } 7 = { <trigger> } }" },
  { name: 'years_from_game_start', description: 'How many years it has been since the start of the game', supportedScopes: ['none'], valueType: 'comparison', syntax: "years_from_game_start > 5" },
];

/**
 * All triggers combined
 */
export const allTriggers: TriggerDefinition[] = [
  ...characterTriggers,
  ...landedtitleTriggers,
  ...provinceTriggers,
  ...dynastyTriggers,
  ...dynastyhouseTriggers,
  ...cultureTriggers,
  ...cultureinnovationTriggers,
  ...faithTriggers,
  ...religionTriggers,
  ...armyTriggers,
  ...schemeTriggers,
  ...warTriggers,
  ...activityTriggers,
  ...artifactTriggers,
  ...secretTriggers,
  ...factionTriggers,
  ...holyorderTriggers,
  ...mercenarycompanyTriggers,
  ...inspirationTriggers,
  ...storyTriggers,
  ...casusbelliTriggers,
  ...travelplanTriggers,
  ...counciltaskTriggers,
  ...struggleTriggers,
  ...legendTriggers,
  ...accoladeTriggers,
  ...epidemicTriggers,
  ...taskcontractTriggers,
  ...situationTriggers,
  ...situationsubregionTriggers,
  ...taxslotTriggers,
  ...domicileTriggers,
  ...greatprojectTriggers,
  ...confederationTriggers,
  ...houserelationTriggers,
  ...agentslotTriggers,
  ...generalTriggers,
];

/**
 * Get triggers valid for a specific scope
 */
export function getTriggersForScope(scope: ScopeType): TriggerDefinition[] {
  return allTriggers.filter(trigger => {
    if (trigger.supportedScopes.includes('none')) return true;
    return trigger.supportedScopes.includes(scope);
  });
}

/**
 * Build a map for quick lookup
 */
export const triggersMap = new Map<string, TriggerDefinition>(
  allTriggers.map(t => [t.name, t])
);
