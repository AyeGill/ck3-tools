/**
 * CK3 Effect Definitions (Auto-generated)
 * 
 * Effects are commands that modify game state.
 * Each effect has a list of scopes where it can be used.
 * 
 * Source: OldEnt repository (version 1.10.2)
 * Total effects: 1343
 */

import { ScopeType } from './scopes';

export interface EffectDefinition {
  name: string;
  description: string;
  supportedScopes: ScopeType[];
  supportedTargets?: ScopeType[];
  outputScope?: ScopeType;
  isIterator?: boolean;
  syntax?: string;
}

/**
 * Effects for character scope (667 effects)
 */
export const characterEffects: EffectDefinition[] = [
  { name: 'every_killed_character', description: 'Iterate through all kills of a character', supportedScopes: ['character', 'artifact'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_killed_character = { limit = { <triggers> } <effects> }" },
  { name: 'ordered_killed_character', description: 'Iterate through all kills of a character', supportedScopes: ['character', 'artifact'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_killed_character = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'random_killed_character', description: 'Iterate through all kills of a character', supportedScopes: ['character', 'artifact'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_killed_character = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'accept_activity_invite', description: 'accept_activity_invite = activity', supportedScopes: ['character'], supportedTargets: ['activity'], syntax: "The scoped character accepts the invitation to the target activity, using their default travel plan." },
  { name: 'accept_activity_invite_without_travel', description: 'accept_activity_invite_without_travel = activity', supportedScopes: ['character'], supportedTargets: ['activity'], syntax: "The scoped character accepts the invitation to the target activity, without adding a travel plan.\nThe character will need to be at the location or they will be kicked out of the activity." },
  { name: 'add_amenity_level', description: 'add_amenity_level = { type = food value = 2 }', supportedScopes: ['character'], syntax: "Increases the amenity type by the given value for the scoped character" },
  { name: 'add_character_flag', description: 'adds a character flag', supportedScopes: ['character'], syntax: "usage:\nadd_character_flag = X\nadd_character_flag = { flag = X days/weeks/years = Y }\nwhere X is the name of the flag and Y is a value or value interval \"{ min max }\"" },
  { name: 'add_character_modifier', description: 'Add a modifier to a character', supportedScopes: ['character'], syntax: "add_character_modifier = name\nadd_character_modifier = { modifier = name days/weeks/months/years = int }\nYou can also add an optional 'desc' field. This is a dynamic description that'll be used for your timed modifier" },
  { name: 'add_courtier', description: 'Add the target character to the scope character\'s court', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'add_diplomacy_lifestyle_perk_points', description: 'Adds lifestyle per points to the given character', supportedScopes: ['character'] },
  { name: 'add_diplomacy_lifestyle_xp', description: 'Adds lifestyle XP to the given character', supportedScopes: ['character'] },
  { name: 'add_dread', description: 'adds (or removes) dread to a character', supportedScopes: ['character'] },
  { name: 'add_gold', description: 'adds gold to a character', supportedScopes: ['character'] },
  { name: 'add_hook', description: 'Adds a hook on a character', supportedScopes: ['character'], syntax: "add_hook = { type = X, target = Y, secret = Z, days/months/years = W  }\nNote: days/months/years optional (taken from hook type otherwise) and can be a value or an interval, secret required for hook types that require it.\nDoes send a toast to the player if it's involved." },
  { name: 'add_hook_no_toast', description: 'Adds a hook on a character', supportedScopes: ['character'], syntax: "add_hook = { type = X, target = Y, secret = Z, days/months/years = W  }\nNote: days/months/years optional (taken from hook type otherwise) and can be a value or an interval, secret required for hook types that require it.\nDoes NOT send a toast to the player." },
  { name: 'add_intrigue_lifestyle_perk_points', description: 'Adds lifestyle per points to the given character', supportedScopes: ['character'] },
  { name: 'add_intrigue_lifestyle_xp', description: 'Adds lifestyle XP to the given character', supportedScopes: ['character'] },
  { name: 'add_joined_faction_discontent', description: 'add_joined_faction_discontent = X adds (or subtracts) discontent to the factions the scope character is in', supportedScopes: ['character'] },
  { name: 'add_knows_of_killer', description: 'Adds the right hand side character as knowing of the killer of the scoped object', supportedScopes: ['character'], supportedTargets: ['character'], syntax: "dead_person = { add_knows_of_killer = root }" },
  { name: 'add_learning_lifestyle_perk_points', description: 'Adds lifestyle per points to the given character', supportedScopes: ['character'] },
  { name: 'add_learning_lifestyle_xp', description: 'Adds lifestyle XP to the given character', supportedScopes: ['character'] },
  { name: 'add_long_term_gold', description: 'Add gold to \'long term\' AI budget category, respecting maximums, overflow goes into Short Term budget. (gold will be created out of nowhere)character, add_long_term_gold = X', supportedScopes: ['character'] },
  { name: 'add_martial_lifestyle_perk_points', description: 'Adds lifestyle per points to the given character', supportedScopes: ['character'] },
  { name: 'add_martial_lifestyle_xp', description: 'Adds lifestyle XP to the given character', supportedScopes: ['character'] },
  { name: 'add_opinion', description: 'Adds a temporary opinion modifier, add_opinion = { modifier = X days/months/years = Y target = Z }', supportedScopes: ['character'], syntax: "X is a scripted modifier name. Y can be a value or a range \"{ A B }\" If no timeout are specified, the modifier's scripted default timeout will be used." },
  { name: 'add_perk', description: 'Adds the perk for this character', supportedScopes: ['character'] },
  { name: 'add_personal_artifact_claim', description: 'Adds a personal claim on the target artifact to the scoped character', supportedScopes: ['character'], supportedTargets: ['artifact'] },
  { name: 'add_piety', description: 'gives (or takes) piety to a character', supportedScopes: ['character'] },
  { name: 'add_piety_experience', description: 'gives (or takes) piety experience to a character', supportedScopes: ['character'] },
  { name: 'add_piety_level', description: 'increases (or decreases) the piety level of a character', supportedScopes: ['character'] },
  { name: 'add_piety_no_experience', description: 'gives (or takes) piety without experience to a character', supportedScopes: ['character'] },
  { name: 'add_pressed_claim', description: 'gives a pressed claim to a character', supportedScopes: ['character'], supportedTargets: ['landed_title'] },
  { name: 'add_prestige', description: 'gives (or takes) prestige to a character', supportedScopes: ['character'] },
  { name: 'add_prestige_experience', description: 'gives (or takes) prestige experience to a character', supportedScopes: ['character'] },
  { name: 'add_prestige_level', description: 'increases (or decreases) the prestige level of a character', supportedScopes: ['character'] },
  { name: 'add_prestige_no_experience', description: 'gives (or takes) prestige without experience to a character', supportedScopes: ['character'] },
  { name: 'add_realm_law', description: 'Adds the given law to the scoped character', supportedScopes: ['character'] },
  { name: 'add_realm_law_skip_effects', description: 'Adds the given law to the scoped character. Skips the cost and the pass effect, and the revoke effects of the current law', supportedScopes: ['character'] },
  { name: 'add_relation_flag', description: 'Adds a flag to an existing relation', supportedScopes: ['character'], syntax: "add_relation_flag = {\nrelation = scripted_relation\nflag = flag_name (declared in the relation's script)\ntarget = other_character\n}" },
  { name: 'add_reserved_gold', description: 'Add gold to \'reserved\' AI budget category, respecting maximums, overflow goes into Short Term budget. (gold will be created out of nowhere)character, add_reserved_gold = X', supportedScopes: ['character'] },
  { name: 'add_scheme_cooldown', description: 'Sets a scheme cooldown for the scope character towards = { target=target_character type=scheme_type days/weeks/months/years = duration }', supportedScopes: ['character'] },
  { name: 'add_secret', description: 'Adds a secret', supportedScopes: ['character'], syntax: "add_secret = { type = X target = Y }\nNote that if you create a Secret in the immediate effect, the tooltips for other effects run in that Secret's scope (such as reveal_to) are likely to be displayed incorrectly, or not to be displayed at all. This is due to the game generating the tooltip before it actually has a Secret that exists to work off of.\nTest rigorously and use custom tooltips if necessary. Creating a Secret in the immediate and then running effects on it in an event option should produce perfectly normal tooltips." },
  { name: 'add_short_term_gold', description: 'Add gold to \'short term\' AI budget category, respecting maximums, overflow goes into Short Term budget. (gold will be created out of nowhere)character, add_short_term_gold = X', supportedScopes: ['character'] },
  { name: 'add_stewardship_lifestyle_perk_points', description: 'Adds lifestyle per points to the given character', supportedScopes: ['character'] },
  { name: 'add_stewardship_lifestyle_xp', description: 'Adds lifestyle XP to the given character', supportedScopes: ['character'] },
  { name: 'add_stress', description: 'increases (or decreases) stress of a character', supportedScopes: ['character'] },
  { name: 'add_targeting_factions_discontent', description: 'add_targeting_factions_discontent = X adds (or subtracts) discontent to all the factions that are targeting the scope character', supportedScopes: ['character'] },
  { name: 'add_to_activity', description: 'add_to_activity = activity', supportedScopes: ['character'], supportedTargets: ['activity'], syntax: "The scoped character is invited to and accepts an invitation to join the target activity, using their default travel plan" },
  { name: 'add_to_activity_without_travel', description: 'add_to_activity = activity', supportedScopes: ['character'], supportedTargets: ['activity'], syntax: "The scoped character is invited to and accepts an invitation to join the target activity, without adding a travel plan.\nThe character will need to be at the location or they will be kicked out of the activity." },
  { name: 'add_to_scheme', description: 'Adds a character as an agent to the scheme', supportedScopes: ['character'], supportedTargets: ['scheme'] },
  { name: 'add_trait', description: 'Adds a trait to a character (the trait will not be added and no tooltip will be shown if the character isn\'t eligible for the trait, i.e. when already having the trait, having an opposing trait, not fulfilling the trait\'s is_potential trigger or being outside of the trait\'s range)', supportedScopes: ['character'], supportedTargets: ['trait'] },
  { name: 'add_trait_force_tooltip', description: 'Adds a trait to a character (if the add_trait effect would not add the trait - i.e. when already having the trait, having an opposing trait, not fulfilling the trait\'s is_potential trigger or being outside of the trait\'s range - a tooltip will be shown but the trait will not be added)', supportedScopes: ['character'], supportedTargets: ['trait'] },
  { name: 'add_trait_xp', description: 'Adds XP to the trait level track for the scoped character. Track name is required if the trait has multiple tracks, otherwise should not be provided.', supportedScopes: ['character'], syntax: "add_trait_xp = { trait = <trait_key> track = <track_key> value = <script_value> }" },
  { name: 'add_truce_both_ways', description: 'Sets the both-way truce against the specified character', supportedScopes: ['character'], syntax: "'character' specifies the target character\n'override' says whether it should replace the previous truce even if shorter\n'years / months / days' sets the duration of the truce\n'result' specifies the result from the scope character's point of view ('white_peace' by default)\n'casus_belli' sets the casus belli scope that caused the truce, mutually exclusive with 'name'\n'name' sets a custom description. Dynamic description with the current scope\n'war' sets the war that caused the truce, mutually exclusive with 'casus_belli'\nadd_truce_both_ways = { character = X years/months/days = Y override = yes/no result = victory/defeat/white_peace casus_belli/war = Z }" },
  { name: 'add_truce_one_way', description: 'Sets the truce against the specified character', supportedScopes: ['character'], syntax: "'character' specifies the target character\n'override' says whether it should replace the previous truce even if shorter\n'years / months / days' sets the duration of the truce\n'result' specifies the result from the scope character's point of view ('white_peace' by default)\n'casus_belli' sets the casus belli scope that caused the truce, mutually exclusive with 'name'\n'name' sets a custom description. Dynamic description with the current scope\nadd_truce_one_way = { character = X years/months/days = Y override = yes/no result = victory/defeat/white_peace casus_belli/war = Z }" },
  { name: 'add_tyranny', description: 'adds (or removes) tyranny to (or from) a character', supportedScopes: ['character'] },
  { name: 'add_unpressed_claim', description: 'gives an unpressed claim to a character', supportedScopes: ['character'], supportedTargets: ['landed_title'] },
  { name: 'add_visiting_courtier', description: 'Add the target character as the scope character\'s guest', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'add_war_chest_gold', description: 'Add gold to \'war chest\' AI budget category, respecting maximums, overflow goes into Short Term budget. (gold will be created out of nowhere)character, add_war_chest_gold = X', supportedScopes: ['character'] },
  { name: 'adopt', description: 'Set scoped character as parent ot the targetscope:new_parent = { adopt = scope:offspring }', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'allow_alliance', description: 'Allows (previously broken) alliance with the target character', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'allow_in_scheme', description: 'Allow the character to join the scheme as an agent', supportedScopes: ['character'], supportedTargets: ['scheme'] },
  { name: 'apply_ai_vassal_obligation_liege_most_desired', description: 'Apply the new level for the most desired AI obligation level the liege in the contract wants', supportedScopes: ['character'] },
  { name: 'apply_ai_vassal_obligation_vassal_most_desired', description: 'Apply the new level for the most desired AI obligation level the vassal in the contract wants', supportedScopes: ['character'] },
  { name: 'appoint_court_position', description: 'Appoints the target character in target court position within scoped character\'s court', supportedScopes: ['character'], syntax: "recipient = character scope - target character to receive the title\ncourt_position = court position type - court position type to assign the receiver" },
  { name: 'assign_council_task', description: 'Assigns the target character to the council task', supportedScopes: ['character'], syntax: "assign_council_task = {\ncouncil_task = council_task_scope\ntarget = character_taking_the_position    fire_on_actions = [yes]\n}" },
  { name: 'assign_councillor_type', description: 'Assigns the target character to a council position of a specific type.', supportedScopes: ['character'], syntax: "If 'remove_existing_councillor = yes', any existing councillor is removed before assigning. (not fired)\nassign_councillor_type = {\ntype = <council_position_type_key>\ntarget = character_taking_the_position\nfire_on_actions = [yes]\nremove_existing_councillor = [no]\n}" },
  { name: 'banish', description: 'The character gets banished.', supportedScopes: ['character'] },
  { name: 'becomes_independent', description: 'becomes and independent ruler. becomes_independent = { change = \'previously created title_and_vassal_change\'', supportedScopes: ['character'] },
  { name: 'break_alliance', description: 'Breaks the alliance with the target character', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'cancel_truce_both_ways', description: 'Ends the truce against the specified character, and theirs against the scoped character. cancel_truce_both_ways = scope:character', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'cancel_truce_one_way', description: 'Ends the truce against the specified character. cancel_truce_one_way = scope:character', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'change_age', description: 'Changes the character\'s age by the given amount. Sets age to 0 if it\'d end up below 0. Note that this will completely bypass birthday on-actions, age-related health, and so on, just like the console command', supportedScopes: ['character'], syntax: "Usage: change_age = script value" },
  { name: 'change_current_court_grandeur', description: 'Changes the current court grandeur of a character with a royal court, clamped between NRoyalCourt::COURT_GRANDEUR_MIN and NRoyalCourt::COURT_GRANDEUR_MAX.', supportedScopes: ['character'] },
  { name: 'change_current_weight', description: 'Change the current weight of the scoped character', supportedScopes: ['character'], syntax: "change_current_weight = 20" },
  { name: 'change_diarchy_swing', description: 'Change scales of power swing for the active diarchy', supportedScopes: ['character'], syntax: "change_diarchy_swing = -5" },
  { name: 'change_first_name', description: 'Change the first name of a character', supportedScopes: ['character'], syntax: "change_first_name = <localization_key>\nchange_first_name = scope:name/var:name # containing a flag with a localization key\nchange_first_name = { template_character = scope:character } # copy name from the template character" },
  { name: 'change_government', description: 'changes the government of a character', supportedScopes: ['character'] },
  { name: 'change_liege', description: '= { liege = \'Character that should become the new liege\' change = \'previously created title_and_vassal_change\', adds a liege change', supportedScopes: ['character'] },
  { name: 'change_prison_type', description: 'Changes the charater\'s prison type. Scoped character is the prisoner. Accepts any static modifier (see also improson effect).', supportedScopes: ['character'], syntax: "change_prison_type = house_arrest" },
  { name: 'change_strife_opinion', description: 'Change strife opinion caused by the scoped character', supportedScopes: ['character'], syntax: "scope:diarch = { change_strife_opinion = 15 }" },
  { name: 'change_target_weight', description: 'Change the target weight of the scoped character', supportedScopes: ['character'], syntax: "change_target_weight = 20" },
  { name: 'change_trait_rank', description: 'Changes the trait rank = { trait = trait_group rank = change max = maximum new rank }', supportedScopes: ['character'] },
  { name: 'clear_forced_vote', description: 'Clears forced voting', supportedScopes: ['character'], syntax: "clear_forced_vote = yes" },
  { name: 'complete_activity_intent', description: 'complete_activity_intent = bool', supportedScopes: ['character'], syntax: "Complete the scoped character's current intent in their involved activity" },
  { name: 'consume_banish_reasons', description: '\'Consume\' all banish reasons that the scoped character has on the target character. Until they get a new reason, they cannot banish the target again.', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'consume_divorce_reasons', description: '\'Consume\' all divorce reason that the scoped character has on the target character. Until they get a new reason, they cannot divorce the target again.', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'consume_execute_reasons', description: '\'Consume\' all execute reasons that the scoped character has on the target character. Until they get a new reason, they cannot execute the target again.', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'consume_imprisonment_reasons', description: '\'Consume\' all imprisonment reasons that the scoped character has on the target character. Until they get a new reason, they cannot imprison the target again.', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'consume_revoke_title_reason', description: '\'Consume\' 1 revoke title reason that the scoped character has on the target character.', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'copy_inheritable_appearance_from', description: 'copies the inheritable appearance attributes (inheritable genes in the character\'s DNA string) from the target character to the scoped character', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'copy_localized_text', description: 'Copies a piece of localized text from the target character for the given key.', supportedScopes: ['character'], syntax: "copy_localized_text = { key = key target = character }" },
  { name: 'create_alliance', description: 'Create an alliance between the scoped character and the target. The allied through characters determine who gets checked against for if the alliance should persist or not.', supportedScopes: ['character'], syntax: "create_alliance = {\ntarget = scope\nallied_through_owner = scope\nallied_through_target = scope\n}\nOR as a short hand use just the target to use the owner and target as the allied through characters\ncreate_alliance = scope" },
  { name: 'create_artifact', description: 'Creates a new artifact and adds it to the inventory of the given character', supportedScopes: ['character'], syntax: "Be aware that we make use of the current scopes implicitly. This is done in common/artifacts/visuals\nname = dynamic description - artifact name\ndescription = dynamic description - artifact description\nrarity = enum - artifact rarity, ex. legendary\ntype = flag - inventory slot type, ex. trinket\nmodifier = static modifier - applied to the character whom wields this artifact\ndurability = script value - new durability, will be max by default\nmax_durability = script value - Optional. A value for the max durability, which would override the one normally assigned by the defines\ndecaying = yes/no - Optional. Set if artifact decays with time. Yes by default\nhistory = artifact history entry - custom history entry to denote for example that this is artifact was reforged by someone else than the owner\ntype = artifact history entry type - available types:\ncreated_before_history\ncreated\nprize_created\ndiscovered\ncreator_discovered\nclaimed_by_house\ngiven\nstolen\ninherited\nconquest\ntaken_in_siege\ntaken_in_battle\nwon_in_duel\npurchased\nprize_awarded\nransomed\nreforged\ntemplate = artifact scripted template - a scripted base template with triggers and modifiers\nvisuals = artifact visual type - how this artifact should appear visually\ngenerate_history = bool - automatically generate a new history entry if none has been scripted?\nquality = script value - new quality, used in AI scoring\nwealth = script value - new wealth, used in AI scoring\ncreator = character scope - set a custom creator of the artifact ( default is the owner )\nvisuals_source = scope containing landed title, dynasty or house - set a source of coat of arms graphics for the artifact\n(only few artifact models actually make use of it. Most notable - banners)\nsave_scope_as = new artifact - an optional way to get a reference to the newly created artifact\ntitle_history = title - history entries of the given title will be added to the artifact history\ntitle_history_date = game date - from which date onwards to copy historical entries from given title\ncreator = character scope - set a custom creator of the artifact ( default is the owner )" },
  { name: 'create_cadet_branch', description: 'The scope character creates a cadet branch of the house he is in [yes|no]', supportedScopes: ['character'] },
  { name: 'create_character_memory', description: 'Creates a memory for the character of a given type and participants plus an optional duration. Saved as scope:new_memory.', supportedScopes: ['character'], syntax: "create_character_memory = { type = memory_type participants = { tag = scope } duration = { years = 3 } }" },
  { name: 'create_divergent_culture', description: 'Creates a new divergent culture from the scope character\'s culture. The new culture will keep all pillars and traditions of the parent culture ï¿½ it is up to the user to add or remove pillars and traditions as appropriate.The new divergent culture is saved as scope:new_culture.', supportedScopes: ['character'], syntax: "create_divergent_culture = yes" },
  { name: 'create_divergent_culture_with_side_effects', description: 'Creates a new divergent culture from the scope character\'s culture. This also incurs the cost, does conversion, and such, just as if you\'d diverged via the UI. Unlike create_divergent_culture, it will change ethos and suchThe new culture is NOT saved as a scope due to technical limitations.', supportedScopes: ['character'], syntax: "create_divergent_culture_with_side_effects = yes" },
  { name: 'create_divergent_culture_with_side_effects_excluding_cost', description: 'Creates a new divergent culture from the scope character\'s culture. Ignores the cost, does conversion, and such, just as if you\'d diverged via the UI. Unlike create_divergent_culture, it will change ethos and suchThe new culture is NOT saved as a scope due to technical limitations.', supportedScopes: ['character'], syntax: "create_divergent_culture_with_side_effects_excluding_cost = yes" },
  { name: 'create_faction', description: 'the scoped character creates a faction of the specified type against the specified target, create_faction = { type = X target = Y }', supportedScopes: ['character'] },
  { name: 'create_hybrid_culture', description: 'Creates a new hybrid culture from the scope character\'s culture and the RHS culture. The new culture will have a random mix of pillars and traditions from both, like when the AI hybridizes. The new hybrid culture is saved as scope:new_culture.', supportedScopes: ['character'], supportedTargets: ['culture'], syntax: "create_hybrid_culture = culture:anglo-saxon" },
  { name: 'create_hybrid_culture_with_side_effects', description: 'Creates a new hybrid culture from the scope character\'s culture and the RHS culture. The new culture will have a random mix of pillars and traditions from both, like when the AI hybridizes. This also incurs the cost, does conversion, and such, just as if you\'d hybridized via the UI. The new hybrid culture is NOT saved as a scope due to technical limitations.', supportedScopes: ['character'], supportedTargets: ['culture'], syntax: "create_hybrid_culture_with_side_effects = culture:anglo-saxon" },
  { name: 'create_inspiration', description: 'create_inspiration = inspiration_type', supportedScopes: ['character'], syntax: "Creates an inspiration of a given type owned by scoped character, new inspiration is saved as scope:new_inspiration\ncreate_inspiration = { type = inspiration_type gold = script_value }\nAs above but overrides the base cost compared to the one defined in the type" },
  { name: 'create_story', description: 'creates and initializes a story cycle with the current character as owner', supportedScopes: ['character'], syntax: "create_story = story_type\ncreate_story = {\ntype = story_type\nsave_scope_as/save_temporary_scope_as = scope_name # optional way to get a reference to the new story}" },
  { name: 'death', description: 'kills a character, death = { killer = X death_reason = Y artifact = Z }, where X is a character and Y is one of the death reason keys. Optionally artifact Z will be used as the killing artifact instead of the defaulted one from the killer\'s slot for that death reason\'s definition. Or death = natural which will pick a natural death reason to kill the character from.', supportedScopes: ['character'] },
  { name: 'decline_activity_invite', description: 'decline_activity_invite = activity', supportedScopes: ['character'], supportedTargets: ['activity'], syntax: "The scoped character declines the invitation to the target activity" },
  { name: 'depose', description: 'The character gets deposed.', supportedScopes: ['character'] },
  { name: 'depose_diarch', description: 'Current scoped diarch is deposed and replaced with the next from the line of succession', supportedScopes: ['character'], syntax: "depose_diarch = yes/no" },
  { name: 'designate_diarch', description: 'Designated target character as a future diarch', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'destroy_title', description: 'Destroys a title', supportedScopes: ['character'], supportedTargets: ['landed_title'] },
  { name: 'end_diarchy', description: 'End diarchy for the character', supportedScopes: ['character'], syntax: "end_diarchy = yes/no" },
  { name: 'end_pregnancy', description: 'end a pregnancy', supportedScopes: ['character'] },
  { name: 'every_acclaimed_knight', description: 'Iterate through all acclaimed knights employed by a given character', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_acclaimed_knight = { limit = { <triggers> } <effects> }" },
  { name: 'every_accolade', description: 'Iterate through all ( active and inactive ) Accolades of a given liege character\'s Acclaimed Knights', supportedScopes: ['character'], supportedTargets: ['accolade'], outputScope: 'accolade', isIterator: true, syntax: "every_accolade = { limit = { <triggers> } <effects> }" },
  { name: 'every_active_accolade', description: 'Iterate through all active Accolades of a given liege character\'s Acclaimed Knights', supportedScopes: ['character'], supportedTargets: ['accolade'], outputScope: 'accolade', isIterator: true, syntax: "every_active_accolade = { limit = { <triggers> } <effects> }" },
  { name: 'every_alert_creatable_title', description: 'Iterate through all titles that can be created by the character. (only for alerts)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_alert_creatable_title = { limit = { <triggers> } <effects> }" },
  { name: 'every_alert_usurpable_title', description: 'Iterate through all titles that can be usurped by the character. (only for alerts)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_alert_usurpable_title = { limit = { <triggers> } <effects> }" },
  { name: 'every_ally', description: 'Iterate through all allies', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_ally = { limit = { <triggers> } <effects> }" },
  { name: 'every_ancestor', description: 'Iterate through all the ancestors of the scope character up to 5 generations', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_ancestor = { limit = { <triggers> } <effects> }" },
  { name: 'every_army', description: 'Iterate through all armies', supportedScopes: ['character'], supportedTargets: ['army'], outputScope: 'army', isIterator: true, syntax: "every_army = { limit = { <triggers> } <effects> }" },
  { name: 'every_character_artifact', description: 'Iterate through all artifacts in a given characters inventory', supportedScopes: ['character'], supportedTargets: ['artifact'], outputScope: 'artifact', isIterator: true, syntax: "every_character_artifact = { limit = { <triggers> } <effects> }" },
  { name: 'every_character_struggle', description: 'Iterate through all struggles that character is involved in. Optional: Narrow down the involvement status *_chracter_struggle = { involvement = involved | interloper }', supportedScopes: ['character'], supportedTargets: ['struggle'], outputScope: 'struggle', isIterator: true, syntax: "every_character_struggle = { limit = { <triggers> } <effects> }" },
  { name: 'every_character_to_title_neighboring_and_across_water_county', description: 'Scopes from a character to a neighboring county (incl. across water, looking trough the de Jure lieges)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_character_to_title_neighboring_and_across_water_county = { limit = { <triggers> } <effects> }" },
  { name: 'every_character_to_title_neighboring_and_across_water_duchy', description: 'Scopes from a character to a neighboring duchy (incl. across water, looking trough the de Jure lieges)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_character_to_title_neighboring_and_across_water_duchy = { limit = { <triggers> } <effects> }" },
  { name: 'every_character_to_title_neighboring_and_across_water_empire', description: 'Scopes from a character to a neighboring empire (incl. across water, looking trough the de Jure lieges)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_character_to_title_neighboring_and_across_water_empire = { limit = { <triggers> } <effects> }" },
  { name: 'every_character_to_title_neighboring_and_across_water_kingdom', description: 'Scopes from a character to a neighboring kingdom (incl. across water, looking trough the de Jure lieges)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_character_to_title_neighboring_and_across_water_kingdom = { limit = { <triggers> } <effects> }" },
  { name: 'every_character_to_title_neighboring_county', description: 'Scopes from a character to a neighboring county (looking trough the de Jure lieges)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_character_to_title_neighboring_county = { limit = { <triggers> } <effects> }" },
  { name: 'every_character_to_title_neighboring_duchy', description: 'Scopes from a character to a neighboring duchy (looking trough the de Jure lieges)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_character_to_title_neighboring_duchy = { limit = { <triggers> } <effects> }" },
  { name: 'every_character_to_title_neighboring_empire', description: 'Scopes from a character to a neighboring empire (looking trough the de Jure lieges)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_character_to_title_neighboring_empire = { limit = { <triggers> } <effects> }" },
  { name: 'every_character_to_title_neighboring_kingdom', description: 'Scopes from a character to a neighboring kingdom (looking trough the de Jure lieges)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_character_to_title_neighboring_kingdom = { limit = { <triggers> } <effects> }" },
  { name: 'every_character_trait', description: 'Iterate through all traits a character has', supportedScopes: ['character'], supportedTargets: ['trait'], outputScope: 'trait', isIterator: true, syntax: "every_character_trait = { limit = { <triggers> } <effects> }" },
  { name: 'every_character_war', description: 'Wars of the scoped character', supportedScopes: ['character'], supportedTargets: ['war'], outputScope: 'war', isIterator: true, syntax: "every_character_war = { limit = { <triggers> } <effects> }" },
  { name: 'every_child', description: 'Iterate through all children', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_child = { limit = { <triggers> } <effects> }" },
  { name: 'every_claim', description: 'Iterate through the titles of all claims held by a character; parameters: explicit = yes/no/all pressed = yes/no/all', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_claim = { limit = { <triggers> } <effects> }" },
  { name: 'every_claimed_artifact', description: 'Iterate through all claimed artifacts of the scoped character', supportedScopes: ['character'], supportedTargets: ['artifact'], outputScope: 'artifact', isIterator: true, syntax: "every_claimed_artifact = { limit = { <triggers> } <effects> }" },
  { name: 'every_close_family_member', description: 'Iterate through all the close family [father, mother, siblings, children, grandparents]', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_close_family_member = { limit = { <triggers> } <effects> }" },
  { name: 'every_close_or_extended_family_member', description: 'Iterate through all the close and extended relatives [father, mother, siblings, children, grandparents, uncles/aunts, nephew/niece, cousins]', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_close_or_extended_family_member = { limit = { <triggers> } <effects> }" },
  { name: 'every_concubine', description: 'Iterate through all concubines', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_concubine = { limit = { <triggers> } <effects> }" },
  { name: 'every_consort', description: 'Iterate through all consorts (concubines and spouses)', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_consort = { limit = { <triggers> } <effects> }" },
  { name: 'every_councillor', description: 'Iterate through all councillors', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_councillor = { limit = { <triggers> } <effects> }" },
  { name: 'every_court_position_employer', description: 'Iterates through all characters that employ the scoped character in any court position.', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_court_position_employer = { limit = { <triggers> } <effects> }" },
  { name: 'every_court_position_holder', description: 'Iterates through all characters employed by the scoped character in the target court position.', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_court_position_holder = { limit = { <triggers> } <effects> }" },
  { name: 'every_courtier', description: 'Iterate through all courtiers', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_courtier = { limit = { <triggers> } <effects> }" },
  { name: 'every_courtier_away', description: 'Iterate through all courtiers that are away', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_courtier_away = { limit = { <triggers> } <effects> }" },
  { name: 'every_courtier_or_guest', description: 'Iterate through all courtiers and guests (pool and foreign court guests)', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_courtier_or_guest = { limit = { <triggers> } <effects> }" },
  { name: 'every_de_jure_claim', description: 'Iterate through all de jure claims for a character', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_de_jure_claim = { limit = { <triggers> } <effects> }" },
  { name: 'every_diarchy_succession_character', description: 'Iterate through all character in the diarchy line of succession.If there\'s no active diarchy or active one doesn\'t have succession,it iterates over regency candidates', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_diarchy_succession_character = { limit = { <triggers> } <effects> }" },
  { name: 'every_diplomacy_councillor', description: 'Iterate through all diplomacy-based councillors', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_diplomacy_councillor = { limit = { <triggers> } <effects> }" },
  { name: 'every_directly_owned_province', description: 'Iterate through all directly owned provinces', supportedScopes: ['character'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, syntax: "every_directly_owned_province = { limit = { <triggers> } <effects> }" },
  { name: 'every_election_title', description: 'Iterate through all titles the scoped character can vote on', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_election_title = { limit = { <triggers> } <effects> }" },
  { name: 'every_equipped_character_artifact', description: 'Iterate through all equipped artifacts in a given characters inventory', supportedScopes: ['character'], supportedTargets: ['artifact'], outputScope: 'artifact', isIterator: true, syntax: "every_equipped_character_artifact = { limit = { <triggers> } <effects> }" },
  { name: 'every_extended_family_member', description: 'Iterate through all the extended family [uncles/aunts, nephew/niece, cousins]', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_extended_family_member = { limit = { <triggers> } <effects> }" },
  { name: 'every_foreign_court_guest', description: 'Iterate through all guests visiting from another court (in contrast to pool_guest they have a liege)', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_foreign_court_guest = { limit = { <triggers> } <effects> }" },
  { name: 'every_former_concubine', description: 'Iterate through all former concubines. Not persisted past death', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_former_concubine = { limit = { <triggers> } <effects> }" },
  { name: 'every_former_concubinist', description: 'Iterate through all former concubinists. Not persisted past death', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_former_concubinist = { limit = { <triggers> } <effects> }" },
  { name: 'every_former_spouse', description: 'Iterate through all former spouses', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_former_spouse = { limit = { <triggers> } <effects> }" },
  { name: 'every_general_councillor', description: 'Iterate through all councillors that are not related to a skill', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_general_councillor = { limit = { <triggers> } <effects> }" },
  { name: 'every_heir', description: 'Heirs of the scoped character', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_heir = { limit = { <triggers> } <effects> }" },
  { name: 'every_heir_title', description: 'Iterate through all landed titles character is heir to', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_heir_title = { limit = { <triggers> } <effects> }" },
  { name: 'every_heir_to_title', description: 'Iterate through all titles the scoped character is heir to', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_heir_to_title = { limit = { <triggers> } <effects> }" },
  { name: 'every_held_title', description: 'Iterate through all held landed titles', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_held_title = { limit = { <triggers> } <effects> }" },
  { name: 'every_hired_mercenary', description: 'Iterate through all hired mercenary companies', supportedScopes: ['character'], supportedTargets: ['mercenary_company'], outputScope: 'mercenary_company', isIterator: true, syntax: "every_hired_mercenary = { limit = { <triggers> } <effects> }" },
  { name: 'every_home_court_hostage', description: 'Iterate through all hostages currently abroad', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_home_court_hostage = { limit = { <triggers> } <effects> }" },
  { name: 'every_hooked_character', description: 'Iterate through all characters this character has a hook on', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_hooked_character = { limit = { <triggers> } <effects> }" },
  { name: 'every_hostile_raider', description: 'Iterate through anyone the character is hostile to due to their top-liege\'s realm having been raided', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_hostile_raider = { limit = { <triggers> } <effects> }" },
  { name: 'every_intrigue_councillor', description: 'Iterate through all intrigue-based councillors', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_intrigue_councillor = { limit = { <triggers> } <effects> }" },
  { name: 'every_invited_activity', description: 'Iterate through all activities a character has been invited to', supportedScopes: ['character'], supportedTargets: ['activity'], outputScope: 'activity', isIterator: true, syntax: "every_invited_activity = { limit = { <triggers> } <effects> }" },
  { name: 'every_knight', description: 'Iterate through all knights', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_knight = { limit = { <triggers> } <effects> }" },
  { name: 'every_known_secret', description: 'Iterate through all secrets known by the character', supportedScopes: ['character'], supportedTargets: ['secret'], outputScope: 'secret', isIterator: true, syntax: "every_known_secret = { limit = { <triggers> } <effects> }" },
  { name: 'every_learning_councillor', description: 'Iterate through all learning-based councillors', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_learning_councillor = { limit = { <triggers> } <effects> }" },
  { name: 'every_liege_or_above', description: 'Iterate through all lieges above a character (skipping the character themselves)', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_liege_or_above = { limit = { <triggers> } <effects> }" },
  { name: 'every_martial_councillor', description: 'Iterate through all martial-based councillors', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_martial_councillor = { limit = { <triggers> } <effects> }" },
  { name: 'every_memory', description: 'Iterate through all memories of a character', supportedScopes: ['character'], supportedTargets: ['character_memory'], outputScope: 'character_memory', isIterator: true, syntax: "every_memory = { limit = { <triggers> } <effects> }" },
  { name: 'every_neighboring_and_across_water_realm_same_rank_owner', description: 'A sub-realm or realm bordering the scope character\'s realm (including across water) and has the same rank as the scope character (look for lieges of he owner of the land if necessary)', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_neighboring_and_across_water_realm_same_rank_owner = { limit = { <triggers> } <effects> }" },
  { name: 'every_neighboring_and_across_water_top_liege_realm', description: 'A realm with a different top liege neighboring the realm of the scope character\'s top liege (including across water); switches to the realm\'s top title. Can be based on borders a day or two out of date', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_neighboring_and_across_water_top_liege_realm = { limit = { <triggers> } <effects> }" },
  { name: 'every_neighboring_and_across_water_top_liege_realm_owner', description: 'A realm with a different top liege neighboring the realm of the scope character\'s top liege (including across water); switches to the holder of the realm. Can be based on borders a day or two out of date', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_neighboring_and_across_water_top_liege_realm_owner = { limit = { <triggers> } <effects> }" },
  { name: 'every_neighboring_realm_same_rank_owner', description: 'A sub-realm or realm bordering the scope character\'s realm and has the same rank as the scope character (look for lieges of he owner of the land if necessary)', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_neighboring_realm_same_rank_owner = { limit = { <triggers> } <effects> }" },
  { name: 'every_neighboring_top_liege_realm', description: 'A realm with a different top liege neighboring the realm of the scope character\'s top liege; switches to the realm\'s top title. Can be based on borders a day or two out of date', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_neighboring_top_liege_realm = { limit = { <triggers> } <effects> }" },
  { name: 'every_neighboring_top_liege_realm_owner', description: 'A realm with a different top liege neighboring the realm of the scope character\'s top liege; switches to the holder of the realm. Can be based on borders a day or two out of date', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_neighboring_top_liege_realm_owner = { limit = { <triggers> } <effects> }" },
  { name: 'every_opposite_sex_spouse_candidate', description: 'Iterate through all the spouse candidates of the opposite sex of a character.', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "WARNING: THIS IS VERY SLOW DO NOT DO IT OFTEN.\nevery_opposite_sex_spouse_candidate = { limit = { <triggers> } <effects> }" },
  { name: 'every_owned_story', description: 'Iterate through all owned stories for a character', supportedScopes: ['character'], supportedTargets: ['story'], outputScope: 'story', isIterator: true, syntax: "every_owned_story = { limit = { <triggers> } <effects> }" },
  { name: 'every_parent', description: 'Iterate through all (both) parents', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_parent = { limit = { <triggers> } <effects> }" },
  { name: 'every_patroned_holy_order', description: 'Iterate through all holy orders that the scoped character is a patron of', supportedScopes: ['character'], supportedTargets: ['holy_order'], outputScope: 'holy_order', isIterator: true, syntax: "every_patroned_holy_order = { limit = { <triggers> } <effects> }" },
  { name: 'every_personal_claimed_artifact', description: 'Iterate through all personally claimed artifacts of the scoped character', supportedScopes: ['character'], supportedTargets: ['artifact'], outputScope: 'artifact', isIterator: true, syntax: "every_personal_claimed_artifact = { limit = { <triggers> } <effects> }" },
  { name: 'every_pinned_character', description: 'Iterate through characters this player has pinned', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_pinned_character = { limit = { <triggers> } <effects> }" },
  { name: 'every_pinning_character', description: 'Iterate through characters whose player has this character pinned', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_pinning_character = { limit = { <triggers> } <effects> }" },
  { name: 'every_played_character', description: 'Iterate through all characters the player playing this character has played. Matches the game over legacy, except for excluding the currently played character', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_played_character = { limit = { <triggers> } <effects> }" },
  { name: 'every_player_heir', description: 'Iterate through player heirs, capped at the first 10', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_player_heir = { limit = { <triggers> } <effects> }" },
  { name: 'every_pool_guest', description: 'Iterate through all guests visiting the court from the pool (in contrast to foreign_court_guest they don\'t have a liege)', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_pool_guest = { limit = { <triggers> } <effects> }" },
  { name: 'every_potential_marriage_option', description: 'Iterate through all potential selectable marriage or betrohed options', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_potential_marriage_option = { limit = { <triggers> } <effects> }" },
  { name: 'every_powerful_vassal', description: 'Iterate through the all powerful vassals of a character', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_powerful_vassal = { limit = { <triggers> } <effects> }" },
  { name: 'every_pretender_title', description: 'Iterate through all landed titles character is pretender to', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_pretender_title = { limit = { <triggers> } <effects> }" },
  { name: 'every_primary_war_enemy', description: 'Iterate through all primary war enemies', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_primary_war_enemy = { limit = { <triggers> } <effects> }" },
  { name: 'every_prisoner', description: 'Iterate through all prisoners', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_prisoner = { limit = { <triggers> } <effects> }" },
  { name: 'every_prowess_councillor', description: 'Iterate through all prowess-based councillors', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_prowess_councillor = { limit = { <triggers> } <effects> }" },
  { name: 'every_raid_target', description: 'Iterate through anyone the character is hostile to due to having raided them. Only returns top lieges', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_raid_target = { limit = { <triggers> } <effects> }" },
  { name: 'every_realm_county', description: 'Iterate through all counties in the realm. Based on top liege', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_realm_county = { limit = { <triggers> } <effects> }" },
  { name: 'every_realm_de_jure_duchy', description: 'Iterate through all de jure duchies that have at least one county in the realm. Based on top liege', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_realm_de_jure_duchy = { limit = { <triggers> } <effects> }" },
  { name: 'every_realm_de_jure_empire', description: 'Iterate through all de jure empire that have at least one county in the realm. Based on top liege', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_realm_de_jure_empire = { limit = { <triggers> } <effects> }" },
  { name: 'every_realm_de_jure_kingdom', description: 'Iterate through all de jure kingdom that have at least one county in the realm. Based on top liege', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_realm_de_jure_kingdom = { limit = { <triggers> } <effects> }" },
  { name: 'every_realm_province', description: 'Iterate through all realm provinces of a character', supportedScopes: ['character'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, syntax: "every_realm_province = { limit = { <triggers> } <effects> }" },
  { name: 'every_relation', description: 'Iterate through scripted relations of a given type or multiple types, if someone is multiple relations they will only be in the list once', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_relation = { limit = { <triggers> } <effects> }" },
  { name: 'every_same_sex_spouse_candidate', description: 'Iterate through all the spouse candidates of the same sex of a character.', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "WARNING: THIS IS VERY SLOW DO NOT DO IT OFTEN.\nevery_same_sex_spouse_candidate = { limit = { <triggers> } <effects> }" },
  { name: 'every_scheme', description: 'Iterate through all schemes owned by the character', supportedScopes: ['character'], supportedTargets: ['scheme'], outputScope: 'scheme', isIterator: true, syntax: "every_scheme = { limit = { <triggers> } <effects> }" },
  { name: 'every_secret', description: 'Iterate through all secrets of the character', supportedScopes: ['character'], supportedTargets: ['secret'], outputScope: 'secret', isIterator: true, syntax: "every_secret = { limit = { <triggers> } <effects> }" },
  { name: 'every_sibling', description: 'Iterate through all siblings', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_sibling = { limit = { <triggers> } <effects> }" },
  { name: 'every_sponsored_inspiration', description: 'Iterate through all sponsored inspirations', supportedScopes: ['character'], supportedTargets: ['inspiration'], outputScope: 'inspiration', isIterator: true, syntax: "every_sponsored_inspiration = { limit = { <triggers> } <effects> }" },
  { name: 'every_spouse', description: 'Iterate through all spouses', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_spouse = { limit = { <triggers> } <effects> }" },
  { name: 'every_spouse_candidate', description: 'Iterate through all the spouse candidates of a character.', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "WARNING: THIS IS VERY SLOW DO NOT DO IT OFTEN.\nevery_spouse_candidate = { limit = { <triggers> } <effects> }" },
  { name: 'every_stewardship_councillor', description: 'Iterate through all stewardship-based councillors', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_stewardship_councillor = { limit = { <triggers> } <effects> }" },
  { name: 'every_sub_realm_barony', description: 'Iterate through all baronies in sub-realm', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_sub_realm_barony = { limit = { <triggers> } <effects> }" },
  { name: 'every_sub_realm_county', description: 'Iterate through all counties in sub-realm', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_sub_realm_county = { limit = { <triggers> } <effects> }" },
  { name: 'every_sub_realm_duchy', description: 'Iterate through all duchies in sub-realm', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_sub_realm_duchy = { limit = { <triggers> } <effects> }" },
  { name: 'every_sub_realm_empire', description: 'Iterate through all empires in sub-realm', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_sub_realm_empire = { limit = { <triggers> } <effects> }" },
  { name: 'every_sub_realm_kingdom', description: 'Iterate through all kingdoms in sub-realm', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_sub_realm_kingdom = { limit = { <triggers> } <effects> }" },
  { name: 'every_sub_realm_title', description: 'Iterate through all titles in sub-realm', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_sub_realm_title = { limit = { <triggers> } <effects> }" },
  { name: 'every_targeting_faction', description: 'Iterate through all factions targeting the scope character', supportedScopes: ['character'], supportedTargets: ['faction'], outputScope: 'faction', isIterator: true, syntax: "every_targeting_faction = { limit = { <triggers> } <effects> }" },
  { name: 'every_targeting_scheme', description: 'Iterate through all schemes targeting the character', supportedScopes: ['character'], supportedTargets: ['scheme'], outputScope: 'scheme', isIterator: true, syntax: "every_targeting_scheme = { limit = { <triggers> } <effects> }" },
  { name: 'every_targeting_secret', description: 'Iterate through all secrets that target the specified scope', supportedScopes: ['character'], supportedTargets: ['secret'], outputScope: 'secret', isIterator: true, syntax: "every_targeting_secret = { limit = { <triggers> } <effects> }" },
  { name: 'every_traveling_family_member', description: 'Iterate though all characters that should travel with the scoped one (when moving between courts for instance); includes the scoped character', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_traveling_family_member = { limit = { <triggers> } <effects> }" },
  { name: 'every_truce_holder', description: 'Iterate through all characters that have a truce on this character', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_truce_holder = { limit = { <triggers> } <effects> }" },
  { name: 'every_truce_target', description: 'Iterate through all characters this character has a truce on', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_truce_target = { limit = { <triggers> } <effects> }" },
  { name: 'every_unspent_known_secret', description: 'Iterate through all unspent secrets known by the character', supportedScopes: ['character'], supportedTargets: ['secret'], outputScope: 'secret', isIterator: true, syntax: "every_unspent_known_secret = { limit = { <triggers> } <effects> }" },
  { name: 'every_vassal', description: 'Iterate through all DIRECT vassals', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_vassal = { limit = { <triggers> } <effects> }" },
  { name: 'every_vassal_or_below', description: 'Iterate through ALL vassals, not just direct vassals', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_vassal_or_below = { limit = { <triggers> } <effects> }" },
  { name: 'every_war_ally', description: 'Iterate through all direct war allies', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_war_ally = { limit = { <triggers> } <effects> }" },
  { name: 'every_war_enemy', description: 'Iterate through all direct war enemies', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_war_enemy = { limit = { <triggers> } <effects> }" },
  { name: 'every_warden_hostage', description: 'Iterate through all hostages having this warden', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_warden_hostage = { limit = { <triggers> } <effects> }" },
  { name: 'execute_decision', description: 'Execute the specified decision for the scoped character', supportedScopes: ['character'], supportedTargets: ['decision'] },
  { name: 'finish_council_task', description: 'The councillor finish the current assigned task successfully.', supportedScopes: ['character'] },
  { name: 'fire_councillor', description: 'The scope character fires the target character from the council.', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'forbid_from_scheme', description: 'Forbid the scope character from joining the target scheme as an agent (and kick the character out if already in the scheme)', supportedScopes: ['character'], supportedTargets: ['scheme'] },
  { name: 'force_add_to_scheme', description: 'Adds a character as an agent to the scheme and forces them to stay', supportedScopes: ['character'], syntax: "{\nscheme = target_Scheme\ndays/months/years = duration\n}" },
  { name: 'force_character_skill_recalculation', description: 'Forces a character\'s skills to be recalculated immediately, bypassing the wait for the daily tick.', supportedScopes: ['character'], syntax: "NOTE: Only use this when *absolutely* necessary, as it will impact performance negatively if misused\nUsage: force_character_skill_recalculation = yes/no" },
  { name: 'force_vote_as', description: 'Forces the character to vote the same as the target', supportedScopes: ['character'], syntax: "force_vote_as = { target = someone days/months/years = x }" },
  { name: 'get_title', description: 'gives a title to a character', supportedScopes: ['character'], supportedTargets: ['landed_title'] },
  { name: 'give_nickname', description: 'Give a nickname to this character', supportedScopes: ['character'] },
  { name: 'imprison', description: 'Imprisons the target character as this character\'s prisoner, imprison = { target = X reason = Y type = Z }, where X is a character, Y is a flag, Z is a static modifier', supportedScopes: ['character'] },
  { name: 'invalidate_diarch_if_needed', description: 'Immediately check if diarch should be invalidated', supportedScopes: ['character'], syntax: "If needed, current scoped diarch is removed and replaced\nwith the next one from the line of succession\nscope:diarch = { invalidate_diarch_if_needed = yes/no }" },
  { name: 'invite_to_activity', description: 'invite_to_activity = activity', supportedScopes: ['character'], supportedTargets: ['activity'], syntax: "The scoped character is invited to the target activity" },
  { name: 'join_faction', description: 'the character in the scope joins the assigned faction', supportedScopes: ['character'], supportedTargets: ['faction'] },
  { name: 'join_faction_forced', description: 'the character in the scope is forced to join a faction by a character for a defined time,', supportedScopes: ['character'], syntax: "join_faction_forced = {\nfaction = X\nforced_by = Y\ndays/months/years = duration\n}" },
  { name: 'join_faction_skip_check', description: 'the character in the scope joins the assigned faction skiping the can_character_join trigger', supportedScopes: ['character'], supportedTargets: ['faction'] },
  { name: 'learn_court_language_of', description: 'The character learns the court language of the target characterlearn_court_language_of = scope:target_character', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'learn_language', description: 'The character learns the languagelearn_language = language_norwegian', supportedScopes: ['character'] },
  { name: 'learn_language_of_culture', description: 'The character learns the language of the target culturelearn_language_of_culture = scope:target_culture', supportedScopes: ['character'], supportedTargets: ['culture'] },
  { name: 'leave_faction', description: 'the charcter in the scope leaves the assigned faction', supportedScopes: ['character'], supportedTargets: ['faction'] },
  { name: 'make_claim_strong', description: 'makes a claim strong (character adds the claim if not having it already)', supportedScopes: ['character'], supportedTargets: ['landed_title'] },
  { name: 'make_claim_weak', description: 'makes a claim weak (character adds the claim if not having it already)', supportedScopes: ['character'], supportedTargets: ['landed_title'] },
  { name: 'make_concubine', description: 'Makes the target character a concubine of the scope character, the target should not be imprisoned', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'make_pregnant', description: 'makes a character pregnant', supportedScopes: ['character'], syntax: "father= 'the real father'\nnumber_of_children= X\nknown_bastard=yes/no" },
  { name: 'make_pregnant_no_checks', description: 'makes a character pregnant. Doesn\'t error on things like celibacy', supportedScopes: ['character'], syntax: "father= 'the real father'\nnumber_of_children= X\nknown_bastard=yes/no" },
  { name: 'make_trait_active', description: 'Activates an inactive trait. Tooltip will not be shown if the character cannot have the trait.', supportedScopes: ['character'], supportedTargets: ['trait'] },
  { name: 'make_trait_active_force_tooltip', description: 'Activates an inactive trait. Tooltip will be shown even if the character cannot have the trait.', supportedScopes: ['character'], supportedTargets: ['trait'] },
  { name: 'make_trait_inactive', description: 'Makes a current trait of a character inactive. Tooltip will not be shown if the character doesn\'t have the trait.', supportedScopes: ['character'], supportedTargets: ['trait'] },
  { name: 'make_trait_inactive_force_tooltip', description: 'Makes a current trait of a character inactive. Tooltip will be shown even if the character doesn\'t have the trait.', supportedScopes: ['character'], supportedTargets: ['trait'] },
  { name: 'make_unprunable', description: 'The scope character will no longer be prunable after their death. Use with care, as this will make everyone related to them unprunable too. So you should only use this if someone absolutely *needs* to stick around several years after their death. Example: make_unprunable = yes', supportedScopes: ['character'] },
  { name: 'marry', description: 'Marries the scoped character to the target character.', supportedScopes: ['character'], supportedTargets: ['character'], syntax: "marry = target" },
  { name: 'marry_matrilineal', description: 'Marries the scoped character to the target character matrilineally.', supportedScopes: ['character'], supportedTargets: ['character'], syntax: "marry_matrilineal = target" },
  { name: 'move_budget_gold', description: 'Move gold from one AI budget category to the other, will not move more than is available in the source budget or what can fit in the target budget.character, move_budget_gold = { gold = X from = Z to = Y }', supportedScopes: ['character'], syntax: "('budget_war_chest', 'budget_reserved', 'budget_short_term', 'budget_long_term')" },
  { name: 'move_to_pool', description: 'The scoped character (courtier or guest) leaves their current court and moves into the pool', supportedScopes: ['character'], syntax: "scope:guest = { move_to_pool = yes }" },
  { name: 'move_to_pool_at', description: 'The scoped character (courtier/guest/pool character) leaves their current court (if any) and moves into the pool of the specified province', supportedScopes: ['character'], supportedTargets: ['province'], syntax: "scope:guest = { move_to_pool_at = scope:some_province }" },
  { name: 'open_appoint_court_position_window', description: 'Opens the appointment window for the specified court position with scoped character as liege', supportedScopes: ['character'] },
  { name: 'ordered_acclaimed_knight', description: 'Iterate through all acclaimed knights employed by a given character', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_acclaimed_knight = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_accolade', description: 'Iterate through all ( active and inactive ) Accolades of a given liege character\'s Acclaimed Knights', supportedScopes: ['character'], supportedTargets: ['accolade'], outputScope: 'accolade', isIterator: true, syntax: "ordered_accolade = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_active_accolade', description: 'Iterate through all active Accolades of a given liege character\'s Acclaimed Knights', supportedScopes: ['character'], supportedTargets: ['accolade'], outputScope: 'accolade', isIterator: true, syntax: "ordered_active_accolade = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_alert_creatable_title', description: 'Iterate through all titles that can be created by the character. (only for alerts)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_alert_creatable_title = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_alert_usurpable_title', description: 'Iterate through all titles that can be usurped by the character. (only for alerts)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_alert_usurpable_title = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_ally', description: 'Iterate through all allies', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_ally = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_ancestor', description: 'Iterate through all the ancestors of the scope character up to 5 generations', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_ancestor = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_army', description: 'Iterate through all armies', supportedScopes: ['character'], supportedTargets: ['army'], outputScope: 'army', isIterator: true, syntax: "ordered_army = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_character_artifact', description: 'Iterate through all artifacts in a given characters inventory', supportedScopes: ['character'], supportedTargets: ['artifact'], outputScope: 'artifact', isIterator: true, syntax: "ordered_character_artifact = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_character_struggle', description: 'Iterate through all struggles that character is involved in. Optional: Narrow down the involvement status *_chracter_struggle = { involvement = involved | interloper }', supportedScopes: ['character'], supportedTargets: ['struggle'], outputScope: 'struggle', isIterator: true, syntax: "ordered_character_struggle = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_character_to_title_neighboring_and_across_water_county', description: 'Scopes from a character to a neighboring county (incl. across water, looking trough the de Jure lieges)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_character_to_title_neighboring_and_across_water_county = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_character_to_title_neighboring_and_across_water_duchy', description: 'Scopes from a character to a neighboring duchy (incl. across water, looking trough the de Jure lieges)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_character_to_title_neighboring_and_across_water_duchy = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_character_to_title_neighboring_and_across_water_empire', description: 'Scopes from a character to a neighboring empire (incl. across water, looking trough the de Jure lieges)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_character_to_title_neighboring_and_across_water_empire = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_character_to_title_neighboring_and_across_water_kingdom', description: 'Scopes from a character to a neighboring kingdom (incl. across water, looking trough the de Jure lieges)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_character_to_title_neighboring_and_across_water_kingdom = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_character_to_title_neighboring_county', description: 'Scopes from a character to a neighboring county (looking trough the de Jure lieges)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_character_to_title_neighboring_county = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_character_to_title_neighboring_duchy', description: 'Scopes from a character to a neighboring duchy (looking trough the de Jure lieges)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_character_to_title_neighboring_duchy = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_character_to_title_neighboring_empire', description: 'Scopes from a character to a neighboring empire (looking trough the de Jure lieges)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_character_to_title_neighboring_empire = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_character_to_title_neighboring_kingdom', description: 'Scopes from a character to a neighboring kingdom (looking trough the de Jure lieges)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_character_to_title_neighboring_kingdom = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_character_trait', description: 'Iterate through all traits a character has', supportedScopes: ['character'], supportedTargets: ['trait'], outputScope: 'trait', isIterator: true, syntax: "ordered_character_trait = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_character_war', description: 'Wars of the scoped character', supportedScopes: ['character'], supportedTargets: ['war'], outputScope: 'war', isIterator: true, syntax: "ordered_character_war = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_child', description: 'Iterate through all children', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_child = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_claim', description: 'Iterate through the titles of all claims held by a character; parameters: explicit = yes/no/all pressed = yes/no/all', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_claim = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_claimed_artifact', description: 'Iterate through all claimed artifacts of the scoped character', supportedScopes: ['character'], supportedTargets: ['artifact'], outputScope: 'artifact', isIterator: true, syntax: "ordered_claimed_artifact = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_close_family_member', description: 'Iterate through all the close family [father, mother, siblings, children, grandparents]', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_close_family_member = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_close_or_extended_family_member', description: 'Iterate through all the close and extended relatives [father, mother, siblings, children, grandparents, uncles/aunts, nephew/niece, cousins]', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_close_or_extended_family_member = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_concubine', description: 'Iterate through all concubines', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_concubine = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_consort', description: 'Iterate through all consorts (concubines and spouses)', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_consort = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_councillor', description: 'Iterate through all councillors', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_councillor = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_court_position_employer', description: 'Iterates through all characters that employ the scoped character in any court position.', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_court_position_employer = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_court_position_holder', description: 'Iterates through all characters employed by the scoped character in the target court position.', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_court_position_holder = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_courtier', description: 'Iterate through all courtiers', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_courtier = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_courtier_away', description: 'Iterate through all courtiers that are away', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_courtier_away = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_courtier_or_guest', description: 'Iterate through all courtiers and guests (pool and foreign court guests)', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_courtier_or_guest = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_de_jure_claim', description: 'Iterate through all de jure claims for a character', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_de_jure_claim = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_diarchy_succession_character', description: 'Iterate through all character in the diarchy line of succession.If there\'s no active diarchy or active one doesn\'t have succession,it iterates over regency candidates', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_diarchy_succession_character = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_diplomacy_councillor', description: 'Iterate through all diplomacy-based councillors', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_diplomacy_councillor = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_directly_owned_province', description: 'Iterate through all directly owned provinces', supportedScopes: ['character'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, syntax: "ordered_directly_owned_province = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_election_title', description: 'Iterate through all titles the scoped character can vote on', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_election_title = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_equipped_character_artifact', description: 'Iterate through all equipped artifacts in a given characters inventory', supportedScopes: ['character'], supportedTargets: ['artifact'], outputScope: 'artifact', isIterator: true, syntax: "ordered_equipped_character_artifact = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_extended_family_member', description: 'Iterate through all the extended family [uncles/aunts, nephew/niece, cousins]', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_extended_family_member = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_foreign_court_guest', description: 'Iterate through all guests visiting from another court (in contrast to pool_guest they have a liege)', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_foreign_court_guest = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_former_concubine', description: 'Iterate through all former concubines. Not persisted past death', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_former_concubine = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_former_concubinist', description: 'Iterate through all former concubinists. Not persisted past death', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_former_concubinist = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_former_spouse', description: 'Iterate through all former spouses', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_former_spouse = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_general_councillor', description: 'Iterate through all councillors that are not related to a skill', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_general_councillor = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_heir', description: 'Heirs of the scoped character', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_heir = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_heir_title', description: 'Iterate through all landed titles character is heir to', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_heir_title = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_heir_to_title', description: 'Iterate through all titles the scoped character is heir to', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_heir_to_title = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_held_title', description: 'Iterate through all held landed titles', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_held_title = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_hired_mercenary', description: 'Iterate through all hired mercenary companies', supportedScopes: ['character'], supportedTargets: ['mercenary_company'], outputScope: 'mercenary_company', isIterator: true, syntax: "ordered_hired_mercenary = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_home_court_hostage', description: 'Iterate through all hostages currently abroad', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_home_court_hostage = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_hooked_character', description: 'Iterate through all characters this character has a hook on', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_hooked_character = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_hostile_raider', description: 'Iterate through anyone the character is hostile to due to their top-liege\'s realm having been raided', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_hostile_raider = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_intrigue_councillor', description: 'Iterate through all intrigue-based councillors', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_intrigue_councillor = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_invited_activity', description: 'Iterate through all activities a character has been invited to', supportedScopes: ['character'], supportedTargets: ['activity'], outputScope: 'activity', isIterator: true, syntax: "ordered_invited_activity = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_knight', description: 'Iterate through all knights', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_knight = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_known_secret', description: 'Iterate through all secrets known by the character', supportedScopes: ['character'], supportedTargets: ['secret'], outputScope: 'secret', isIterator: true, syntax: "ordered_known_secret = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_learning_councillor', description: 'Iterate through all learning-based councillors', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_learning_councillor = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_liege_or_above', description: 'Iterate through all lieges above a character (skipping the character themselves)', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_liege_or_above = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_martial_councillor', description: 'Iterate through all martial-based councillors', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_martial_councillor = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_memory', description: 'Iterate through all memories of a character', supportedScopes: ['character'], supportedTargets: ['character_memory'], outputScope: 'character_memory', isIterator: true, syntax: "ordered_memory = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_neighboring_and_across_water_realm_same_rank_owner', description: 'A sub-realm or realm bordering the scope character\'s realm (including across water) and has the same rank as the scope character (look for lieges of he owner of the land if necessary)', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_neighboring_and_across_water_realm_same_rank_owner = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_neighboring_and_across_water_top_liege_realm', description: 'A realm with a different top liege neighboring the realm of the scope character\'s top liege (including across water); switches to the realm\'s top title. Can be based on borders a day or two out of date', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_neighboring_and_across_water_top_liege_realm = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_neighboring_and_across_water_top_liege_realm_owner', description: 'A realm with a different top liege neighboring the realm of the scope character\'s top liege (including across water); switches to the holder of the realm. Can be based on borders a day or two out of date', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_neighboring_and_across_water_top_liege_realm_owner = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_neighboring_realm_same_rank_owner', description: 'A sub-realm or realm bordering the scope character\'s realm and has the same rank as the scope character (look for lieges of he owner of the land if necessary)', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_neighboring_realm_same_rank_owner = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_neighboring_top_liege_realm', description: 'A realm with a different top liege neighboring the realm of the scope character\'s top liege; switches to the realm\'s top title. Can be based on borders a day or two out of date', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_neighboring_top_liege_realm = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_neighboring_top_liege_realm_owner', description: 'A realm with a different top liege neighboring the realm of the scope character\'s top liege; switches to the holder of the realm. Can be based on borders a day or two out of date', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_neighboring_top_liege_realm_owner = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_opposite_sex_spouse_candidate', description: 'Iterate through all the spouse candidates of the opposite sex of a character.', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "WARNING: THIS IS VERY SLOW DO NOT DO IT OFTEN.\nordered_opposite_sex_spouse_candidate = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_owned_story', description: 'Iterate through all owned stories for a character', supportedScopes: ['character'], supportedTargets: ['story'], outputScope: 'story', isIterator: true, syntax: "ordered_owned_story = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_parent', description: 'Iterate through all (both) parents', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_parent = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_patroned_holy_order', description: 'Iterate through all holy orders that the scoped character is a patron of', supportedScopes: ['character'], supportedTargets: ['holy_order'], outputScope: 'holy_order', isIterator: true, syntax: "ordered_patroned_holy_order = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_personal_claimed_artifact', description: 'Iterate through all personally claimed artifacts of the scoped character', supportedScopes: ['character'], supportedTargets: ['artifact'], outputScope: 'artifact', isIterator: true, syntax: "ordered_personal_claimed_artifact = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_pinned_character', description: 'Iterate through characters this player has pinned', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_pinned_character = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_pinning_character', description: 'Iterate through characters whose player has this character pinned', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_pinning_character = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_played_character', description: 'Iterate through all characters the player playing this character has played. Matches the game over legacy, except for excluding the currently played character', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_played_character = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_player_heir', description: 'Iterate through player heirs, capped at the first 10', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_player_heir = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_pool_guest', description: 'Iterate through all guests visiting the court from the pool (in contrast to foreign_court_guest they don\'t have a liege)', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_pool_guest = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_potential_marriage_option', description: 'Iterate through all potential selectable marriage or betrohed options', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_potential_marriage_option = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_powerful_vassal', description: 'Iterate through the all powerful vassals of a character', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_powerful_vassal = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_pretender_title', description: 'Iterate through all landed titles character is pretender to', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_pretender_title = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_primary_war_enemy', description: 'Iterate through all primary war enemies', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_primary_war_enemy = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_prisoner', description: 'Iterate through all prisoners', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_prisoner = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_prowess_councillor', description: 'Iterate through all prowess-based councillors', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_prowess_councillor = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_raid_target', description: 'Iterate through anyone the character is hostile to due to having raided them. Only returns top lieges', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_raid_target = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_realm_county', description: 'Iterate through all counties in the realm. Based on top liege', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_realm_county = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_realm_de_jure_duchy', description: 'Iterate through all de jure duchies that have at least one county in the realm. Based on top liege', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_realm_de_jure_duchy = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_realm_de_jure_empire', description: 'Iterate through all de jure empire that have at least one county in the realm. Based on top liege', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_realm_de_jure_empire = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_realm_de_jure_kingdom', description: 'Iterate through all de jure kingdom that have at least one county in the realm. Based on top liege', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_realm_de_jure_kingdom = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_realm_province', description: 'Iterate through all realm provinces of a character', supportedScopes: ['character'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, syntax: "ordered_realm_province = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_relation', description: 'Iterate through scripted relations of a given type or multiple types, if someone is multiple relations they will only be in the list once', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_relation = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_same_sex_spouse_candidate', description: 'Iterate through all the spouse candidates of the same sex of a character.', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "WARNING: THIS IS VERY SLOW DO NOT DO IT OFTEN.\nordered_same_sex_spouse_candidate = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_scheme', description: 'Iterate through all schemes owned by the character', supportedScopes: ['character'], supportedTargets: ['scheme'], outputScope: 'scheme', isIterator: true, syntax: "ordered_scheme = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_secret', description: 'Iterate through all secrets of the character', supportedScopes: ['character'], supportedTargets: ['secret'], outputScope: 'secret', isIterator: true, syntax: "ordered_secret = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_sibling', description: 'Iterate through all siblings', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_sibling = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_sponsored_inspiration', description: 'Iterate through all sponsored inspirations', supportedScopes: ['character'], supportedTargets: ['inspiration'], outputScope: 'inspiration', isIterator: true, syntax: "ordered_sponsored_inspiration = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_spouse', description: 'Iterate through all spouses', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_spouse = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_spouse_candidate', description: 'Iterate through all the spouse candidates of a character.', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "WARNING: THIS IS VERY SLOW DO NOT DO IT OFTEN.\nordered_spouse_candidate = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_stewardship_councillor', description: 'Iterate through all stewardship-based councillors', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_stewardship_councillor = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_sub_realm_barony', description: 'Iterate through all baronies in sub-realm', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_sub_realm_barony = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_sub_realm_county', description: 'Iterate through all counties in sub-realm', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_sub_realm_county = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_sub_realm_duchy', description: 'Iterate through all duchies in sub-realm', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_sub_realm_duchy = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_sub_realm_empire', description: 'Iterate through all empires in sub-realm', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_sub_realm_empire = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_sub_realm_kingdom', description: 'Iterate through all kingdoms in sub-realm', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_sub_realm_kingdom = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_sub_realm_title', description: 'Iterate through all titles in sub-realm', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_sub_realm_title = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_targeting_faction', description: 'Iterate through all factions targeting the scope character', supportedScopes: ['character'], supportedTargets: ['faction'], outputScope: 'faction', isIterator: true, syntax: "ordered_targeting_faction = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_targeting_scheme', description: 'Iterate through all schemes targeting the character', supportedScopes: ['character'], supportedTargets: ['scheme'], outputScope: 'scheme', isIterator: true, syntax: "ordered_targeting_scheme = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_targeting_secret', description: 'Iterate through all secrets that target the specified scope', supportedScopes: ['character'], supportedTargets: ['secret'], outputScope: 'secret', isIterator: true, syntax: "ordered_targeting_secret = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_traveling_family_member', description: 'Iterate though all characters that should travel with the scoped one (when moving between courts for instance); includes the scoped character', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_traveling_family_member = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_truce_holder', description: 'Iterate through all characters that have a truce on this character', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_truce_holder = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_truce_target', description: 'Iterate through all characters this character has a truce on', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_truce_target = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_unspent_known_secret', description: 'Iterate through all unspent secrets known by the character', supportedScopes: ['character'], supportedTargets: ['secret'], outputScope: 'secret', isIterator: true, syntax: "ordered_unspent_known_secret = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_vassal', description: 'Iterate through all DIRECT vassals', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_vassal = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_vassal_or_below', description: 'Iterate through ALL vassals, not just direct vassals', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_vassal_or_below = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_war_ally', description: 'Iterate through all direct war allies', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_war_ally = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_war_enemy', description: 'Iterate through all direct war enemies', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_war_enemy = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_warden_hostage', description: 'Iterate through all hostages having this warden', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_warden_hostage = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'pay_long_term_gold', description: 'the scope character pays gold to the target character, pay_long_term_gold = { target = X gold = Y } (from AI budget category \'long term\' first, then rest)', supportedScopes: ['character'] },
  { name: 'pay_long_term_income', description: 'the scope character immediately pays gold corresponding to their income to the target character, pay_long_term_income = { target = X days/months/years = Y } (AI budget \'long term\' first, then rest)', supportedScopes: ['character'] },
  { name: 'pay_reserved_gold', description: 'the scope character pays gold to the target character, pay_reserved_gold = { target = X gold = Y } (from AI budget category \'reserved\' first, then rest)', supportedScopes: ['character'] },
  { name: 'pay_reserved_income', description: 'the scope character immediately pays gold corresponding to their income to the target character, pay_reserved_income = { target = X days/months/years = Y } (AI budget \'reserved\' first, then rest)', supportedScopes: ['character'] },
  { name: 'pay_short_term_gold', description: 'the scope character pays gold to the target character, pay_short_term_gold = { target = X gold = Y } (from AI budget category \'short term\' first, then rest)', supportedScopes: ['character'] },
  { name: 'pay_short_term_income', description: 'the scope character immediately pays gold corresponding to their income to the target character, pay_short_term_income = { target = X days/months/years = Y } (AI budget \'short term\' first, then rest)', supportedScopes: ['character'] },
  { name: 'pay_war_chest_gold', description: 'the scope character pays gold to the target character, pay_war_chest_gold = { target = X gold = Y } (from AI budget category \'war chest\' first, then rest)', supportedScopes: ['character'] },
  { name: 'pay_war_chest_income', description: 'the scope character immediately pays gold corresponding to their income to the target character, pay_war_chest_income = { target = X days/months/years = Y } (AI budget \'war chest\' first, then rest)', supportedScopes: ['character'] },
  { name: 'play_music_cue', description: 'Plays the specified music cue.', supportedScopes: ['character'] },
  { name: 'play_sound_effect', description: 'Plays the specified sound effect.', supportedScopes: ['character'] },
  { name: 'random_acclaimed_knight', description: 'Iterate through all acclaimed knights employed by a given character', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_acclaimed_knight = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_accolade', description: 'Iterate through all ( active and inactive ) Accolades of a given liege character\'s Acclaimed Knights', supportedScopes: ['character'], supportedTargets: ['accolade'], outputScope: 'accolade', isIterator: true, syntax: "random_accolade = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_active_accolade', description: 'Iterate through all active Accolades of a given liege character\'s Acclaimed Knights', supportedScopes: ['character'], supportedTargets: ['accolade'], outputScope: 'accolade', isIterator: true, syntax: "random_active_accolade = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_alert_creatable_title', description: 'Iterate through all titles that can be created by the character. (only for alerts)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_alert_creatable_title = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_alert_usurpable_title', description: 'Iterate through all titles that can be usurped by the character. (only for alerts)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_alert_usurpable_title = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_ally', description: 'Iterate through all allies', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_ally = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_ancestor', description: 'Iterate through all the ancestors of the scope character up to 5 generations', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_ancestor = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_army', description: 'Iterate through all armies', supportedScopes: ['character'], supportedTargets: ['army'], outputScope: 'army', isIterator: true, syntax: "random_army = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_character_artifact', description: 'Iterate through all artifacts in a given characters inventory', supportedScopes: ['character'], supportedTargets: ['artifact'], outputScope: 'artifact', isIterator: true, syntax: "random_character_artifact = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_character_struggle', description: 'Iterate through all struggles that character is involved in. Optional: Narrow down the involvement status *_chracter_struggle = { involvement = involved | interloper }', supportedScopes: ['character'], supportedTargets: ['struggle'], outputScope: 'struggle', isIterator: true, syntax: "random_character_struggle = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_character_to_title_neighboring_and_across_water_county', description: 'Scopes from a character to a neighboring county (incl. across water, looking trough the de Jure lieges)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_character_to_title_neighboring_and_across_water_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_character_to_title_neighboring_and_across_water_duchy', description: 'Scopes from a character to a neighboring duchy (incl. across water, looking trough the de Jure lieges)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_character_to_title_neighboring_and_across_water_duchy = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_character_to_title_neighboring_and_across_water_empire', description: 'Scopes from a character to a neighboring empire (incl. across water, looking trough the de Jure lieges)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_character_to_title_neighboring_and_across_water_empire = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_character_to_title_neighboring_and_across_water_kingdom', description: 'Scopes from a character to a neighboring kingdom (incl. across water, looking trough the de Jure lieges)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_character_to_title_neighboring_and_across_water_kingdom = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_character_to_title_neighboring_county', description: 'Scopes from a character to a neighboring county (looking trough the de Jure lieges)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_character_to_title_neighboring_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_character_to_title_neighboring_duchy', description: 'Scopes from a character to a neighboring duchy (looking trough the de Jure lieges)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_character_to_title_neighboring_duchy = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_character_to_title_neighboring_empire', description: 'Scopes from a character to a neighboring empire (looking trough the de Jure lieges)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_character_to_title_neighboring_empire = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_character_to_title_neighboring_kingdom', description: 'Scopes from a character to a neighboring kingdom (looking trough the de Jure lieges)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_character_to_title_neighboring_kingdom = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_character_trait', description: 'Iterate through all traits a character has', supportedScopes: ['character'], supportedTargets: ['trait'], outputScope: 'trait', isIterator: true, syntax: "random_character_trait = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_character_war', description: 'Wars of the scoped character', supportedScopes: ['character'], supportedTargets: ['war'], outputScope: 'war', isIterator: true, syntax: "random_character_war = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_child', description: 'Iterate through all children', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_child = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_claim', description: 'Iterate through the titles of all claims held by a character; parameters: explicit = yes/no/all pressed = yes/no/all', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_claim = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_claimed_artifact', description: 'Iterate through all claimed artifacts of the scoped character', supportedScopes: ['character'], supportedTargets: ['artifact'], outputScope: 'artifact', isIterator: true, syntax: "random_claimed_artifact = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_close_family_member', description: 'Iterate through all the close family [father, mother, siblings, children, grandparents]', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_close_family_member = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_close_or_extended_family_member', description: 'Iterate through all the close and extended relatives [father, mother, siblings, children, grandparents, uncles/aunts, nephew/niece, cousins]', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_close_or_extended_family_member = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_concubine', description: 'Iterate through all concubines', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_concubine = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_consort', description: 'Iterate through all consorts (concubines and spouses)', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_consort = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_councillor', description: 'Iterate through all councillors', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_councillor = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_court_position_employer', description: 'Iterates through all characters that employ the scoped character in any court position.', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_court_position_employer = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_court_position_holder', description: 'Iterates through all characters employed by the scoped character in the target court position.', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_court_position_holder = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_courtier', description: 'Iterate through all courtiers', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_courtier = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_courtier_away', description: 'Iterate through all courtiers that are away', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_courtier_away = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_courtier_or_guest', description: 'Iterate through all courtiers and guests (pool and foreign court guests)', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_courtier_or_guest = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_de_jure_claim', description: 'Iterate through all de jure claims for a character', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_de_jure_claim = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_diarchy_succession_character', description: 'Iterate through all character in the diarchy line of succession.If there\'s no active diarchy or active one doesn\'t have succession,it iterates over regency candidates', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_diarchy_succession_character = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_diplomacy_councillor', description: 'Iterate through all diplomacy-based councillors', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_diplomacy_councillor = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_directly_owned_province', description: 'Iterate through all directly owned provinces', supportedScopes: ['character'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, syntax: "random_directly_owned_province = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_election_title', description: 'Iterate through all titles the scoped character can vote on', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_election_title = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_equipped_character_artifact', description: 'Iterate through all equipped artifacts in a given characters inventory', supportedScopes: ['character'], supportedTargets: ['artifact'], outputScope: 'artifact', isIterator: true, syntax: "random_equipped_character_artifact = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_extended_family_member', description: 'Iterate through all the extended family [uncles/aunts, nephew/niece, cousins]', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_extended_family_member = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_foreign_court_guest', description: 'Iterate through all guests visiting from another court (in contrast to pool_guest they have a liege)', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_foreign_court_guest = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_former_concubine', description: 'Iterate through all former concubines. Not persisted past death', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_former_concubine = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_former_concubinist', description: 'Iterate through all former concubinists. Not persisted past death', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_former_concubinist = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_former_spouse', description: 'Iterate through all former spouses', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_former_spouse = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_general_councillor', description: 'Iterate through all councillors that are not related to a skill', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_general_councillor = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_heir', description: 'Heirs of the scoped character', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_heir = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_heir_title', description: 'Iterate through all landed titles character is heir to', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_heir_title = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_heir_to_title', description: 'Iterate through all titles the scoped character is heir to', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_heir_to_title = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_held_title', description: 'Iterate through all held landed titles', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_held_title = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_hired_mercenary', description: 'Iterate through all hired mercenary companies', supportedScopes: ['character'], supportedTargets: ['mercenary_company'], outputScope: 'mercenary_company', isIterator: true, syntax: "random_hired_mercenary = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_home_court_hostage', description: 'Iterate through all hostages currently abroad', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_home_court_hostage = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_hooked_character', description: 'Iterate through all characters this character has a hook on', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_hooked_character = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_hostile_raider', description: 'Iterate through anyone the character is hostile to due to their top-liege\'s realm having been raided', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_hostile_raider = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_intrigue_councillor', description: 'Iterate through all intrigue-based councillors', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_intrigue_councillor = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_invited_activity', description: 'Iterate through all activities a character has been invited to', supportedScopes: ['character'], supportedTargets: ['activity'], outputScope: 'activity', isIterator: true, syntax: "random_invited_activity = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_knight', description: 'Iterate through all knights', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_knight = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_known_secret', description: 'Iterate through all secrets known by the character', supportedScopes: ['character'], supportedTargets: ['secret'], outputScope: 'secret', isIterator: true, syntax: "random_known_secret = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_learning_councillor', description: 'Iterate through all learning-based councillors', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_learning_councillor = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_liege_or_above', description: 'Iterate through all lieges above a character (skipping the character themselves)', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_liege_or_above = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_martial_councillor', description: 'Iterate through all martial-based councillors', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_martial_councillor = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_memory', description: 'Iterate through all memories of a character', supportedScopes: ['character'], supportedTargets: ['character_memory'], outputScope: 'character_memory', isIterator: true, syntax: "random_memory = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_neighboring_and_across_water_realm_same_rank_owner', description: 'A sub-realm or realm bordering the scope character\'s realm (including across water) and has the same rank as the scope character (look for lieges of he owner of the land if necessary)', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_neighboring_and_across_water_realm_same_rank_owner = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_neighboring_and_across_water_top_liege_realm', description: 'A realm with a different top liege neighboring the realm of the scope character\'s top liege (including across water); switches to the realm\'s top title. Can be based on borders a day or two out of date', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_neighboring_and_across_water_top_liege_realm = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_neighboring_and_across_water_top_liege_realm_owner', description: 'A realm with a different top liege neighboring the realm of the scope character\'s top liege (including across water); switches to the holder of the realm. Can be based on borders a day or two out of date', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_neighboring_and_across_water_top_liege_realm_owner = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_neighboring_realm_same_rank_owner', description: 'A sub-realm or realm bordering the scope character\'s realm and has the same rank as the scope character (look for lieges of he owner of the land if necessary)', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_neighboring_realm_same_rank_owner = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_neighboring_top_liege_realm', description: 'A realm with a different top liege neighboring the realm of the scope character\'s top liege; switches to the realm\'s top title. Can be based on borders a day or two out of date', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_neighboring_top_liege_realm = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_neighboring_top_liege_realm_owner', description: 'A realm with a different top liege neighboring the realm of the scope character\'s top liege; switches to the holder of the realm. Can be based on borders a day or two out of date', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_neighboring_top_liege_realm_owner = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_opposite_sex_spouse_candidate', description: 'Iterate through all the spouse candidates of the opposite sex of a character.', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "WARNING: THIS IS VERY SLOW DO NOT DO IT OFTEN.\nrandom_opposite_sex_spouse_candidate = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_owned_story', description: 'Iterate through all owned stories for a character', supportedScopes: ['character'], supportedTargets: ['story'], outputScope: 'story', isIterator: true, syntax: "random_owned_story = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_parent', description: 'Iterate through all (both) parents', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_parent = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_patroned_holy_order', description: 'Iterate through all holy orders that the scoped character is a patron of', supportedScopes: ['character'], supportedTargets: ['holy_order'], outputScope: 'holy_order', isIterator: true, syntax: "random_patroned_holy_order = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_personal_claimed_artifact', description: 'Iterate through all personally claimed artifacts of the scoped character', supportedScopes: ['character'], supportedTargets: ['artifact'], outputScope: 'artifact', isIterator: true, syntax: "random_personal_claimed_artifact = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_pinned_character', description: 'Iterate through characters this player has pinned', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_pinned_character = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_pinning_character', description: 'Iterate through characters whose player has this character pinned', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_pinning_character = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_played_character', description: 'Iterate through all characters the player playing this character has played. Matches the game over legacy, except for excluding the currently played character', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_played_character = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_player_heir', description: 'Iterate through player heirs, capped at the first 10', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_player_heir = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_pool_guest', description: 'Iterate through all guests visiting the court from the pool (in contrast to foreign_court_guest they don\'t have a liege)', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_pool_guest = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_potential_marriage_option', description: 'Iterate through all potential selectable marriage or betrohed options', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_potential_marriage_option = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_powerful_vassal', description: 'Iterate through the all powerful vassals of a character', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_powerful_vassal = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_pretender_title', description: 'Iterate through all landed titles character is pretender to', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_pretender_title = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_primary_war_enemy', description: 'Iterate through all primary war enemies', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_primary_war_enemy = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_prisoner', description: 'Iterate through all prisoners', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_prisoner = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_prowess_councillor', description: 'Iterate through all prowess-based councillors', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_prowess_councillor = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_raid_target', description: 'Iterate through anyone the character is hostile to due to having raided them. Only returns top lieges', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_raid_target = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_realm_county', description: 'Iterate through all counties in the realm. Based on top liege', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_realm_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_realm_de_jure_duchy', description: 'Iterate through all de jure duchies that have at least one county in the realm. Based on top liege', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_realm_de_jure_duchy = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_realm_de_jure_empire', description: 'Iterate through all de jure empire that have at least one county in the realm. Based on top liege', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_realm_de_jure_empire = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_realm_de_jure_kingdom', description: 'Iterate through all de jure kingdom that have at least one county in the realm. Based on top liege', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_realm_de_jure_kingdom = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_realm_province', description: 'Iterate through all realm provinces of a character', supportedScopes: ['character'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, syntax: "random_realm_province = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_relation', description: 'Iterate through scripted relations of a given type or multiple types, if someone is multiple relations they will only be in the list once', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_relation = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_same_sex_spouse_candidate', description: 'Iterate through all the spouse candidates of the same sex of a character.', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "WARNING: THIS IS VERY SLOW DO NOT DO IT OFTEN.\nrandom_same_sex_spouse_candidate = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_scheme', description: 'Iterate through all schemes owned by the character', supportedScopes: ['character'], supportedTargets: ['scheme'], outputScope: 'scheme', isIterator: true, syntax: "random_scheme = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_secret', description: 'Iterate through all secrets of the character', supportedScopes: ['character'], supportedTargets: ['secret'], outputScope: 'secret', isIterator: true, syntax: "random_secret = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_sibling', description: 'Iterate through all siblings', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_sibling = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_sponsored_inspiration', description: 'Iterate through all sponsored inspirations', supportedScopes: ['character'], supportedTargets: ['inspiration'], outputScope: 'inspiration', isIterator: true, syntax: "random_sponsored_inspiration = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_spouse', description: 'Iterate through all spouses', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_spouse = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_spouse_candidate', description: 'Iterate through all the spouse candidates of a character.', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "WARNING: THIS IS VERY SLOW DO NOT DO IT OFTEN.\nrandom_spouse_candidate = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_stewardship_councillor', description: 'Iterate through all stewardship-based councillors', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_stewardship_councillor = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_sub_realm_barony', description: 'Iterate through all baronies in sub-realm', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_sub_realm_barony = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_sub_realm_county', description: 'Iterate through all counties in sub-realm', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_sub_realm_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_sub_realm_duchy', description: 'Iterate through all duchies in sub-realm', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_sub_realm_duchy = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_sub_realm_empire', description: 'Iterate through all empires in sub-realm', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_sub_realm_empire = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_sub_realm_kingdom', description: 'Iterate through all kingdoms in sub-realm', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_sub_realm_kingdom = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_sub_realm_title', description: 'Iterate through all titles in sub-realm', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_sub_realm_title = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_targeting_faction', description: 'Iterate through all factions targeting the scope character', supportedScopes: ['character'], supportedTargets: ['faction'], outputScope: 'faction', isIterator: true, syntax: "random_targeting_faction = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_targeting_scheme', description: 'Iterate through all schemes targeting the character', supportedScopes: ['character'], supportedTargets: ['scheme'], outputScope: 'scheme', isIterator: true, syntax: "random_targeting_scheme = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_targeting_secret', description: 'Iterate through all secrets that target the specified scope', supportedScopes: ['character'], supportedTargets: ['secret'], outputScope: 'secret', isIterator: true, syntax: "random_targeting_secret = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_traveling_family_member', description: 'Iterate though all characters that should travel with the scoped one (when moving between courts for instance); includes the scoped character', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_traveling_family_member = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_truce_holder', description: 'Iterate through all characters that have a truce on this character', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_truce_holder = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_truce_target', description: 'Iterate through all characters this character has a truce on', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_truce_target = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_unspent_known_secret', description: 'Iterate through all unspent secrets known by the character', supportedScopes: ['character'], supportedTargets: ['secret'], outputScope: 'secret', isIterator: true, syntax: "random_unspent_known_secret = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_vassal', description: 'Iterate through all DIRECT vassals', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_vassal = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_vassal_or_below', description: 'Iterate through ALL vassals, not just direct vassals', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_vassal_or_below = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_war_ally', description: 'Iterate through all direct war allies', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_war_ally = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_war_enemy', description: 'Iterate through all direct war enemies', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_war_enemy = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_warden_hostage', description: 'Iterate through all hostages having this warden', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_warden_hostage = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'refund_all_perks', description: 'Refunds all perks of the character. Example: refund_all_perks = yes', supportedScopes: ['character'] },
  { name: 'refund_perks', description: 'Refunds all perks of the RHS lifestyle. Example: refund_perks = intrigue_lifestyle', supportedScopes: ['character'] },
  { name: 'release_from_prison', description: 'releases the character from the prison, imprison = X, where X is a boolean value', supportedScopes: ['character'] },
  { name: 'remove_all_character_modifier_instances', description: 'Remove all instances of a modifier from a character', supportedScopes: ['character'], syntax: "remove_all_character_modifier_instances = name" },
  { name: 'remove_character_flag', description: 'removes a character flag', supportedScopes: ['character'] },
  { name: 'remove_character_modifier', description: 'Remove a modifier from a character', supportedScopes: ['character'], syntax: "remove_character_modifier = name" },
  { name: 'remove_claim', description: 'removes an explicit (not from a living parent/grand parent) claim', supportedScopes: ['character'], supportedTargets: ['landed_title'] },
  { name: 'remove_concubine', description: 'Removes the target character as a concubine of the scope character', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_courtier_or_guest', description: 'Removes the target character (guest or courtier) from the scope character\'s court', supportedScopes: ['character'], supportedTargets: ['character'], syntax: "scope:host = { remove_courtier_or_guest = scope:guest } # move to pool, staying in same province\nscope:host = {\nremove_courtier_or_guest = {\ncharacter = scope:guest\nnew_location = scope:some_province # optionally specify a new location\n}\n}" },
  { name: 'remove_decision_cooldown', description: 'Remove the cooldown on taking a decision for the scoped character', supportedScopes: ['character'], supportedTargets: ['decision'], syntax: "remove_decision_cooldown = decision_name" },
  { name: 'remove_from_activity', description: 'remove_from_activity = activity', supportedScopes: ['character'], supportedTargets: ['activity'], syntax: "The scoped character is removed from the target activity" },
  { name: 'remove_hook', description: 'Removes a hook on a character, remove_hook = { target = X, type = Y }, if type is specified, the hook will only be removed if it is of that type', supportedScopes: ['character'] },
  { name: 'remove_interaction_cooldown', description: 'Remove the cooldown on using an interaction for the scoped character', supportedScopes: ['character'], syntax: "remove_interaction_cooldown = interaction_name" },
  { name: 'remove_interaction_cooldown_against', description: 'Remove the cooldown on using an interaction against the target character for the scoped character', supportedScopes: ['character'], syntax: "remove_interaction_cooldown_against = { interaction = interaction_name target = character }" },
  { name: 'remove_localized_text', description: 'Removes a piece of localized text from being stored on the character with a given key, you should do this whenever you are done with the custom text so as to not bloat saves', supportedScopes: ['character'], syntax: "remove_localized_text = key" },
  { name: 'remove_long_term_gold', description: 'removes gold from a character (from AI\'s \'long term\' budget first, then rest)', supportedScopes: ['character'] },
  { name: 'remove_nickname', description: 'Removes any nickname from the current character [yes|no]', supportedScopes: ['character'] },
  { name: 'remove_opinion', description: 'Removes a temporary opinion modifier, remove_opinion = { target = X modifier = Y single = Z (no by default) } where X is a character, Y is the opinion modifier, Z tells whether to remove all instances of the modifier or just one', supportedScopes: ['character'] },
  { name: 'remove_perk', description: 'Remove the perk for this character', supportedScopes: ['character'] },
  { name: 'remove_personal_artifact_claim', description: 'Removes a personal claim on the target artifact from the scoped character', supportedScopes: ['character'], supportedTargets: ['artifact'] },
  { name: 'remove_realm_law', description: 'Removes the given law from the scoped character. This will leave the law group empty, so only do this if you\'re getting rid of a law group', supportedScopes: ['character'] },
  { name: 'remove_relation_activity_recurrer', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_relation_antiquarian', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_relation_best_friend', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_relation_bully', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_relation_court_physician', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_relation_crush', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_relation_flag', description: 'Removed a flag from an existing relation flag = flag_name (declared in scripted_relation) target = other_character relation = scripted_relation', supportedScopes: ['character'] },
  { name: 'remove_relation_friend', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_relation_guardian', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_relation_intrigue_mentor', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_relation_intrigue_student', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_relation_lover', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_relation_mentor', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_relation_nemesis', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_relation_nursed_child', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_relation_oaf', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_relation_potential_friend', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_relation_potential_hook', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_relation_potential_lover', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_relation_potential_rival', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_relation_rival', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_relation_soldier_friend', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_relation_soulmate', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_relation_student', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_relation_victim', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_relation_ward', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_relation_wedding_bad_fertility', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_relation_wedding_good_fertility', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_relation_wedding_very_bad_fertility', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_relation_wedding_very_good_fertility', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_relation_wet_nurse', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_reserved_gold', description: 'removes gold from a character (from AI\'s \'reserved\' budget first, then rest)', supportedScopes: ['character'] },
  { name: 'remove_scheme_cooldown_against', description: 'Remove the cooldown on using a scheme against the target character for the scoped character', supportedScopes: ['character'], syntax: "remove_scheme_cooldown_against = { scheme = scheme_name target = character }" },
  { name: 'remove_short_term_gold', description: 'removes gold from a character (from AI\'s \'short term\' budget first, then rest)', supportedScopes: ['character'] },
  { name: 'remove_trait', description: 'Removes a trait from a character. Tooltip will not be shown if the character doesn\'t have the trait.', supportedScopes: ['character'], supportedTargets: ['trait'] },
  { name: 'remove_trait_force_tooltip', description: 'Removes a trait from a character. Tooltip will be shown even if the character doesn\'t have the trait.', supportedScopes: ['character'], supportedTargets: ['trait'] },
  { name: 'remove_war_chest_gold', description: 'removes gold from a character (from AI\'s \'war chest\' budget first, then rest)', supportedScopes: ['character'] },
  { name: 'replace_court_position', description: 'Replaces the target character holding target court position within scoped character\'s court with target character', supportedScopes: ['character'], syntax: "recipient = character scope - target character to receive the title\nholder = character scope - target character to revoke the target court position of in favour of recipient\ncourt_position = court position type - court position type to assign the receiver" },
  { name: 'reset_beneficiary', description: 'The target character stops having a beneficiary. reset_beneficiary = yes', supportedScopes: ['character'] },
  { name: 'return_hostage', description: 'Release scoped character from hostage and return to home court', supportedScopes: ['character'] },
  { name: 'return_to_court', description: 'Returns the scope character to the employers court.', supportedScopes: ['character'] },
  { name: 'reverse_add_opinion', description: 'Adds a temporary reverse opinion modifier, reverse_add_opinion = { modifier = X days/months/years = Y target = Z }', supportedScopes: ['character'], syntax: "X is a scripted modifier name. Y can be a value or a range \"{ A B }\" If no timeout are specified, the modifier's scripted default timeout will be used." },
  { name: 'revoke_court_position', description: 'Revokes target position from scoped character.', supportedScopes: ['character'], syntax: "court_position = court position type - court position type to revoke from scoped character's court" },
  { name: 'scriptedtests_recalculate_character_modifier', description: 'Recalculates the modifier of the scoped character', supportedScopes: ['character'] },
  { name: 'scriptedtests_recalculate_succession', description: 'Recalculates the line of succession of the scoped character', supportedScopes: ['character'] },
  { name: 'send_interface_message', description: 'Sends a message to the player playing the character in the scope and then executes any effects inside.', supportedScopes: ['character'], syntax: "For the message text and tooltip, $EFFECT$ contains the text description of the effects in the past tense.\nAnd $DESC$ contains the text from the desc field.\nsend_interface_message = {\ntype = message_type # default: send_interface_message\ntitle = LOCALIZATION # optional, otherwise takes it from the message type\ndesc = LOCALIZATION # optional, otherwise takes it from the message type\ntooltip = LOCALIZATION # optional, otherwise takes it from the message type\nleft_icon = scope:recipient # optional, character, artifact, or title\nright_icon = scope:the_title # optional, character, artifact, or title\n# optional effects...\nadd_dread = 5\nscope:someone = { add_gold = 5 }\n}" },
  { name: 'send_interface_toast', description: 'Sends a message to the player playing the character in the scope and then executes any effects inside.', supportedScopes: ['character'], syntax: "For the message text and tooltip, $EFFECT$ contains the text description of the effects in the past tense.\nAnd $DESC$ contains the text from the desc field.\nsend_interface_toast = {\ntype = message_type # default: send_interface_toast\ntitle = LOCALIZATION # optional, otherwise takes it from the message type\ndesc = LOCALIZATION # optional, otherwise takes it from the message type\ntooltip = LOCALIZATION # optional, otherwise takes it from the message type\nleft_icon = scope:recipient # optional, character, artifact, or title\nright_icon = scope:the_title # optional, character, artifact, or title\n# optional effects...\nadd_dread = 5\nscope:someone = { add_gold = 5 }\n}" },
  { name: 'set_absolute_country_control', description: 'Sets if this character has absolute country control, unlock_character_movement = yes/no/boolean event target', supportedScopes: ['character'] },
  { name: 'set_age', description: 'Sets the character\'s age. Note that this will completely bypass birthday on-actions, age-related health, and so on, just like the console command', supportedScopes: ['character'], syntax: "Usage: set_age = script value" },
  { name: 'set_amenity_level', description: 'set_amenity_level = { type = food value = 2 }', supportedScopes: ['character'], syntax: "Sets the amenity type to the given value for the scoped character" },
  { name: 'set_beneficiary', description: 'The target character becomes the beneficiary of the scoped character. set_beneficiary = some character', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'set_character_faith', description: 'Changes what faith a character has executing the effects for it. For history setup use \'set_character_faith_history\' instead.', supportedScopes: ['character'], supportedTargets: ['faith'] },
  { name: 'set_character_faith_history', description: 'Changes what faith a character has NOT executing the effects for it. USE ONLY IN HISOTRY SETUP!', supportedScopes: ['character'], supportedTargets: ['faith'] },
  { name: 'set_character_faith_with_conversion', description: 'Changes what faith a character has, as if they used the faith-view interaction (minus the piety cost). So vassals who\'d accept will get converted, as will capitals', supportedScopes: ['character'], supportedTargets: ['faith'] },
  { name: 'set_child_of_concubine_on_pregnancy', description: 'Sets the child to be (or not be) a child of a concubine during pregnancy', supportedScopes: ['character'] },
  { name: 'set_council_task', description: 'Sets the task of the scope councillor { task_type = council_position_type_key target = for_targeted_tasks  }', supportedScopes: ['character'] },
  { name: 'set_court_language', description: 'Set the character\'s court language to the given languageset_court_language = language_norwegian', supportedScopes: ['character'] },
  { name: 'set_court_type', description: 'Set the court type for this character\'s royal court', supportedScopes: ['character'] },
  { name: 'set_culture', description: 'Set the culture for this character', supportedScopes: ['character'], supportedTargets: ['culture'] },
  { name: 'set_culture_same_as', description: 'sets the culture of the character to be the same as the culture of the target', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'set_current_court_grandeur', description: 'Sets the current court grandeur of a character with a royal court, clamped between NRoyalCourt::COURT_GRANDEUR_MIN and NRoyalCourt::COURT_GRANDEUR_MAX.', supportedScopes: ['character'], syntax: "Does not apply a grace period, and removes any existing one." },
  { name: 'set_death_reason', description: 'set_death_reason = { killer = X death_reason = Y artifact = Z }', supportedScopes: ['character'], syntax: "All parameters are optional. Sets the death reason, the killer, and artifact used in the death of a dead character" },
  { name: 'set_default_education', description: 'Set the default education focus for this character', supportedScopes: ['character'] },
  { name: 'set_designated_heir', description: 'Sets the given character as designated heir', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'set_diarch', description: 'Set target character as new diarch. Requires an active diarchy', supportedScopes: ['character'], supportedTargets: ['character'], syntax: "set_diarch = scope:new_diarch" },
  { name: 'set_diarchy_mandate', description: 'Set mandate for the diarch. Takes mandate type as argument', supportedScopes: ['character'], syntax: "scope:diarch = { set_diarchy_mandate = live_long_and_prosper }" },
  { name: 'set_diarchy_swing', description: 'Set scales of power swing for the active diarchy', supportedScopes: ['character'], syntax: "set_diarchy_swing = 55" },
  { name: 'set_diarchy_type', description: 'Set diarthy type for the character. Takes diarchy type as argument', supportedScopes: ['character'], syntax: "set_diarchy_type = regency" },
  { name: 'set_employer', description: 'Add the scope character to the target character\'s court', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'set_father', description: 'sets the father of a character', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'set_focus', description: 'Set the focus for this character', supportedScopes: ['character'] },
  { name: 'set_house', description: 'Sets the dynasty house of the character', supportedScopes: ['character'], supportedTargets: ['dynasty_house'] },
  { name: 'set_immortal_age', description: 'Changes what age the character became immortal at. Only works if already immortal', supportedScopes: ['character'], syntax: "set_immortal_age = 20" },
  { name: 'set_killer_public', description: 'Sets the scoped character\'s killer as being publicly known', supportedScopes: ['character'], syntax: "set_killer_public = bool" },
  { name: 'set_knight_status', description: 'Sets the knight status of the character to Forced/Default/Disallowed', supportedScopes: ['character'] },
  { name: 'set_known_bastard_on_pregnancy', description: 'Sets the child to a known or unknown bastard during pregnancy', supportedScopes: ['character'] },
  { name: 'set_location', description: 'Moves the character to a specific location.', supportedScopes: ['character'], syntax: "stick_to_location can be used to prevent the safety checks that sometimes return characters to their default location automatically.Usage:   set_location = province\nset_location = { location = province   stick_to_location = yes/no }" },
  { name: 'set_location_to_default', description: 'Moves the character to its "default" location.This is usually the realm capital for landed characters, or court location for courtiers.', supportedScopes: ['character'], syntax: "Usage: set_location_to_default = yes/no" },
  { name: 'set_mother', description: 'Sets the mother of a character', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'set_num_pregnancy_children', description: 'Set the number of children', supportedScopes: ['character'] },
  { name: 'set_override_designated_winner', description: 'The scoped character will put their beneficiary on the throne if they\'re the #1 participant if this is called with \'yes\'. Call with \'no\' to turn it off again. set_override_designate_winner = yes/no', supportedScopes: ['character'] },
  { name: 'set_player_character', description: 'The scope character\'s player will now play as the target character. Scope must be player-controlled. Target cannot be player-controlled. Example:set_player_character = scope:title_recipient', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'set_pregnancy_assumed_father', description: 'Set the assumed father of the pregnancy', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'set_primary_spouse', description: 'Set the primary spouse of a character', supportedScopes: ['character'], supportedTargets: ['character'], syntax: "set_primary_spouse = scope" },
  { name: 'set_primary_title_to', description: 'Sets the primary title for a character', supportedScopes: ['character'], supportedTargets: ['landed_title'], syntax: "set_primary_title_to = <title>" },
  { name: 'set_real_father', description: 'Changes the real father of the scoped character', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'set_real_mother', description: 'Changes the real mother of the scoped character', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'set_realm_capital', description: 'Set a new realm capital', supportedScopes: ['character'], supportedTargets: ['landed_title'], syntax: "character = { set_realm_capital = new_title }" },
  { name: 'set_relation_activity_recurrer', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_relation_antiquarian', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_relation_best_friend', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_relation_bully', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_relation_court_physician', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_relation_crush', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_relation_friend', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_relation_guardian', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_relation_intrigue_mentor', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_relation_intrigue_student', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_relation_lover', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_relation_mentor', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_relation_nemesis', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_relation_nursed_child', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_relation_oaf', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_relation_potential_friend', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_relation_potential_hook', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_relation_potential_lover', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_relation_potential_rival', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_relation_rival', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_relation_soldier_friend', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_relation_soulmate', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_relation_student', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_relation_victim', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_relation_ward', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_relation_wedding_bad_fertility', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_relation_wedding_good_fertility', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_relation_wedding_very_bad_fertility', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_relation_wedding_very_good_fertility', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_relation_wet_nurse', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_reserved_gold_maximum', description: 'Set the maximum (and also desired value) for the \'reserved\' gold AI budget. This budget is saved up, even before the war chest budget. It will not correct the current gold in that budget to conform to the new maximum.character, set_reserved_gold_maximum = X', supportedScopes: ['character'] },
  { name: 'set_sexuality', description: 'Sets the sexuality of the character', supportedScopes: ['character'] },
  { name: 'set_to_lowborn', description: 'Set the character to lowborn', supportedScopes: ['character'] },
  { name: 'set_trait_rank', description: 'Sets the trait rank = { trait = trait_group rank = new rank }', supportedScopes: ['character'] },
  { name: 'set_vassal_contract_modification_blocked', description: 'Blocks the vassal contract from being modified with regards to being checked by \'vassal_contract_is_blocked_from_modification\'', supportedScopes: ['character'] },
  { name: 'spawn_army', description: 'Spawns an army for this character. If the character is not at war, the regiments will be created, but the army will not be spawned.', supportedScopes: ['character'], syntax: "Usage:\nspawn_army = {\nlevies = int/script value # optional, number of men\nmen_at_arms = { # optional, multiple can be specified. Need either levies or MAA\ntype = key\nmen/stacks = int/script value\n}\nlocation = province\norigin = province # optional, location used if not set. This is used for where to base bonuses and the like on\nwar = war # optional. If set, the stack will disband after the war ends\nwar_keep_on_attacker_victory = yes/no # Default: no. Tied to a war. Normally the stack will disband upon victory (if a war is specified), but this parameter prevents that from happening upon attacker victory\ninheritable = yes/no # Default: yes\nuses_supply = yes/no # Default: yes\narmy = army # optional. If set, the stack will merge into this army\nsave_scope_as/save_temporary_scope_as = new_army # optional way to get a reference to the new army. Note this might not be set if the army wasn't spawned (e.g. if the character is not at war)\nname = description # gives the troops a specific name that shows up in interfaces\n}" },
  { name: 'sponsor_inspiration', description: 'sponsor_inspiration = inspiration', supportedScopes: ['character'], supportedTargets: ['inspiration'], syntax: "Sets the sponsor of the target inspiration to the scoped character" },
  { name: 'start_default_task', description: 'Force the Councillor to revert to the default task. Any relevant percentage progress will be lost (even if the councillor was performing the default task already).', supportedScopes: ['character'] },
  { name: 'start_diarchy', description: 'Start diarchy for the character. Takes diarchy type as argument', supportedScopes: ['character'], syntax: "start_diarchy = regency" },
  { name: 'start_scheme', description: 'starts a scheme  = { type = X target = Y }', supportedScopes: ['character'] },
  { name: 'start_travel_plan', description: 'Start a travel plan. Saving this as a scope will not work for player characters if they have to use the planner.', supportedScopes: ['character'], syntax: "start_travel_plan = {\ndestination = PROVINCE (repeatable)\ntravel_leader = CHARACTER (optional)\ncompanion = CHARACTER (optional & repeatable)\nplayers_use_planner = YES/NO (default yes)\nreturn_trip = YES/NO (default yes, adds a destination at the end of the travel plan to return to the starting location)\non_arrival_event = EVENT (triggered on non-home destinations determined by on_arrival_destinations. Root is travel plan owner.)\non_arrival_on_action = ON_ACTION (triggered on non-home destinations determined by on_arrival_destinations. Root is travel plan owner.)\non_start_event = EVENT (triggered when the travel starts. Root is travel plan owner.)\non_start_on_action = ON_ACTION (triggered when the travel starts. Root is travel plan owner.)\non_travel_planner_cancel_event = EVENT (triggered if a player exits the travel planner instead of starting a travel. Root is travel plan owner.)\non_travel_planner_cancel_on_action = ON_ACTION (triggered if a player exits the travel planner instead of starting a travel. Root is travel plan owner.)\non_arrival_destinations = all/first/last/all_but_last (which destinations the on_arrival should trigger on, defaults to all_but_last)\n}" },
  { name: 'start_war', description: 'starts a war  = { casus_belli/cb = X target = Y claimant = Z target_title = W1 target_title = W2 ... } where X is a casus belli type, Y is the target character, Z i the (optional) claimant, W1, W2.... are targeted titles.', supportedScopes: ['character'], syntax: "If there are no title targets, the effect will pick one of possible title targets." },
  { name: 'store_localized_text_in_death', description: 'Makes a piece of localized text with the given key be stored on the character even after death, you should use this sparingly to avoid save bloat and use \'remove_localized_text\' if you no longer need itsaves', supportedScopes: ['character'], syntax: "store_localized_text_in_death = key" },
  { name: 'stress_impact', description: 'Stress impact according to specified traits (trait = value), use base = value for a base value that\'s always added', supportedScopes: ['character'] },
  { name: 'take_hostage', description: 'Take target character as a hostagescope:warden = { take_hostage = scope:hostage }', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'unlearn_court_language_of', description: 'The character unlearns the court language of the target character. Cannot unlearn the language of your cultureunlearn_court_language_of = scope:target_character', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'unlearn_language', description: 'The character unlearns the language. Cannot unlearn the language of your cultureunlearn_language = language_norwegian', supportedScopes: ['character'] },
  { name: 'unlearn_language_of_culture', description: 'The character unlearns the language of the target culture. Cannot unlearn the language of your cultureunlearn_language_of_culture = scope:target_culture', supportedScopes: ['character'], supportedTargets: ['culture'] },
  { name: 'use_hook', description: 'Uses a hook a character has (removes if weak, puts on cooldown if strong), use_hook = some_character', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'vassal_contract_decrease_obligation_level', description: 'decrease the obligation level of the scoped character\'s vassal contract', supportedScopes: ['character'] },
  { name: 'vassal_contract_increase_obligation_level', description: 'increase the obligation level of the scoped character\'s vassal contract', supportedScopes: ['character'] },
  { name: 'vassal_contract_set_obligation_level', description: 'change the obligation level of the scoped character\'s vassal contract', supportedScopes: ['character'], syntax: "vassal_contract_set_obligation_level = { type = name level = 1 } # index to obligation level\nvassal_contract_set_obligation_level = { type = name level = feudal_obligation_low }\nvassal_contract_set_obligation_level = { type = name level = scope:obligation }" },
  { name: 'visit_court_of', description: 'Add the scope character as the target character\'s guest', supportedScopes: ['character'], supportedTargets: ['character'] },
];

/**
 * Effects for landed_title scope (126 effects)
 */
export const landedtitleEffects: EffectDefinition[] = [
  { name: 'generate_coa', description: 'Generates a coat of arms for the scoped landed title, dynasty or house', supportedScopes: ['landed_title', 'dynasty', 'dynasty_house'], syntax: "generate_coa = yes" },
  { name: 'reset_coa', description: 'Rest the coat of arms for the scoped landed title, dynasty or house to its template', supportedScopes: ['landed_title', 'dynasty', 'dynasty_house'], syntax: "reset_coa = yes" },
  { name: 'set_coa', description: 'Sets the coat of arms of a landed title, dynasty, or house to the right hand side coat of arms or that of an object of the same type', supportedScopes: ['landed_title', 'dynasty', 'dynasty_house'], syntax: "set_coa = k_england\nset_coa = scope:new_coa" },
  { name: 'add_county_modifier', description: 'Add a modifier to a county', supportedScopes: ['landed_title'], syntax: "add_county_modifier = name\nadd_county_modifier = { modifier = name days/weeks/months/years = int }\nYou can also add an optional 'desc' field. This is a dynamic description that'll be used for your timed modifier" },
  { name: 'change_county_control', description: 'Changes the county control of a title. If the title has higher tier than county, the effect will propagate down to all counties below it.', supportedScopes: ['landed_title'] },
  { name: 'change_de_jure_drift_progress', description: 'Change the progress of de jure drift of a title<drifting_title> = { change_de_jure_drift_progress = {    target = <drift_target_title>    values = <progress_change_value> } }', supportedScopes: ['landed_title'] },
  { name: 'change_development_level', description: 'Changes the development level of a title. If the title has higher tier than county, the effect will propagate down to all counties below it.', supportedScopes: ['landed_title'] },
  { name: 'change_development_progress', description: 'Changes the development progress of a title. If the title has higher tier than county, the effect will propagate down to all counties below it.', supportedScopes: ['landed_title'] },
  { name: 'change_development_progress_with_overflow', description: 'Changes the development progress of a title. If the title has higher tier than county, the effect will propagate down to all counties below it. Will overflow, so adding +100 to a county with 50 progress left will increase the level by 1 and result in 50 progress towards the next level', supportedScopes: ['landed_title'] },
  { name: 'clear_title_laws', description: 'remove all title laws from the scoped title. DOES NOT apply law removal costs and effects.', supportedScopes: ['landed_title'], syntax: "clear_title_laws = yes" },
  { name: 'clear_title_laws_effects', description: 'remove all title laws from the scoped title. DOES apply law removal costs and effects.', supportedScopes: ['landed_title'], syntax: "clear_title_laws_effects = yes" },
  { name: 'copy_title_history', description: 'Copy title history from another title', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], syntax: "copy_title_history = source_title" },
  { name: 'every_claimant', description: 'Iterate through all claimants to title. parameters: explicit = yes/no/all - default yes', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_claimant = { limit = { <triggers> } <effects> }" },
  { name: 'every_connected_county', description: 'Iterate through all counties connected to this one. Is based on top liege', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "any/every/whatever_connectec_county = {\nmax_naval_distance = 500\nallow_one_county_land_gap = yes\nevery_connected_county = { limit = { <triggers> } <effects> }" },
  { name: 'every_controlled_faith', description: 'Iterate through all faiths headed by a title', supportedScopes: ['landed_title'], supportedTargets: ['faith'], outputScope: 'faith', isIterator: true, syntax: "every_controlled_faith = { limit = { <triggers> } <effects> }" },
  { name: 'every_county_province', description: 'Iterate through all provinces in a county', supportedScopes: ['landed_title'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, syntax: "every_county_province = { limit = { <triggers> } <effects> }" },
  { name: 'every_county_struggle', description: 'Iterate through all struggles that a county is involved in.', supportedScopes: ['landed_title'], supportedTargets: ['struggle'], outputScope: 'struggle', isIterator: true, syntax: "every_county_struggle = { limit = { <triggers> } <effects> }" },
  { name: 'every_de_jure_county', description: 'Iterate through all counties within this dejure title', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_de_jure_county = { limit = { <triggers> } <effects> }" },
  { name: 'every_de_jure_county_holder', description: 'Iterate through all characters directly holding counties within this dejure title', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_de_jure_county_holder = { limit = { <triggers> } <effects> }" },
  { name: 'every_de_jure_top_liege', description: 'Iterate through all top lieges of the counts within this dejure title', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_de_jure_top_liege = { limit = { <triggers> } <effects> }" },
  { name: 'every_dejure_vassal_title_holder', description: 'Iterate through all the vassal holders of the title', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_dejure_vassal_title_holder = { limit = { <triggers> } <effects> }" },
  { name: 'every_direct_de_facto_vassal_title', description: 'Iterate through all de facto vassal titles', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_direct_de_facto_vassal_title = { limit = { <triggers> } <effects> }" },
  { name: 'every_direct_de_jure_vassal_title', description: 'Iterate through the all de jure vassals titles', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_direct_de_jure_vassal_title = { limit = { <triggers> } <effects> }" },
  { name: 'every_election_candidate', description: 'Iterate through all characters who are valid candidates in an election for a title', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_election_candidate = { limit = { <triggers> } <effects> }" },
  { name: 'every_elector', description: 'Iterate through all characters who are valid electors in an election for a title', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_elector = { limit = { <triggers> } <effects> }" },
  { name: 'every_in_de_facto_hierarchy', description: 'Iterate through the title itself, all de facto vassals, and below. The continue trigger specifies whether to recursively iterate through the vassal\'s vassal', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "This is unrelated to the limit; if the limit is met it is added to the list, but its vassals will get checked even if the limit isn't met as long as the 'continue' trigger is\n..._de_jure_vassal_and_below = { continue = { conditions } }\nevery_in_de_facto_hierarchy = { limit = { <triggers> } <effects> }" },
  { name: 'every_in_de_jure_hierarchy', description: 'Iterate through the title itself, all de jure vassals, and below. The continue trigger specifies whether to recursively iterate through the vassal\'s vassal', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "This is unrelated to the limit; if the limit is met it is added to the list, but its vassals will get checked even if the limit isn't met as long as the 'continue' trigger is\n..._de_jure_vassal_and_below = { continue = { conditions } }\nevery_in_de_jure_hierarchy = { limit = { <triggers> } <effects> }" },
  { name: 'every_neighboring_county', description: 'Iterate through all neighboring counties. Can only be used in county scope', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_neighboring_county = { limit = { <triggers> } <effects> }" },
  { name: 'every_past_holder', description: 'Iterate through all past owners of a title from earliest to latest', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_past_holder = { limit = { <triggers> } <effects> }" },
  { name: 'every_past_holder_reversed', description: 'Iterate through all past owners of a title from latest to earliest', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_past_holder_reversed = { limit = { <triggers> } <effects> }" },
  { name: 'every_this_title_or_de_jure_above', description: 'Iterate through this title and all its dejure liege titles', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_this_title_or_de_jure_above = { limit = { <triggers> } <effects> }" },
  { name: 'every_title_heir', description: 'Line of succession for the scoped title', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_title_heir = { limit = { <triggers> } <effects> }" },
  { name: 'every_title_joined_faction', description: 'Iterate through all factions joined the scope landed title', supportedScopes: ['landed_title'], supportedTargets: ['faction'], outputScope: 'faction', isIterator: true, syntax: "every_title_joined_faction = { limit = { <triggers> } <effects> }" },
  { name: 'every_title_to_title_neighboring_and_across_water_county', description: 'Scopes from a title to a neighboring county (incl. across water, looking trough the de Jure lieges)', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_title_to_title_neighboring_and_across_water_county = { limit = { <triggers> } <effects> }" },
  { name: 'every_title_to_title_neighboring_and_across_water_duchy', description: 'Scopes from a title to a neighboring duchy (incl. across water, looking trough the de Jure lieges)', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_title_to_title_neighboring_and_across_water_duchy = { limit = { <triggers> } <effects> }" },
  { name: 'every_title_to_title_neighboring_and_across_water_empire', description: 'Scopes from a title to a neighboring empire (incl. across water, looking trough the de Jure lieges)', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_title_to_title_neighboring_and_across_water_empire = { limit = { <triggers> } <effects> }" },
  { name: 'every_title_to_title_neighboring_and_across_water_kingdom', description: 'Scopes from a title to a neighboring kingdom (incl. across water, looking trough the de Jure lieges)', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_title_to_title_neighboring_and_across_water_kingdom = { limit = { <triggers> } <effects> }" },
  { name: 'every_title_to_title_neighboring_county', description: 'Scopes from a title to a neighboring county (looking trough the de Jure lieges)', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_title_to_title_neighboring_county = { limit = { <triggers> } <effects> }" },
  { name: 'every_title_to_title_neighboring_duchy', description: 'Scopes from a title to a neighboring duchy (looking trough the de Jure lieges)', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_title_to_title_neighboring_duchy = { limit = { <triggers> } <effects> }" },
  { name: 'every_title_to_title_neighboring_empire', description: 'Scopes from a title to a neighboring empire (looking trough the de Jure lieges)', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_title_to_title_neighboring_empire = { limit = { <triggers> } <effects> }" },
  { name: 'every_title_to_title_neighboring_kingdom', description: 'Scopes from a title to a neighboring kingdom (looking trough the de Jure lieges)', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_title_to_title_neighboring_kingdom = { limit = { <triggers> } <effects> }" },
  { name: 'lease_out_to', description: 'Lease out the scoped title', supportedScopes: ['landed_title'], supportedTargets: ['holy_order'], syntax: "lease_out_to = scope:a_holy_order" },
  { name: 'ordered_claimant', description: 'Iterate through all claimants to title. parameters: explicit = yes/no/all - default yes', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_claimant = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_connected_county', description: 'Iterate through all counties connected to this one. Is based on top liege', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "any/every/whatever_connectec_county = {\nmax_naval_distance = 500\nallow_one_county_land_gap = yes\nordered_connected_county = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_controlled_faith', description: 'Iterate through all faiths headed by a title', supportedScopes: ['landed_title'], supportedTargets: ['faith'], outputScope: 'faith', isIterator: true, syntax: "ordered_controlled_faith = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_county_province', description: 'Iterate through all provinces in a county', supportedScopes: ['landed_title'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, syntax: "ordered_county_province = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_county_struggle', description: 'Iterate through all struggles that a county is involved in.', supportedScopes: ['landed_title'], supportedTargets: ['struggle'], outputScope: 'struggle', isIterator: true, syntax: "ordered_county_struggle = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_de_jure_county', description: 'Iterate through all counties within this dejure title', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_de_jure_county = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_de_jure_county_holder', description: 'Iterate through all characters directly holding counties within this dejure title', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_de_jure_county_holder = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_de_jure_top_liege', description: 'Iterate through all top lieges of the counts within this dejure title', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_de_jure_top_liege = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_dejure_vassal_title_holder', description: 'Iterate through all the vassal holders of the title', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_dejure_vassal_title_holder = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_direct_de_facto_vassal_title', description: 'Iterate through all de facto vassal titles', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_direct_de_facto_vassal_title = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_direct_de_jure_vassal_title', description: 'Iterate through the all de jure vassals titles', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_direct_de_jure_vassal_title = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_election_candidate', description: 'Iterate through all characters who are valid candidates in an election for a title', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_election_candidate = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_elector', description: 'Iterate through all characters who are valid electors in an election for a title', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_elector = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_in_de_facto_hierarchy', description: 'Iterate through the title itself, all de facto vassals, and below. The continue trigger specifies whether to recursively iterate through the vassal\'s vassal', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "This is unrelated to the limit; if the limit is met it is added to the list, but its vassals will get checked even if the limit isn't met as long as the 'continue' trigger is\n..._de_jure_vassal_and_below = { continue = { conditions } }\nordered_in_de_facto_hierarchy = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_in_de_jure_hierarchy', description: 'Iterate through the title itself, all de jure vassals, and below. The continue trigger specifies whether to recursively iterate through the vassal\'s vassal', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "This is unrelated to the limit; if the limit is met it is added to the list, but its vassals will get checked even if the limit isn't met as long as the 'continue' trigger is\n..._de_jure_vassal_and_below = { continue = { conditions } }\nordered_in_de_jure_hierarchy = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_neighboring_county', description: 'Iterate through all neighboring counties. Can only be used in county scope', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_neighboring_county = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_past_holder', description: 'Iterate through all past owners of a title from earliest to latest', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_past_holder = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_past_holder_reversed', description: 'Iterate through all past owners of a title from latest to earliest', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_past_holder_reversed = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_this_title_or_de_jure_above', description: 'Iterate through this title and all its dejure liege titles', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_this_title_or_de_jure_above = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_title_heir', description: 'Line of succession for the scoped title', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_title_heir = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_title_joined_faction', description: 'Iterate through all factions joined the scope landed title', supportedScopes: ['landed_title'], supportedTargets: ['faction'], outputScope: 'faction', isIterator: true, syntax: "ordered_title_joined_faction = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_title_to_title_neighboring_and_across_water_county', description: 'Scopes from a title to a neighboring county (incl. across water, looking trough the de Jure lieges)', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_title_to_title_neighboring_and_across_water_county = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_title_to_title_neighboring_and_across_water_duchy', description: 'Scopes from a title to a neighboring duchy (incl. across water, looking trough the de Jure lieges)', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_title_to_title_neighboring_and_across_water_duchy = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_title_to_title_neighboring_and_across_water_empire', description: 'Scopes from a title to a neighboring empire (incl. across water, looking trough the de Jure lieges)', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_title_to_title_neighboring_and_across_water_empire = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_title_to_title_neighboring_and_across_water_kingdom', description: 'Scopes from a title to a neighboring kingdom (incl. across water, looking trough the de Jure lieges)', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_title_to_title_neighboring_and_across_water_kingdom = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_title_to_title_neighboring_county', description: 'Scopes from a title to a neighboring county (looking trough the de Jure lieges)', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_title_to_title_neighboring_county = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_title_to_title_neighboring_duchy', description: 'Scopes from a title to a neighboring duchy (looking trough the de Jure lieges)', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_title_to_title_neighboring_duchy = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_title_to_title_neighboring_empire', description: 'Scopes from a title to a neighboring empire (looking trough the de Jure lieges)', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_title_to_title_neighboring_empire = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_title_to_title_neighboring_kingdom', description: 'Scopes from a title to a neighboring kingdom (looking trough the de Jure lieges)', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_title_to_title_neighboring_kingdom = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'random_claimant', description: 'Iterate through all claimants to title. parameters: explicit = yes/no/all - default yes', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_claimant = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_connected_county', description: 'Iterate through all counties connected to this one. Is based on top liege', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "any/every/whatever_connectec_county = {\nmax_naval_distance = 500\nallow_one_county_land_gap = yes\nrandom_connected_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_controlled_faith', description: 'Iterate through all faiths headed by a title', supportedScopes: ['landed_title'], supportedTargets: ['faith'], outputScope: 'faith', isIterator: true, syntax: "random_controlled_faith = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_county_province', description: 'Iterate through all provinces in a county', supportedScopes: ['landed_title'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, syntax: "random_county_province = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_county_struggle', description: 'Iterate through all struggles that a county is involved in.', supportedScopes: ['landed_title'], supportedTargets: ['struggle'], outputScope: 'struggle', isIterator: true, syntax: "random_county_struggle = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_de_jure_county', description: 'Iterate through all counties within this dejure title', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_de_jure_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_de_jure_county_holder', description: 'Iterate through all characters directly holding counties within this dejure title', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_de_jure_county_holder = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_de_jure_top_liege', description: 'Iterate through all top lieges of the counts within this dejure title', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_de_jure_top_liege = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_dejure_vassal_title_holder', description: 'Iterate through all the vassal holders of the title', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_dejure_vassal_title_holder = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_direct_de_facto_vassal_title', description: 'Iterate through all de facto vassal titles', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_direct_de_facto_vassal_title = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_direct_de_jure_vassal_title', description: 'Iterate through the all de jure vassals titles', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_direct_de_jure_vassal_title = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_election_candidate', description: 'Iterate through all characters who are valid candidates in an election for a title', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_election_candidate = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_elector', description: 'Iterate through all characters who are valid electors in an election for a title', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_elector = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_in_de_facto_hierarchy', description: 'Iterate through the title itself, all de facto vassals, and below. The continue trigger specifies whether to recursively iterate through the vassal\'s vassal', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "This is unrelated to the limit; if the limit is met it is added to the list, but its vassals will get checked even if the limit isn't met as long as the 'continue' trigger is\n..._de_jure_vassal_and_below = { continue = { conditions } }\nrandom_in_de_facto_hierarchy = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_in_de_jure_hierarchy', description: 'Iterate through the title itself, all de jure vassals, and below. The continue trigger specifies whether to recursively iterate through the vassal\'s vassal', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "This is unrelated to the limit; if the limit is met it is added to the list, but its vassals will get checked even if the limit isn't met as long as the 'continue' trigger is\n..._de_jure_vassal_and_below = { continue = { conditions } }\nrandom_in_de_jure_hierarchy = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_neighboring_county', description: 'Iterate through all neighboring counties. Can only be used in county scope', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_neighboring_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_past_holder', description: 'Iterate through all past owners of a title from earliest to latest', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_past_holder = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_past_holder_reversed', description: 'Iterate through all past owners of a title from latest to earliest', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_past_holder_reversed = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_this_title_or_de_jure_above', description: 'Iterate through this title and all its dejure liege titles', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_this_title_or_de_jure_above = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_title_heir', description: 'Line of succession for the scoped title', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_title_heir = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_title_joined_faction', description: 'Iterate through all factions joined the scope landed title', supportedScopes: ['landed_title'], supportedTargets: ['faction'], outputScope: 'faction', isIterator: true, syntax: "random_title_joined_faction = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_title_to_title_neighboring_and_across_water_county', description: 'Scopes from a title to a neighboring county (incl. across water, looking trough the de Jure lieges)', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_title_to_title_neighboring_and_across_water_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_title_to_title_neighboring_and_across_water_duchy', description: 'Scopes from a title to a neighboring duchy (incl. across water, looking trough the de Jure lieges)', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_title_to_title_neighboring_and_across_water_duchy = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_title_to_title_neighboring_and_across_water_empire', description: 'Scopes from a title to a neighboring empire (incl. across water, looking trough the de Jure lieges)', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_title_to_title_neighboring_and_across_water_empire = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_title_to_title_neighboring_and_across_water_kingdom', description: 'Scopes from a title to a neighboring kingdom (incl. across water, looking trough the de Jure lieges)', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_title_to_title_neighboring_and_across_water_kingdom = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_title_to_title_neighboring_county', description: 'Scopes from a title to a neighboring county (looking trough the de Jure lieges)', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_title_to_title_neighboring_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_title_to_title_neighboring_duchy', description: 'Scopes from a title to a neighboring duchy (looking trough the de Jure lieges)', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_title_to_title_neighboring_duchy = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_title_to_title_neighboring_empire', description: 'Scopes from a title to a neighboring empire (looking trough the de Jure lieges)', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_title_to_title_neighboring_empire = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_title_to_title_neighboring_kingdom', description: 'Scopes from a title to a neighboring kingdom (looking trough the de Jure lieges)', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_title_to_title_neighboring_kingdom = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'remove_all_county_modifier_instances', description: 'Remove all instances of a modifier from a county', supportedScopes: ['landed_title'], syntax: "remove_all_county_modifier_instances = name" },
  { name: 'remove_county_modifier', description: 'Remove a modifier from a county', supportedScopes: ['landed_title'], syntax: "remove_county_modifier = name" },
  { name: 'reset_title_name', description: 'Sets the name and adjective of the scoped title back to being based on its key. Won\'t cause the prefix to change', supportedScopes: ['landed_title'], syntax: "reset_title_name = yes" },
  { name: 'reset_title_prefix', description: 'Sets the prefix of the scoped title back to being based on its key. Won\'t cause its adjective or name to change', supportedScopes: ['landed_title'], syntax: "reset_title_prefix = yes" },
  { name: 'revoke_lease', description: 'Revoke the lease of the scoped title', supportedScopes: ['landed_title'], syntax: "revoke_lease = yes" },
  { name: 'set_always_follows_primary_heir', description: 'Sets if the title should always go to the primary heir in partition succession', supportedScopes: ['landed_title'], syntax: "set_always_follows_primary_heir = yes" },
  { name: 'set_can_be_named_after_dynasty', description: 'Sets if the title can be named after it\'s holder\'s dynasty. set_can_be_named_after_dynasty_effect = no', supportedScopes: ['landed_title'] },
  { name: 'set_capital_barony', description: 'Sets scoped barony to be the county capital', supportedScopes: ['landed_title'], syntax: "set_capital_barony = yes" },
  { name: 'set_capital_county', description: 'Sets the capital county of the title to the target county', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], syntax: "set_capital_county = <some county title>" },
  { name: 'set_color_from_title', description: 'Sets the color of the title to the same as the target title (shifted very slightly to not be identical)', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], syntax: "set_color_from_title = <some title>" },
  { name: 'set_county_culture', description: 'sets the culture of a county', supportedScopes: ['landed_title'], supportedTargets: ['culture'], syntax: "usage:\nset_county_culture = culture:english/root.character_culture" },
  { name: 'set_county_faith', description: 'Changes what faith a county has', supportedScopes: ['landed_title'], supportedTargets: ['faith'] },
  { name: 'set_de_jure_liege_title', description: 'Set a new DeJure liege title', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], syntax: "set_de_jure_liege_title = new_de_jure_liege" },
  { name: 'set_definitive_form', description: 'Sets if the title should use a definitive form name (no \'Kingdom of\')', supportedScopes: ['landed_title'], syntax: "set_definitive_form = yes" },
  { name: 'set_delete_on_destroy', description: 'Sets if the title should be deleted from the gamestate completely when it is destroyed. set_delete_on_destroy = yes', supportedScopes: ['landed_title'] },
  { name: 'set_destroy_if_invalid_heir', description: 'Sets if the title should be destroyed on succession if there\'s no heir matching its restrictions. set_destroy_if_invalid_heir = yes', supportedScopes: ['landed_title'] },
  { name: 'set_destroy_on_gain_same_tier', description: 'Sets if the title should be deleted from the gamestate completely when character gains or create a new title with the same tier.set_destroy_on_gain_same_tier = yes', supportedScopes: ['landed_title'] },
  { name: 'set_destroy_on_succession', description: 'Sets if the title should be destroyed on succession. set_destroy_on_succession = yes', supportedScopes: ['landed_title'] },
  { name: 'set_landless_title', description: 'Sets if the title is landless (can be held by rulers with no land)', supportedScopes: ['landed_title'], syntax: "set_landless_title = yes" },
  { name: 'set_no_automatic_claims', description: 'Sets if the title should disallow automatic claims (meaning claims will only be added by script, and by pressed claims being inherited).', supportedScopes: ['landed_title'], syntax: "set_no_automatic_claims = yes" },
  { name: 'set_title_name', description: 'sets the name (localization key) of the scoped title. The adjective will be constructed by adding \'_adj\' to the localisation key. Won\'t cause the prefix to change', supportedScopes: ['landed_title'], syntax: "set_title_name = TEST_NAME_PLEASE_IGNORE" },
  { name: 'set_title_prefix', description: 'sets the prefix of the scoped title. Won\'t cause its name or adjective to change', supportedScopes: ['landed_title'], syntax: "set_title_prefix = PREFIX_THE" },
  { name: 'title_create_faction', description: 'the scoped landed title creates a faction of the specified type against the specified target, title_create_faction = { type = X target = Y }', supportedScopes: ['landed_title'] },
  { name: 'title_join_faction', description: 'the landed title in the scope joins the assigned faction', supportedScopes: ['landed_title'], supportedTargets: ['faction'] },
  { name: 'title_leave_faction', description: 'the title in the scope leaves the assigned faction', supportedScopes: ['landed_title'], supportedTargets: ['faction'] },
  { name: 'update_dynamic_coa', description: 'update_dynamic_coa = yes', supportedScopes: ['landed_title'], syntax: "Updates the dynamic coat of arms definition of a given title picking a new one and overwriting the existing set coat of arms with it if picked" },
];

/**
 * Effects for province scope (24 effects)
 */
export const provinceEffects: EffectDefinition[] = [
  { name: 'add_building', description: 'Add building to the province<province> = { add_building = <building_name> }', supportedScopes: ['province'] },
  { name: 'add_province_modifier', description: 'Add a modifier to a province', supportedScopes: ['province'], syntax: "add_province_modifier = name\nadd_province_modifier = { modifier = name days/weeks/months/years = int }\nYou can also add an optional 'desc' field. This is a dynamic description that'll be used for your timed modifier" },
  { name: 'add_special_building', description: 'Add a special building to the province (will also add/change a special slot if needed)', supportedScopes: ['province'] },
  { name: 'add_special_building_slot', description: 'Add a special building slot to the province<province> = { add_special_building_slot = <building_name> }', supportedScopes: ['province'] },
  { name: 'add_travel_point_of_interest', description: 'Add a travel point of interest type to this province.', supportedScopes: ['province'], syntax: "add_travel_point_of_interest = point_of_interest_type" },
  { name: 'begin_create_holding', description: 'Start construction of the specified holding type. By default player won\'t get anything if manually cancels the construction', supportedScopes: ['province'], syntax: "scope:my_province = {\nbegin_create_holding = castle_holding\n}\nOptionally refund cost can be set to some value.\nscope:my_province = {\nbegin_create_holding = {\ntype = castle_holding\nrefund_cost = {\ngold = 100\n}\n}\n}" },
  { name: 'every_army_in_location', description: 'Iterate through all armies currently located in the scoped province', supportedScopes: ['province'], supportedTargets: ['army'], outputScope: 'army', isIterator: true, syntax: "every_army_in_location = { limit = { <triggers> } <effects> }" },
  { name: 'every_character_in_location', description: 'Iterate through all characters currently located in the scoped province', supportedScopes: ['province'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_character_in_location = { limit = { <triggers> } <effects> }" },
  { name: 'every_neighboring_province', description: 'Iterate through all neighboring provinces of a province', supportedScopes: ['province'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, syntax: "every_neighboring_province = { limit = { <triggers> } <effects> }" },
  { name: 'generate_building', description: 'Adds a random building to the province, using the AI\'s construction logic<province> = { generate_building = yes }', supportedScopes: ['province'] },
  { name: 'ordered_army_in_location', description: 'Iterate through all armies currently located in the scoped province', supportedScopes: ['province'], supportedTargets: ['army'], outputScope: 'army', isIterator: true, syntax: "ordered_army_in_location = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_character_in_location', description: 'Iterate through all characters currently located in the scoped province', supportedScopes: ['province'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_character_in_location = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_neighboring_province', description: 'Iterate through all neighboring provinces of a province', supportedScopes: ['province'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, syntax: "ordered_neighboring_province = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'random_army_in_location', description: 'Iterate through all armies currently located in the scoped province', supportedScopes: ['province'], supportedTargets: ['army'], outputScope: 'army', isIterator: true, syntax: "random_army_in_location = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_character_in_location', description: 'Iterate through all characters currently located in the scoped province', supportedScopes: ['province'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_character_in_location = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_neighboring_province', description: 'Iterate through all neighboring provinces of a province', supportedScopes: ['province'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, syntax: "random_neighboring_province = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'refill_garrison', description: 'The scoped province gets its garrison refilled. refill_levy = yes/no', supportedScopes: ['province'] },
  { name: 'refill_levy', description: 'The scoped province gets its levy refilled. refill_levy = yes/no', supportedScopes: ['province'] },
  { name: 'remove_all_province_modifier_instances', description: 'Remove all instances of a modifier from a province', supportedScopes: ['province'], syntax: "remove_all_province_modifier_instances = name" },
  { name: 'remove_building', description: 'Remove building from the province<province> = { remove_building = <building_name> }', supportedScopes: ['province'] },
  { name: 'remove_holding', description: 'Removes the holding in scoped province, cannot remove capital holdings', supportedScopes: ['province'] },
  { name: 'remove_province_modifier', description: 'Remove a modifier from a province', supportedScopes: ['province'], syntax: "remove_province_modifier = name" },
  { name: 'remove_travel_point_of_interest', description: 'Remove a travel point of interest type in this province.', supportedScopes: ['province'], syntax: "remove_travel_point_of_interest = point_of_interest_type" },
  { name: 'set_holding_type', description: 'Changes the scoped province\'s holding to another type, removing all buildings that are invalid for the new holding.', supportedScopes: ['province'], syntax: "This might also allow to construct a new holding in an empty province, but it is untested." },
];

/**
 * Effects for dynasty scope (11 effects)
 */
export const dynastyEffects: EffectDefinition[] = [
  { name: 'add_dynasty_modifier', description: 'Add a modifier to a dynasty', supportedScopes: ['dynasty'], syntax: "add_dynasty_modifier = name\nadd_dynasty_modifier = { modifier = name days/weeks/months/years = int }\nYou can also add an optional 'desc' field. This is a dynamic description that'll be used for your timed modifier" },
  { name: 'add_dynasty_perk', description: 'Adds dynasty perk. add_dynasty_perk = key', supportedScopes: ['dynasty'] },
  { name: 'add_dynasty_prestige', description: 'adds dynasty prestige', supportedScopes: ['dynasty'] },
  { name: 'add_dynasty_prestige_level', description: 'adds dynasty prestige levels', supportedScopes: ['dynasty'] },
  { name: 'every_dynasty_member', description: 'Iterate through all dynasty members', supportedScopes: ['dynasty'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_dynasty_member = { limit = { <triggers> } <effects> }" },
  { name: 'ordered_dynasty_member', description: 'Iterate through all dynasty members', supportedScopes: ['dynasty'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_dynasty_member = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'random_dynasty_member', description: 'Iterate through all dynasty members', supportedScopes: ['dynasty'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_dynasty_member = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'remove_all_dynasty_modifier_instances', description: 'Remove all instances of a modifier from a dynasty', supportedScopes: ['dynasty'], syntax: "remove_all_dynasty_modifier_instances = name" },
  { name: 'remove_dynasty_modifier', description: 'Remove a modifier from a dynasty', supportedScopes: ['dynasty'], syntax: "remove_dynasty_modifier = name" },
  { name: 'remove_dynasty_perk', description: 'Removes dynasty perk. remove_dynasty_perk = key', supportedScopes: ['dynasty'] },
  { name: 'set_dynasty_name', description: 'Sets dynasty name', supportedScopes: ['dynasty'], syntax: "set_dynasty_name=loc_key" },
];

/**
 * Effects for dynasty_house scope (14 effects)
 */
export const dynastyhouseEffects: EffectDefinition[] = [
  { name: 'add_house_artifact_claim', description: 'Adds a claim on the target artifact to the scoped house', supportedScopes: ['dynasty_house'], supportedTargets: ['artifact'] },
  { name: 'add_house_modifier', description: 'Add a modifier to a house', supportedScopes: ['dynasty_house'], syntax: "add_house_modifier = name\nadd_house_modifier = { modifier = name days/weeks/months/years = int }\nYou can also add an optional 'desc' field. This is a dynamic description that'll be used for your timed modifier" },
  { name: 'every_house_claimed_artifact', description: 'Iterate through all claimed artifacts of the scoped house', supportedScopes: ['dynasty_house'], supportedTargets: ['artifact'], outputScope: 'artifact', isIterator: true, syntax: "every_house_claimed_artifact = { limit = { <triggers> } <effects> }" },
  { name: 'every_house_member', description: 'Iterate through all house members', supportedScopes: ['dynasty_house'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_house_member = { limit = { <triggers> } <effects> }" },
  { name: 'ordered_house_claimed_artifact', description: 'Iterate through all claimed artifacts of the scoped house', supportedScopes: ['dynasty_house'], supportedTargets: ['artifact'], outputScope: 'artifact', isIterator: true, syntax: "ordered_house_claimed_artifact = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_house_member', description: 'Iterate through all house members', supportedScopes: ['dynasty_house'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_house_member = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'random_house_claimed_artifact', description: 'Iterate through all claimed artifacts of the scoped house', supportedScopes: ['dynasty_house'], supportedTargets: ['artifact'], outputScope: 'artifact', isIterator: true, syntax: "random_house_claimed_artifact = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_house_member', description: 'Iterate through all house members', supportedScopes: ['dynasty_house'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_house_member = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'remove_all_house_modifier_instances', description: 'Remove all instances of a modifier from a house', supportedScopes: ['dynasty_house'], syntax: "remove_all_house_modifier_instances = name" },
  { name: 'remove_house_artifact_claim', description: 'Removes a claim on the target artifact from the scoped house', supportedScopes: ['dynasty_house'], supportedTargets: ['artifact'] },
  { name: 'remove_house_modifier', description: 'Remove a modifier from a house', supportedScopes: ['dynasty_house'], syntax: "remove_house_modifier = name" },
  { name: 'set_house_name', description: 'Sets dynasty house name', supportedScopes: ['dynasty_house'], syntax: "set_house_name=loc_key" },
  { name: 'set_house_name_from_dynasty', description: 'Sets dynasty house name from another dynasty\'s name', supportedScopes: ['dynasty_house'], supportedTargets: ['dynasty'], syntax: "set_house_name_from_dynasty = dynasty" },
  { name: 'set_house_name_from_house', description: 'Sets dynasty house name from another dynasty house\'s name', supportedScopes: ['dynasty_house'], supportedTargets: ['dynasty_house'], syntax: "set_house_name_from_house = house" },
];

/**
 * Effects for culture scope (46 effects)
 */
export const cultureEffects: EffectDefinition[] = [
  { name: 'add_culture_tradition', description: 'Adds the cultural tradition scope specified in the RHS to the scope culture.add_culture_tradition = tradition_court_eunuchs', supportedScopes: ['culture'], supportedTargets: ['culture_tradition'] },
  { name: 'add_innovation', description: 'Add innovation to a culture. add_innovation = innovation_key', supportedScopes: ['culture'] },
  { name: 'add_name_list', description: 'Adds the name list to the culture', supportedScopes: ['culture'], syntax: "<culture> = { add_name_list = name }" },
  { name: 'add_random_innovation', description: 'Add random available innovation<culture> = { add_random_innovation = culture_group_military/culture_group_civic/culture_group_regional/yes }', supportedScopes: ['culture'] },
  { name: 'add_random_valid_tradition', description: 'Adds one random valid tradition to a culture. Target character provides context for can_pick and is_shown. If this would put the culture over the tradition limit, an error is loggedadd_random_valid_tradition = scope:character', supportedScopes: ['culture'], supportedTargets: ['character'] },
  { name: 'add_random_valid_tradition_replace_if_necessary', description: 'Adds one random valid tradition to a culture. Target character provides context for can_pick and is_shown. If this would put the culture over the tradition limit, a random existing tradition is removedadd_random_valid_tradition_replace_if_necessary = scope:character', supportedScopes: ['culture'], supportedTargets: ['character'] },
  { name: 'change_cultural_acceptance', description: 'Changes cultural acceptance with the target culture', supportedScopes: ['culture'], syntax: "change_cultural_acceptance = {\ntarget = <culture>\nvalue = script value\ndesc = dynamic desc. Description that'll show when hovering over the acceptance tooltip in the culture window\n}" },
  { name: 'clear_culture_traditions', description: 'Removes all cultural traditions from the scope culture.clear_culture_traditions = yes', supportedScopes: ['culture'] },
  { name: 'copy_all_traditions_from', description: 'Replaces all traditions of scoped culture with traditions from the given culturecopy_all_traditions_from = scope:target_culture', supportedScopes: ['culture'], supportedTargets: ['culture'] },
  { name: 'every_culture_county', description: 'Iterate through all counties of the culture', supportedScopes: ['culture'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_culture_county = { limit = { <triggers> } <effects> }" },
  { name: 'every_culture_duchy', description: 'Iterate through all duchies of the culture (duchies with at least one county of the culture', supportedScopes: ['culture'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_culture_duchy = { limit = { <triggers> } <effects> }" },
  { name: 'every_culture_empire', description: 'Iterate through all empires of the culture (empires with at least one county of the culture', supportedScopes: ['culture'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_culture_empire = { limit = { <triggers> } <effects> }" },
  { name: 'every_culture_kingdom', description: 'Iterate through all kingdoms of the culture (kingdoms with at least one county of the culture', supportedScopes: ['culture'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_culture_kingdom = { limit = { <triggers> } <effects> }" },
  { name: 'every_parent_culture', description: 'Iterate through all parent cultures', supportedScopes: ['culture'], supportedTargets: ['culture'], outputScope: 'culture', isIterator: true, syntax: "every_parent_culture = { limit = { <triggers> } <effects> }" },
  { name: 'every_parent_culture_or_above', description: 'Iterate through all parent cultures or above', supportedScopes: ['culture'], supportedTargets: ['culture'], outputScope: 'culture', isIterator: true, syntax: "every_parent_culture_or_above = { limit = { <triggers> } <effects> }" },
  { name: 'every_tradition', description: 'Iterate through all traditions of the given culture', supportedScopes: ['culture'], supportedTargets: ['culture_tradition'], outputScope: 'culture_tradition', isIterator: true, syntax: "every_tradition = { limit = { <triggers> } <effects> }" },
  { name: 'get_all_innovations_from', description: 'Discover all innovations from the target culture', supportedScopes: ['culture'], supportedTargets: ['culture'], syntax: "get_all_innovations_from = <culture>" },
  { name: 'get_random_innovation_from', description: 'Get random available innovation from another culture', supportedScopes: ['culture'] },
  { name: 'join_era', description: 'Joins all culture eras up to and including the given one', supportedScopes: ['culture'], syntax: "join_era = culture_era_type" },
  { name: 'leave_era', description: 'Leaves all culture eras down to and including the given one', supportedScopes: ['culture'], syntax: "leave_era = culture_era_type" },
  { name: 'ordered_culture_county', description: 'Iterate through all counties of the culture', supportedScopes: ['culture'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_culture_county = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_culture_duchy', description: 'Iterate through all duchies of the culture (duchies with at least one county of the culture', supportedScopes: ['culture'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_culture_duchy = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_culture_empire', description: 'Iterate through all empires of the culture (empires with at least one county of the culture', supportedScopes: ['culture'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_culture_empire = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_culture_kingdom', description: 'Iterate through all kingdoms of the culture (kingdoms with at least one county of the culture', supportedScopes: ['culture'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_culture_kingdom = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_parent_culture', description: 'Iterate through all parent cultures', supportedScopes: ['culture'], supportedTargets: ['culture'], outputScope: 'culture', isIterator: true, syntax: "ordered_parent_culture = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_parent_culture_or_above', description: 'Iterate through all parent cultures or above', supportedScopes: ['culture'], supportedTargets: ['culture'], outputScope: 'culture', isIterator: true, syntax: "ordered_parent_culture_or_above = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_tradition', description: 'Iterate through all traditions of the given culture', supportedScopes: ['culture'], supportedTargets: ['culture_tradition'], outputScope: 'culture_tradition', isIterator: true, syntax: "ordered_tradition = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'random_culture_county', description: 'Iterate through all counties of the culture', supportedScopes: ['culture'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_culture_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_culture_duchy', description: 'Iterate through all duchies of the culture (duchies with at least one county of the culture', supportedScopes: ['culture'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_culture_duchy = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_culture_empire', description: 'Iterate through all empires of the culture (empires with at least one county of the culture', supportedScopes: ['culture'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_culture_empire = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_culture_kingdom', description: 'Iterate through all kingdoms of the culture (kingdoms with at least one county of the culture', supportedScopes: ['culture'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_culture_kingdom = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_parent_culture', description: 'Iterate through all parent cultures', supportedScopes: ['culture'], supportedTargets: ['culture'], outputScope: 'culture', isIterator: true, syntax: "random_parent_culture = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_parent_culture_or_above', description: 'Iterate through all parent cultures or above', supportedScopes: ['culture'], supportedTargets: ['culture'], outputScope: 'culture', isIterator: true, syntax: "random_parent_culture_or_above = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_tradition', description: 'Iterate through all traditions of the given culture', supportedScopes: ['culture'], supportedTargets: ['culture_tradition'], outputScope: 'culture_tradition', isIterator: true, syntax: "random_tradition = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'remove_culture_tradition', description: 'Removes the cultural tradition scope specified in the RHS from the scope culture.remove_culture_tradition = tradition_court_eunuchs', supportedScopes: ['culture'], supportedTargets: ['culture_tradition'] },
  { name: 'remove_innovation', description: 'Remove innovation from a culture. remove_innovation = innovation_key', supportedScopes: ['culture'] },
  { name: 'remove_random_culture_tradition', description: 'Removes a random cultural tradition from the scope culture.remove_random_culture_tradition = yes', supportedScopes: ['culture'] },
  { name: 'reset_culture_creation_date', description: 'Sets the culture creation date to be todays datereset_culture_creation_date = yes', supportedScopes: ['culture'] },
  { name: 'set_cultural_acceptance', description: 'Sets cultural acceptance with the target culture', supportedScopes: ['culture'], syntax: "set_cultural_accpetance = { target = <culture> value = script value }" },
  { name: 'set_culture_name', description: 'Permanently sets the name of the scope culture to the parsed text from the provided localization string.', supportedScopes: ['culture'], syntax: "Like 'set_title_name', the new name is static and unchanging (i.e., if the localization key provided is 'Neo-[old_culture.GetName]' and the old culture is French, the new name is just be saved as a simple string, 'Neo-French', so that if/when the old_culture scope is cleaned up the localization does not break.set_culture_name = {\nnoun = dynamic description\ncollective_noun = dynamic description\nprefix = dynamic description\n}" },
  { name: 'set_culture_pillar', description: 'Adds the current pillar specified in the RHS to the scope culture, replacing the pillar in the matching slot.set_culture_pillar = ethos_warmonger', supportedScopes: ['culture'] },
  { name: 'set_ethos_from', description: 'Set the ethos from the RHS on the scope culture.set_ethos_from = culture:norwegian', supportedScopes: ['culture'], supportedTargets: ['culture'] },
  { name: 'set_heritage_from', description: 'Set the heritage from the RHS on the scope culture.set_heritage_from = culture:norwegian', supportedScopes: ['culture'], supportedTargets: ['culture'] },
  { name: 'set_language_from', description: 'Set the language from the RHS on the scope culture.set_language_from = culture:norwegian', supportedScopes: ['culture'], supportedTargets: ['culture'] },
  { name: 'set_martial_custom_from', description: 'Set the martial custom from the RHS on the scope culture.set_martial_custom_from = culture:norwegian', supportedScopes: ['culture'], supportedTargets: ['culture'] },
  { name: 'set_name_list', description: 'Remove all existing name lists then adds the specified name list to the culture', supportedScopes: ['culture'], syntax: "<culture> = { set_name_list = name }" },
];

/**
 * Effects for faith scope (26 effects)
 */
export const faithEffects: EffectDefinition[] = [
  { name: 'activate_holy_site', description: 'Activate an inactive holy site<faith_scope> = { activate_holy_site = <holy_site_name> }', supportedScopes: ['faith'] },
  { name: 'add_doctrine', description: 'Add doctrine to faith<faith_scope> = { add_doctrine = <doctrine_name> }', supportedScopes: ['faith'], supportedTargets: ['doctrine'] },
  { name: 'change_fervor', description: 'Changes the fervor of the faith by the given value. change_fervor = script value', supportedScopes: ['faith'] },
  { name: 'deactivate_holy_site', description: 'Deactivate an active holy site<faith_scope> = { deactivate_holy_site = <holy_site_name> }', supportedScopes: ['faith'] },
  { name: 'every_defensive_great_holy_wars', description: 'Iterate through all great holy wars this faith is defending against', supportedScopes: ['faith'], supportedTargets: ['ghw'], outputScope: 'ghw', isIterator: true, syntax: "every_defensive_great_holy_wars = { limit = { <triggers> } <effects> }" },
  { name: 'every_faith_character', description: 'Iterate through characters of the scoped faith', supportedScopes: ['faith'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_faith_character = { limit = { <triggers> } <effects> }" },
  { name: 'every_faith_holy_order', description: 'Iterate through all holy orders of the faith', supportedScopes: ['faith'], supportedTargets: ['holy_order'], outputScope: 'holy_order', isIterator: true, syntax: "every_faith_holy_order = { limit = { <triggers> } <effects> }" },
  { name: 'every_faith_playable_ruler', description: 'Iterate through playable rulers of the scoped faith', supportedScopes: ['faith'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_faith_playable_ruler = { limit = { <triggers> } <effects> }" },
  { name: 'every_faith_ruler', description: 'Iterate through rulers of the scoped faith', supportedScopes: ['faith'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_faith_ruler = { limit = { <triggers> } <effects> }" },
  { name: 'every_holy_site', description: 'Iterate through all holy site baronies of a faith', supportedScopes: ['faith'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_holy_site = { limit = { <triggers> } <effects> }" },
  { name: 'ordered_defensive_great_holy_wars', description: 'Iterate through all great holy wars this faith is defending against', supportedScopes: ['faith'], supportedTargets: ['ghw'], outputScope: 'ghw', isIterator: true, syntax: "ordered_defensive_great_holy_wars = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_faith_character', description: 'Iterate through characters of the scoped faith', supportedScopes: ['faith'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_faith_character = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_faith_holy_order', description: 'Iterate through all holy orders of the faith', supportedScopes: ['faith'], supportedTargets: ['holy_order'], outputScope: 'holy_order', isIterator: true, syntax: "ordered_faith_holy_order = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_faith_playable_ruler', description: 'Iterate through playable rulers of the scoped faith', supportedScopes: ['faith'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_faith_playable_ruler = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_faith_ruler', description: 'Iterate through rulers of the scoped faith', supportedScopes: ['faith'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_faith_ruler = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_holy_site', description: 'Iterate through all holy site baronies of a faith', supportedScopes: ['faith'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_holy_site = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'random_defensive_great_holy_wars', description: 'Iterate through all great holy wars this faith is defending against', supportedScopes: ['faith'], supportedTargets: ['ghw'], outputScope: 'ghw', isIterator: true, syntax: "random_defensive_great_holy_wars = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_faith_character', description: 'Iterate through characters of the scoped faith', supportedScopes: ['faith'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_faith_character = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_faith_holy_order', description: 'Iterate through all holy orders of the faith', supportedScopes: ['faith'], supportedTargets: ['holy_order'], outputScope: 'holy_order', isIterator: true, syntax: "random_faith_holy_order = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_faith_playable_ruler', description: 'Iterate through playable rulers of the scoped faith', supportedScopes: ['faith'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_faith_playable_ruler = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_faith_ruler', description: 'Iterate through rulers of the scoped faith', supportedScopes: ['faith'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_faith_ruler = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_holy_site', description: 'Iterate through all holy site baronies of a faith', supportedScopes: ['faith'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_holy_site = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'remove_doctrine', description: 'Remove doctrine from faith<faith_scope> = { remove_doctrine = <doctrine_name> }', supportedScopes: ['faith'], supportedTargets: ['doctrine'] },
  { name: 'remove_religious_head_title', description: 'Removes the religious head title of the faith', supportedScopes: ['faith'], syntax: "remove_religious_head_title = yes" },
  { name: 'set_religious_head_title', description: 'Sets the religious head title of the faith to the given title. set_religious_head_title = scope', supportedScopes: ['faith'], supportedTargets: ['landed_title'] },
  { name: 'start_great_holy_war', description: 'Starts a great holy war.', supportedScopes: ['faith'], syntax: "start_great_holy_war = {target_character = someonetarget_title = some titledelay = script value # Number of days until the war should startwar = some war # Optional. Will make this a directed GHW instead of undirected, and tie it to this specific war}" },
];

/**
 * Effects for religion scope (3 effects)
 */
export const religionEffects: EffectDefinition[] = [
  { name: 'every_faith', description: 'Iterate through all faiths within a religion', supportedScopes: ['religion'], supportedTargets: ['faith'], outputScope: 'faith', isIterator: true, syntax: "every_faith = { limit = { <triggers> } <effects> }" },
  { name: 'ordered_faith', description: 'Iterate through all faiths within a religion', supportedScopes: ['religion'], supportedTargets: ['faith'], outputScope: 'faith', isIterator: true, syntax: "ordered_faith = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'random_faith', description: 'Iterate through all faiths within a religion', supportedScopes: ['religion'], supportedTargets: ['faith'], outputScope: 'faith', isIterator: true, syntax: "random_faith = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
];

/**
 * Effects for army scope (4 effects)
 */
export const armyEffects: EffectDefinition[] = [
  { name: 'add_loot', description: 'Adds loot to the currently scoped raiding army.', supportedScopes: ['army'], syntax: "Usage:\nadd_loot = VALUE" },
  { name: 'assign_commander', description: 'Assign a commander for the scoped army', supportedScopes: ['army'], supportedTargets: ['character'], syntax: "set_commander = scope:a_character" },
  { name: 'remove_commander', description: 'Removes the currently assigned commander from the scoped army', supportedScopes: ['army'], syntax: "remove_commander = yes" },
  { name: 'set_army_location', description: 'Teleports the army to the given location. Cannot be done while in combat. Will cause combat to happen with this army as the attacker if there\'s hostiles in the target', supportedScopes: ['army'], supportedTargets: ['province'], syntax: "set_army_location = scope:province" },
];

/**
 * Effects for scheme scope (11 effects)
 */
export const schemeEffects: EffectDefinition[] = [
  { name: 'add_scheme_modifier', description: 'adds the specified scheme modifier, add_scheme_modifier = { type = X days = Y } (days are optional, the modifier will expire in Y days if specified)', supportedScopes: ['scheme'] },
  { name: 'add_scheme_progress', description: 'Add progress to the scope scheme. (progress is in 0.0 - 100.0 range)', supportedScopes: ['scheme'] },
  { name: 'end_scheme', description: 'Ends a specific scheme and removes it without any other effect', supportedScopes: ['scheme'] },
  { name: 'every_scheme_agent', description: 'Iterate through all agents in the scheme', supportedScopes: ['scheme'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_scheme_agent = { limit = { <triggers> } <effects> }" },
  { name: 'expose_scheme', description: 'Exposes the scheme to the defender', supportedScopes: ['scheme'] },
  { name: 'expose_scheme_agent', description: 'Exposes the target character as an agent of the current scheme', supportedScopes: ['scheme'], supportedTargets: ['character'] },
  { name: 'ordered_scheme_agent', description: 'Iterate through all agents in the scheme', supportedScopes: ['scheme'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_scheme_agent = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'random_scheme_agent', description: 'Iterate through all agents in the scheme', supportedScopes: ['scheme'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_scheme_agent = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'remove_scheme_modifier', description: 'removes the specified scheme modifier', supportedScopes: ['scheme'] },
  { name: 'scheme_freeze', description: 'scheme_freeze = { reason = LOC_KEY days/months/years = X } freezes the scheme for duration X. 0 duration for indefinite freeze, until scheme_unfreeze is called.', supportedScopes: ['scheme'] },
  { name: 'scheme_unfreeze', description: 'scheme_unfreeze = yes Unfreezes the scheme if it\'s frozen.', supportedScopes: ['scheme'] },
];

/**
 * Effects for war scope (16 effects)
 */
export const warEffects: EffectDefinition[] = [
  { name: 'add_attacker', description: 'adds the target character to the scope war as an attacker', supportedScopes: ['war'], supportedTargets: ['character'] },
  { name: 'add_defender', description: 'adds the target character to the scope war as a defender', supportedScopes: ['war'], supportedTargets: ['character'] },
  { name: 'clear_claimant', description: 'Removes the claimant from a war', supportedScopes: ['war'] },
  { name: 'end_war', description: 'ends the war with the specified winner, end_war = attacker/defender/white_peace', supportedScopes: ['war'] },
  { name: 'every_war_attacker', description: 'Iterate through all attackers in the war', supportedScopes: ['war'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_war_attacker = { limit = { <triggers> } <effects> }" },
  { name: 'every_war_defender', description: 'Iterate through all defenders in the war', supportedScopes: ['war'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_war_defender = { limit = { <triggers> } <effects> }" },
  { name: 'every_war_participant', description: 'Iterate through all participants in the war', supportedScopes: ['war'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_war_participant = { limit = { <triggers> } <effects> }" },
  { name: 'ordered_war_attacker', description: 'Iterate through all attackers in the war', supportedScopes: ['war'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_war_attacker = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_war_defender', description: 'Iterate through all defenders in the war', supportedScopes: ['war'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_war_defender = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_war_participant', description: 'Iterate through all participants in the war', supportedScopes: ['war'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_war_participant = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'random_war_attacker', description: 'Iterate through all attackers in the war', supportedScopes: ['war'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_war_attacker = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_war_defender', description: 'Iterate through all defenders in the war', supportedScopes: ['war'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_war_defender = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_war_participant', description: 'Iterate through all participants in the war', supportedScopes: ['war'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_war_participant = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'remove_participant', description: 'removes the target character from the scope war', supportedScopes: ['war'], supportedTargets: ['character'] },
  { name: 'set_called_to', description: 'sets the target character as already called to the scope war', supportedScopes: ['war'], supportedTargets: ['character'] },
  { name: 'set_casus_belli', description: 'sets the casus belli of the scope war', supportedScopes: ['war'] },
];

/**
 * Effects for activity scope (32 effects)
 */
export const activityEffects: EffectDefinition[] = [
  { name: 'add_activity_log_entry', description: 'add_activity_log_entry = {', supportedScopes: ['activity'], syntax: "key = <loc_key>\nscore = <script_value>\ntags = { <a> <b> <c> } # Optional\nshow_in_conclusion = yes/no # Optional, defaults to no\ncharacter = <character>\ntarget = <character> # Optional\nlocation = <province> # Optional, defaults to current activity loction\nartifact = <artifact> # Optional\n}\nAdd a new log entry to the scoped activity" },
  { name: 'add_to_current_phase_guest_subset', description: 'add_to_current_phase_guest_subset = {', supportedScopes: ['activity'], syntax: "name = <subset_key>\ntarget = scope:character\n}\nAdds the target character to the designated subset in the current phase." },
  { name: 'add_to_guest_subset', description: 'add_to_guest_subset = {', supportedScopes: ['activity'], syntax: "name = <subset_key>\ntarget = scope:character\nphase = <phase_key> # Optional\n}\nAdds the target character to the designated subset. Will add to all phases\nand ongoing subsets if phase is not specified. If a phase is specified, they\nwill be added to all phases of that type." },
  { name: 'every_activity_phase_location', description: 'Iterate through all province locations of the phases of the activity, optionally limited to unique locations.', supportedScopes: ['activity'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, syntax: "any/every/random_activity_phase_location {\nunique = yes/no\n}\nevery_activity_phase_location = { limit = { <triggers> } <effects> }" },
  { name: 'every_activity_phase_location_future', description: 'Iterate through all future province locations of the phases of the activity, optionally limited to unique locations. (\'future\' does not include any started phase)', supportedScopes: ['activity'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, syntax: "any/every/random_activity_phase_location_future {\nunique = yes/no\n}\nevery_activity_phase_location_future = { limit = { <triggers> } <effects> }" },
  { name: 'every_activity_phase_location_past', description: 'Iterate through all past province locations of the phases of the activity, optionally limited to unique locations. (\'past\' only includes ended phases)', supportedScopes: ['activity'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, syntax: "any/every/random_activity_phase_location_future {\nunique = yes/no\n}\nevery_activity_phase_location_past = { limit = { <triggers> } <effects> }" },
  { name: 'every_attending_character', description: 'Iterate through all characters attending an activity.', supportedScopes: ['activity'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "Invited guests that have not accepted/declined yet are not part of this list.\nSupports an optional state the character must be in.\nany_attending_character = { state = travel/passive/active }\nevery_attending_character = { limit = { <triggers> } <effects> }" },
  { name: 'every_guest_subset', description: 'any/every/random_guest_subset = {', supportedScopes: ['activity'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "name = <subset_key>\nphase = <phase_key> # Optional\n}\nIterates through characteres within the specified subset for past, current and\nfuture phases. If phase is specified it will only iterate through characters\nsubsets of that particular phase type.\nevery_guest_subset = { limit = { <triggers> } <effects> }" },
  { name: 'every_guest_subset_current_phase', description: 'any/every/random_guest_subset_current_phase = {', supportedScopes: ['activity'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "name = <subset_key>\n}\nIterates through characteres within the specified subset of the current phase.\nevery_guest_subset_current_phase = { limit = { <triggers> } <effects> }" },
  { name: 'every_invited_character', description: 'Iterate through all characters invited to an activity. Once they accept/decline, they are removed from this list.', supportedScopes: ['activity'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_invited_character = { limit = { <triggers> } <effects> }" },
  { name: 'every_special_guest', description: 'Iterate through all special guests of an activity.', supportedScopes: ['activity'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "any_special_guest = { ... }\nevery_special_guest = { limit = { <triggers> } <effects> }" },
  { name: 'ordered_activity_phase_location', description: 'Iterate through all province locations of the phases of the activity, optionally limited to unique locations.', supportedScopes: ['activity'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, syntax: "any/every/random_activity_phase_location {\nunique = yes/no\n}\nordered_activity_phase_location = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_activity_phase_location_future', description: 'Iterate through all future province locations of the phases of the activity, optionally limited to unique locations. (\'future\' does not include any started phase)', supportedScopes: ['activity'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, syntax: "any/every/random_activity_phase_location_future {\nunique = yes/no\n}\nordered_activity_phase_location_future = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_activity_phase_location_past', description: 'Iterate through all past province locations of the phases of the activity, optionally limited to unique locations. (\'past\' only includes ended phases)', supportedScopes: ['activity'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, syntax: "any/every/random_activity_phase_location_future {\nunique = yes/no\n}\nordered_activity_phase_location_past = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_attending_character', description: 'Iterate through all characters attending an activity.', supportedScopes: ['activity'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "Invited guests that have not accepted/declined yet are not part of this list.\nSupports an optional state the character must be in.\nany_attending_character = { state = travel/passive/active }\nordered_attending_character = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_guest_subset', description: 'any/every/random_guest_subset = {', supportedScopes: ['activity'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "name = <subset_key>\nphase = <phase_key> # Optional\n}\nIterates through characteres within the specified subset for past, current and\nfuture phases. If phase is specified it will only iterate through characters\nsubsets of that particular phase type.\nordered_guest_subset = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_guest_subset_current_phase', description: 'any/every/random_guest_subset_current_phase = {', supportedScopes: ['activity'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "name = <subset_key>\n}\nIterates through characteres within the specified subset of the current phase.\nordered_guest_subset_current_phase = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_invited_character', description: 'Iterate through all characters invited to an activity. Once they accept/decline, they are removed from this list.', supportedScopes: ['activity'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_invited_character = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_special_guest', description: 'Iterate through all special guests of an activity.', supportedScopes: ['activity'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "any_special_guest = { ... }\nordered_special_guest = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'progress_activity_phase_after', description: 'Progress the current activity phase forward after X days.', supportedScopes: ['activity'], syntax: "progress_activity_phase_after = { days = X weeks = Z months = Y}" },
  { name: 'random_activity_phase_location', description: 'Iterate through all province locations of the phases of the activity, optionally limited to unique locations.', supportedScopes: ['activity'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, syntax: "any/every/random_activity_phase_location {\nunique = yes/no\n}\nrandom_activity_phase_location = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_activity_phase_location_future', description: 'Iterate through all future province locations of the phases of the activity, optionally limited to unique locations. (\'future\' does not include any started phase)', supportedScopes: ['activity'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, syntax: "any/every/random_activity_phase_location_future {\nunique = yes/no\n}\nrandom_activity_phase_location_future = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_activity_phase_location_past', description: 'Iterate through all past province locations of the phases of the activity, optionally limited to unique locations. (\'past\' only includes ended phases)', supportedScopes: ['activity'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, syntax: "any/every/random_activity_phase_location_future {\nunique = yes/no\n}\nrandom_activity_phase_location_past = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_attending_character', description: 'Iterate through all characters attending an activity.', supportedScopes: ['activity'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "Invited guests that have not accepted/declined yet are not part of this list.\nSupports an optional state the character must be in.\nany_attending_character = { state = travel/passive/active }\nrandom_attending_character = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_guest_subset', description: 'any/every/random_guest_subset = {', supportedScopes: ['activity'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "name = <subset_key>\nphase = <phase_key> # Optional\n}\nIterates through characteres within the specified subset for past, current and\nfuture phases. If phase is specified it will only iterate through characters\nsubsets of that particular phase type.\nrandom_guest_subset = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_guest_subset_current_phase', description: 'any/every/random_guest_subset_current_phase = {', supportedScopes: ['activity'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "name = <subset_key>\n}\nIterates through characteres within the specified subset of the current phase.\nrandom_guest_subset_current_phase = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_invited_character', description: 'Iterate through all characters invited to an activity. Once they accept/decline, they are removed from this list.', supportedScopes: ['activity'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_invited_character = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_special_guest', description: 'Iterate through all special guests of an activity.', supportedScopes: ['activity'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "any_special_guest = { ... }\nrandom_special_guest = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'remove_from_current_phase_guest_subset', description: 'remove_from_current_phase_guest_subset = {', supportedScopes: ['activity'], syntax: "name = <subset_key>\ntarget = scope:character\n}\nRemoves the target character from the designated subset in the current phase." },
  { name: 'remove_from_guest_subset', description: 'add_to_guest_subset = {', supportedScopes: ['activity'], syntax: "name = <subset_key>\ntarget = scope:character\nphase = <phase_key> # Optional\n}\nRemoves the target character from the designated subset. Will remove from all\nupcoming and ongoing subsets if phase is not specified. If a phase is specified,\nthey will be removed from all phases of that type." },
  { name: 'set_activity_host', description: 'set_activity_host = character', supportedScopes: ['activity'], supportedTargets: ['character'], syntax: "The host of the scoped activity is set to the target character" },
  { name: 'skip_activity_phase', description: 'Skip the current activity phase, either directly to the next phase, or to completion. (fast-forwards) skip_activity_phase = yes/no.', supportedScopes: ['activity'] },
];

/**
 * Effects for artifact scope (26 effects)
 */
export const artifactEffects: EffectDefinition[] = [
  { name: 'add_artifact_history', description: 'Adds a history entry to the artifact, could for example be a reforging event', supportedScopes: ['artifact'], syntax: "type = enum - history entry type\ndate = jomini date - when this historical event took place\nactor = character - who is the actor in the event, for example who created it\nrecipient = character - who is the recipient in the event, for example who was the artifact given to\nlocation = province - where the event took place" },
  { name: 'add_artifact_modifier', description: 'Adds a static modifier to the given artifact', supportedScopes: ['artifact'], syntax: "add_artifact_modifier = modifier_name\nNOTE: does not support duration!" },
  { name: 'add_artifact_title_history', description: 'Adds the title history of the given title to the scoped artifacts history', supportedScopes: ['artifact'], syntax: "add_artifact_title_history = {}\ntarget = title scope - landed title to take history from\ndate = game date - from which date onwards to copy historical entries" },
  { name: 'add_durability', description: 'Add this much to the artifacts durability', supportedScopes: ['artifact'] },
  { name: 'clear_artifact_modifiers', description: 'Removes all modifiers from the scoped artifact', supportedScopes: ['artifact'], syntax: "clear_artifact_modifiers = yes" },
  { name: 'copy_artifact_modifiers', description: 'Copies the modifiers of the target artifact. Does *not* clear out existing modifiers', supportedScopes: ['artifact'], supportedTargets: ['artifact'], syntax: "copy_artifact_modifiers = target_artifact" },
  { name: 'equip_artifact_to_owner', description: 'Makes the owner of the scoped artifact equip it, will fail if there already is an equipment in the artifact\'s slot.', supportedScopes: ['artifact'] },
  { name: 'equip_artifact_to_owner_replace', description: 'Makes the owner of the scoped artifact equip it, will replace the first held artifact if all slots of its type are filled.', supportedScopes: ['artifact'] },
  { name: 'every_artifact_claimant', description: 'Iterate through all characters with a claim on the scoped artifact', supportedScopes: ['artifact'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_artifact_claimant = { limit = { <triggers> } <effects> }" },
  { name: 'every_artifact_house_claimant', description: 'Iterate through all dynasty houses with a claim on the scoped artifact', supportedScopes: ['artifact'], supportedTargets: ['dynasty_house'], outputScope: 'dynasty_house', isIterator: true, syntax: "every_artifact_house_claimant = { limit = { <triggers> } <effects> }" },
  { name: 'ordered_artifact_claimant', description: 'Iterate through all characters with a claim on the scoped artifact', supportedScopes: ['artifact'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_artifact_claimant = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_artifact_house_claimant', description: 'Iterate through all dynasty houses with a claim on the scoped artifact', supportedScopes: ['artifact'], supportedTargets: ['dynasty_house'], outputScope: 'dynasty_house', isIterator: true, syntax: "ordered_artifact_house_claimant = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'random_artifact_claimant', description: 'Iterate through all characters with a claim on the scoped artifact', supportedScopes: ['artifact'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_artifact_claimant = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_artifact_house_claimant', description: 'Iterate through all dynasty houses with a claim on the scoped artifact', supportedScopes: ['artifact'], supportedTargets: ['dynasty_house'], outputScope: 'dynasty_house', isIterator: true, syntax: "random_artifact_house_claimant = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'reforge_artifact', description: 'Reforges the given artifact, restoring its durability and potentially changing any other attributes such as type or modifiers unless those fields are left empty', supportedScopes: ['artifact'], syntax: "Be aware that we make use of the current scopes implicitly. This is done in common/artifacts/visuals\nname = dynamic description - artifact name\ndescription = dynamic description - artifact description\nrarity = enum - artifact rarity, ex. legendary\ntype = flag - inventory slot type, ex. trinket\nmodifier = static modifier - applied to the character whom wields this artifact\ndurability = script value - new durability, will be max by default\nmax_durability = script value - Optional. A value for the max durability, which would override the one normally assigned by the defines\ndecaying = yes/no - Optional. Set if artifact decays with time. Yes by default\nhistory = artifact history entry - custom history entry to denote for example that this is artifact was reforged by someone else than the owner\ntype = artifact history entry type - available types:\ncreated_before_history\ncreated\nprize_created\ndiscovered\ncreator_discovered\nclaimed_by_house\ngiven\nstolen\ninherited\nconquest\ntaken_in_siege\ntaken_in_battle\nwon_in_duel\npurchased\nprize_awarded\nransomed\nreforged\ntemplate = artifact scripted template - a scripted base template with triggers and modifiers\nvisuals = artifact visual type - how this artifact should appear visually\ngenerate_history = bool - automatically generate a new history entry if none has been scripted?\nquality = script value - new quality, used in AI scoring\nwealth = script value - new wealth, used in AI scoring\ncreator = character scope - set a custom creator of the artifact ( default is the owner )\nvisuals_source = scope containing landed title, dynasty or house - set a source of coat of arms graphics for the artifact\n(only few artifact models actually make use of it. Most notable - banners)" },
  { name: 'remove_artifact_feature_group', description: 'Removes th feature from the specified group from the artifact.', supportedScopes: ['artifact'], syntax: "Cannot remove required groups.\nremove_artifact_feature_group = key" },
  { name: 'remove_artifact_modifier', description: 'Removes a static modifier to the given artifact', supportedScopes: ['artifact'], syntax: "remove_artifact_modifier = modifier_name\nNOTE: does not support duration!" },
  { name: 'set_artifact_description', description: 'Sets the description of the given artifact', supportedScopes: ['artifact'], syntax: "set_artifact_description = dynamic desc" },
  { name: 'set_artifact_feature', description: 'Sets the specified feature on the artifact.', supportedScopes: ['artifact'], syntax: "If there's already a feature of that group, it gets overridden.\nset_artifact_feature = key" },
  { name: 'set_artifact_feature_group', description: 'Sets a feature from the specified group on the artifact.', supportedScopes: ['artifact'], syntax: "Uses the current scopes. Uses the weighting from the group.\nIf there's already a feature of that group, it gets overridden.\nset_artifact_feature_group = key" },
  { name: 'set_artifact_name', description: 'Sets the name of the given artifact', supportedScopes: ['artifact'], syntax: "set_artifact_name = dynamic name" },
  { name: 'set_artifact_rarity', description: 'Sets the rarity of the scoped artifact. Note that this does not update graphics and the like', supportedScopes: ['artifact'], syntax: "set_artifact_rarity = common" },
  { name: 'set_max_durability', description: 'Sets the artifact\'s max durability', supportedScopes: ['artifact'] },
  { name: 'set_owner', description: 'Change the artifacts owner and transfer it to the given character', supportedScopes: ['artifact'], syntax: "set_artifact_owner = {}\ntarget = character scope - the new owner character\nhistory = artifact history entry - custom history entry to denote for example that this is artifact was stolen rather than given\ngenerate_history = bool - automatically generate a new history entry if none has been scripted?" },
  { name: 'set_should_decay', description: 'Set if the scoped artifact should decay with time or not', supportedScopes: ['artifact'], syntax: "set_should_decay = yes/no" },
  { name: 'unequip_artifact_from_owner', description: 'Makes the owner of the scoped artifact unequip it.', supportedScopes: ['artifact'] },
];

/**
 * Effects for none scope (216 effects)
 */
export const generalEffects: EffectDefinition[] = [
  { name: 'add_diplomacy_skill', description: 'Adds diplomacy skill', supportedScopes: ['none'] },
  { name: 'add_focus_progress', description: 'Adds focus progress', supportedScopes: ['none'] },
  { name: 'add_internal_flag', description: 'adds effect to be read internally (no effect in the gamestate)', supportedScopes: ['none'] },
  { name: 'add_intrigue_skill', description: 'Adds intrigue skill', supportedScopes: ['none'] },
  { name: 'add_learning_skill', description: 'Adds learning skill', supportedScopes: ['none'] },
  { name: 'add_martial_skill', description: 'Adds martial skill', supportedScopes: ['none'] },
  { name: 'add_prowess_skill', description: 'Adds prowess skill', supportedScopes: ['none'] },
  { name: 'add_stewardship_skill', description: 'Adds stewardship skill', supportedScopes: ['none'] },
  { name: 'add_title_law', description: 'add law to scoped title, overriding any current law from the same group. DOES NOT apply law change costs and effects.', supportedScopes: ['none'], syntax: "add_title_law = princely_elective_succession_law" },
  { name: 'add_title_law_effects', description: 'add law to scoped title, overriding any current law from the same group. DOES apply law change costs and effects.', supportedScopes: ['none'], syntax: "add_title_law = princely_elective_succession_law" },
  { name: 'add_to_global_variable_list', description: 'Adds the event target to a variable list', supportedScopes: ['none'], syntax: "add_to_variable_list = { name = X target = Y }\nWhere X is the name of the variable\nWhere Y is an event target" },
  { name: 'add_to_list', description: 'Adds the current scope to an arbitrarily-named list (or creates the list if not already present) to be referenced later in the (unbroken) event chain', supportedScopes: ['none'], syntax: "add_to_list = <string> NOTE, if adding a permanent target to a temporary list, the whole list becomes permanent" },
  { name: 'add_to_local_variable_list', description: 'Adds the event target to a variable list', supportedScopes: ['none'], syntax: "add_to_variable_list = { name = X target = Y }\nWhere X is the name of the variable\nWhere Y is an event target" },
  { name: 'add_to_temporary_list', description: 'Adds the current scope to an arbitrarily-named list (or creates the list if not already present) to be referenced later in the same effect', supportedScopes: ['none'], syntax: "add_to_temporary_list = <string> NOTE, if adding a temporary target to a permanent list, the list will stay permanent" },
  { name: 'add_to_variable_list', description: 'Adds the event target to a variable list', supportedScopes: ['none'], syntax: "add_to_variable_list = { name = X target = Y }\nWhere X is the name of the variable\nWhere Y is an event target" },
  { name: 'assert_if', description: 'Conditionally cause an assert during run time', supportedScopes: ['none'], syntax: "assert_if = { limit = { X } text = Y }, where X is a trigger and Y is an optional string" },
  { name: 'assert_read', description: 'Conditionally cause an assert during read time', supportedScopes: ['none'], syntax: "assert_read = X, where X is yes or the string to be printed in the assert" },
  { name: 'break_betrothal', description: 'Breaks the betrothal between the scope character to the target character, break_betrothal = target', supportedScopes: ['none'], supportedTargets: ['character'] },
  { name: 'change_global_variable', description: 'Changes the value or a numeric variable', supportedScopes: ['none'], syntax: "change_variable = { name = X operation = Y }\nWhere X is the name of the numeric variable to modify\nWhere the valid operations are add, subtract, multiply, divide, modulo, min and max\nWhere Y is a fixed point value, script value or event target of a value type" },
  { name: 'change_local_variable', description: 'Changes the value or a numeric variable', supportedScopes: ['none'], syntax: "change_variable = { name = X operation = Y }\nWhere X is the name of the numeric variable to modify\nWhere the valid operations are add, subtract, multiply, divide, modulo, min and max\nWhere Y is a fixed point value, script value or event target of a value type" },
  { name: 'change_title_holder', description: '= {', supportedScopes: ['none'], syntax: "holder = 'Character that should get the title'\nchange = 'previously created title_and_vassal_change', adds a title change, will not transfer vassalstake_baronies = yes # Optional; if set, will cause baronies to be taken (rather than vassalized) as well if this title is a countygovernment_base = character # Optional, if the character getting the title was unlanded, their new government will be based on the government of government_base. If no government_base is specified, the government will be based on holder's government." },
  { name: 'change_title_holder_include_vassals', description: '= {', supportedScopes: ['none'], syntax: "holder = 'Character that should get the title'\nchange = 'previously created title_and_vassal_change', adds a title change, will transfer vassalstake_baronies = yes # Optional; if set, will cause baronies to be taken (rather than vassalized) as well if this title is a countygovernment_base = character # Optional, if the character getting the title was unlanded, their new government will be based on the government of government_base. If no government_base is specified, the government will be based on holder's government." },
  { name: 'change_variable', description: 'Changes the value or a numeric variable', supportedScopes: ['none'], syntax: "change_variable = { name = X operation = Y }\nWhere X is the name of the numeric variable to modify\nWhere the valid operations are add, subtract, multiply, divide, modulo, min and max\nWhere Y is a fixed point value, script value or event target of a value type" },
  { name: 'clamp_global_variable', description: 'Clamps a variable the specified max and min', supportedScopes: ['none'], syntax: "clamp_variable = { name = X max = Y min = Z }\nWhere X is the name of the variable\nWhere Y and Z are script values" },
  { name: 'clamp_local_variable', description: 'Clamps a variable the specified max and min', supportedScopes: ['none'], syntax: "clamp_variable = { name = X max = Y min = Z }\nWhere X is the name of the variable\nWhere Y and Z are script values" },
  { name: 'clamp_variable', description: 'Clamps a variable the specified max and min', supportedScopes: ['none'], syntax: "clamp_variable = { name = X max = Y min = Z }\nWhere X is the name of the variable\nWhere Y and Z are script values" },
  { name: 'clear_global_variable_list', description: 'Empties the list', supportedScopes: ['none'], syntax: "clear_variable_list = variable_name" },
  { name: 'clear_local_variable_list', description: 'Empties the list', supportedScopes: ['none'], syntax: "clear_variable_list = variable_name" },
  { name: 'clear_saved_scope', description: 'Clears a saved scope from the top scope', supportedScopes: ['none'], syntax: "save_scope_as = cool_scope -> clear_saved_scope = cool_scope" },
  { name: 'clear_traits', description: 'Removes all traits for the character. clear_traits = yes', supportedScopes: ['none'] },
  { name: 'clear_variable_list', description: 'Empties the list', supportedScopes: ['none'], syntax: "clear_variable_list = variable_name" },
  { name: 'close_all_views', description: 'Closes all views. close_all_views = yes', supportedScopes: ['none'] },
  { name: 'close_view', description: 'Tries to close the defined view.', supportedScopes: ['none'], syntax: "Take care to set player if effect is executed not through UI but through synchronized code. Else all the window will open for all players.\nclose_view = {\nview = <view name>\nplayer = scope:character # optional, else closes for all players who execute the effect\n}simplified: close_view = <view name>" },
  { name: 'copy_traits', description: 'Adds all traits of the target to the character. Skips any traits that the character isn\'t allowed to have. Will not remove the character\'s existing traits. copy_traits = scope:character', supportedScopes: ['none'], supportedTargets: ['character'] },
  { name: 'create_accolade', description: 'Create an accolade for the scoped character with the given knight and types. The name is an optional loc key, a default name will be generated otherwise.', supportedScopes: ['none'], syntax: "create_accolade = { knight = scope:character primary = accolade_type secondary = accolade_type name = loc_key }" },
  { name: 'create_betrothal', description: 'Betroth the scope character to the target character, create_betrothal = target (at least one of the characters need to not be adult)', supportedScopes: ['none'], supportedTargets: ['character'] },
  { name: 'create_betrothal_matrilineal', description: 'Betroth the scope character to the target character matrilineally, create_betrothal_matrilineal = target (at least one of the characters need to not be adult)', supportedScopes: ['none'], supportedTargets: ['character'] },
  { name: 'create_character', description: 'Creates a character', supportedScopes: ['none'], syntax: "save_event_target_as = flag - save the character as an event target\nsave_temporary_event_target_as = flag - save the character as a temporary event target\nname =\nage =\ngender = male/female/character scope\ngender_female_chance = script_value - Range (0..100)\nopposite_gender = character scope\ntrait = add this trait\nrandom_traits_list = { count = { 1 5 } traitID = { some triggers } traitID = { some triggers } } - A number of traits specified by count (1 if not specified) will be picked from the traits that have their triggers met. Scopes are the same as where create_character is used. More than one grouping like this can be defined\nrandom_traits = yes/no\nhealth =\nfertility =\nmother =\nfather =\nreal_father = (should only be set if the real father is not the same as father=)\nemployer = will end up in this court, will become a pool character unless specified or father/mother is landed\nlocation = pool province; mutually exclusive with employer\ntemplate_character =\nfaith, culture and dynasty are set from 1. template_character 2. father 3. mother 4. employer (not employer for dynasty) unless specified directly\nfaith = faith tag OR a faith scope\nrandom_faith = { catholic = { some triggers } cathar = { some triggers }. Random one where the triggers are met will be picked. Scopes are the same as where create_character is used\nrandom_faith_in_religion = religion tag OR a faith scope (there's no religion scope)\nculture = culture name OR a culture scope\nrandom_culture = { norse = { some triggers } norwegian = { some triggers }. Random one where the triggers are met will be picked. Scopes are the same as where create_character is used\nrandom_culture_in_group = culture group name OR a culture scope (there's no group scope)\ndynasty_house = dynasty house name OR a dynasty house scope\ndynasty = generate/inherit/none - What to do if dynasty_house is not specified. generate by default.\nmartial/diplomacy/intrigue...  =  will get random unless specified\nafter_creation = { some effects } run after character is created. Scope starts off in the character, with the scope it was created in as PREV, and the same top scope and saved targets etc." },
  { name: 'create_dynamic_title', description: 'Creates a dynamic title', supportedScopes: ['none'], syntax: "The title will be saved to scope:new_titleusage:\ncreate_dynamic_title = {\ntier = <tier>\nname = key/dynamic description\tadjective = key/dynamic description (optional; name used if not specified)}" },
  { name: 'create_holy_order', description: 'Create a new holy order', supportedScopes: ['none'], syntax: "create_holy_order = {\nleader = scope:a_character\ncapital = scope:a_barony_title\nsave_scope_as/save_temporary_scope_as = new_holy_order # optional way to get a reference to the new holy order\n}" },
  { name: 'create_title_and_vassal_change', description: 'starts a title and vassal change and saves it as a temporary event target', supportedScopes: ['none'], syntax: "create_title_and_vassal_change = {\ntype = conquest (or other type)\nsave_scope_as = change (name of resulting saved scope)\nadd_claim_on_loss = yes (optional)\n}" },
  { name: 'custom_description', description: 'Wraps effects that get a custom description instead of the auto-generated one', supportedScopes: ['none'], syntax: "custom_description = {\ntext = <effect_localization_key>\nsubject = <optional subject scope> #defaults to current scope\nobject = <optional object scope>\nvalue = <optional script value>\n... effects ...\n}" },
  { name: 'custom_description_no_bullet', description: 'Wraps effects that get a custom description instead of the auto-generated one. Also ensures no bullet point appears', supportedScopes: ['none'], syntax: "custom_description_no_bullet = {\ntext = <effect_localization_key>\nsubject = <optional subject scope> #defaults to current scope\nobject = <optional object scope>\nvalue = <optional script value>\n... effects ...\n}" },
  { name: 'custom_label', description: 'just a tooltip, the scope as object (for grouping, localization). Can also be written as custom_label = { text = key subject = scope (optional) <hidden effects> }', supportedScopes: ['none'] },
  { name: 'custom_tooltip', description: 'just a tooltip, the scope as subject (for grouping, localization). Can also be written as custom_tooltip = { text = key subject = scope (optional) <hidden effects> }', supportedScopes: ['none'] },
  { name: 'debug_log', description: 'Log a string to the debug log when this effect executes, debug_log = message, the message can be a localization string with ROOT, SCOPE and PREV available', supportedScopes: ['none'] },
  { name: 'debug_log_date', description: 'Logs the current date to the debug.log', supportedScopes: ['none'] },
  { name: 'debug_log_scopes', description: 'Log the current scope to the debug log when this effect executes yes = full scope info, no=only current scope', supportedScopes: ['none'] },
  { name: 'debug_trigger_event', description: 'Like trigger_event, except it\'ll print the trigger fulfillment and immediate effects of the event too', supportedScopes: ['none'] },
  { name: 'destroy_artifact', description: 'Destroy given artifact, regardless of owner.', supportedScopes: ['none'], supportedTargets: ['artifact'], syntax: "destroy_artifact = artifact" },
  { name: 'destroy_character_memory', description: 'destroy_character_memory = character_memory', supportedScopes: ['none'], supportedTargets: ['character_memory'], syntax: "Destroys the targeted character memory, do not use the destroyed scope after calling this since it will have been removed" },
  { name: 'destroy_inspiration', description: 'destroy_inspiration = inspiration', supportedScopes: ['none'], supportedTargets: ['inspiration'], syntax: "Destroys the targeted inspiration, do not use the destroyed scope after calling this since it will have been removed" },
  { name: 'destroy_owned_artifact', description: 'Destroy artifact owned by character. Safer version of \'destroy_artifact\'.', supportedScopes: ['none'], supportedTargets: ['artifact'], syntax: "destroy_owned_artifact = artifact" },
  { name: 'divorce', description: 'Divorces the scope character from the target character. divorce = target', supportedScopes: ['none'], supportedTargets: ['character'] },
  { name: 'duel', description: 'duel effect that selects an effect based on comparing specified skill(s) of a character to a value or another character\'s skill(s). Alternatively, the compare value can be scripted completely', supportedScopes: ['none'], syntax: "duel = {\nskill = X\n(skills = { X1 X2 ... })    target = Y\nvalue = Z\nlocalization = W\n... random list body\n}\nWhere X is the skill to compare, or the list of skills listed; Y is the target character (requires skill(s) to be set) or integer value Z (works with or without the skill), the rest of the effect is the same as random_list.\nIf the skill(s) are unspecified, the effect needs a value Z (which can use scripted math) which it will then use as the duel value directly.\nIf localization = W is specified, the effect localization W will be used (entry in effect_localization database, not a localization key directly).\nWhen multiple skills are specified, they are added together and the average is taken.\nThe skill difference (or scripted duel value) is available as scope:duel_value inside the outcome entries, the duel target is accessible as scope:duel_target.\nThe three valid types of combinations are: skill(s) + target / skill(s) + value / only value\nSince there is now no automatic weighting, we should be using weight numbers in a comparable range to the scope:duel_value value. Since that will always be between -20 and 20 (unless you do something very unusual), and typically in a more narrow range than that, we should stick to those ranges.\nOnly use larger weights if you want the duel_value to have a smaller impact on the weighting, and only use smaller weights if you want the duel_value to have a huge impact on the weighting.\nIn addition, it is fully possible for the compare_modifier to reduce the weight to 0, which would mean that it will not be possible to happen at all. I've requested code support to make it so that we can define min and max values for weights, but until further notice we should use ranges that are guaranteed to not hit 0, or include min values in the compare_modifier itself.\nLastly, remember that if you want the outcome of a duel to scale linearly from (almost) 0% to (almost) 100%, the duel_value should be applied 50% to the good outcome, and -50% to the bad outcome. If you only apply it on one side, you will retain a (presumably significant) chunk of chance for the other outcome." },
  { name: 'else', description: 'Executes enclosed effects if limit criteria of preceding \'if\' or \'else_if\' is not met', supportedScopes: ['none'], syntax: "if = { limit = { <triggers> } <effects> }\nelse = { <effects> }" },
  { name: 'else_if', description: 'Executes enclosed effects if limit criteria of preceding \'if\' or \'else_if\' is not met, and its own limit is met', supportedScopes: ['none'], syntax: "if = { limit = { <triggers> } <effects> }\nelse_if = { limit = { <triggers> } <effects> }" },
  { name: 'end_inspiration_sponsorship', description: 'end_inspiration_sponsorship = inspiration', supportedScopes: ['none'], supportedTargets: ['inspiration'], syntax: "Stops the sponsorship of the targeted inspiration" },
  { name: 'error_log', description: 'Log a string to the error log when this effect executes, error_log = message, the message can be a localization string with ROOT, SCOPE and PREV available', supportedScopes: ['none'] },
  { name: 'every_accolade_type', description: 'ï¿½ï¿½=ï¿½,', supportedScopes: ['none'], supportedTargets: ['accolade_type'], outputScope: 'accolade_type', isIterator: true },
  { name: 'every_activity', description: 'Iterate through all activities in the world', supportedScopes: ['none'], supportedTargets: ['activity'], outputScope: 'activity', isIterator: true, syntax: "every_activity = { limit = { <triggers> } <effects> }" },
  { name: 'every_activity_type', description: 'IÌ«,', supportedScopes: ['none'], supportedTargets: ['activity_type'], outputScope: 'activity_type', isIterator: true },
  { name: 'every_artifact', description: 'Iterate through all existing artifacts', supportedScopes: ['none'], supportedTargets: ['artifact'], outputScope: 'artifact', isIterator: true, syntax: "every_artifact = { limit = { <triggers> } <effects> }" },
  { name: 'every_barony', description: 'Iterate through all baronies in the game', supportedScopes: ['none'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_barony = { limit = { <triggers> } <effects> }" },
  { name: 'every_character_with_royal_court', description: 'Iterate through all characters with a royal court', supportedScopes: ['none'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_character_with_royal_court = { limit = { <triggers> } <effects> }" },
  { name: 'every_county', description: 'Iterate through all counties in the game', supportedScopes: ['none'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_county = { limit = { <triggers> } <effects> }" },
  { name: 'every_county_in_region', description: 'Iterate through all counties in the region. Put \'region = region_name\' inside it', supportedScopes: ['none'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_county_in_region = { limit = { <triggers> } <effects> }" },
  { name: 'every_culture_global', description: 'Iterate through all cultures in the game', supportedScopes: ['none'], supportedTargets: ['culture'], outputScope: 'culture', isIterator: true, syntax: "every_culture_global = { limit = { <triggers> } <effects> }" },
  { name: 'every_culture_pillar', description: 'ï¿½ï¿½ï¿½,', supportedScopes: ['none'], supportedTargets: ['culture_pillar'], outputScope: 'culture_pillar', isIterator: true },
  { name: 'every_culture_tradition', description: 'ï¿½ï¿½ï¿½', supportedScopes: ['none'], supportedTargets: ['culture_tradition'], outputScope: 'culture_tradition', isIterator: true },
  { name: 'every_decision', description: '(Eï¿½ï¿½ï¿½', supportedScopes: ['none'], supportedTargets: ['decision'], outputScope: 'decision', isIterator: true },
  { name: 'every_doctrine', description: '`Bï¿½ï¿½ï¿½', supportedScopes: ['none'], supportedTargets: ['doctrine'], outputScope: 'doctrine', isIterator: true },
  { name: 'every_duchy', description: 'Iterate through all duchies in the game', supportedScopes: ['none'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_duchy = { limit = { <triggers> } <effects> }" },
  { name: 'every_empire', description: 'Iterate through all empires in the game', supportedScopes: ['none'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_empire = { limit = { <triggers> } <effects> }" },
  { name: 'every_government_type', description: 'ï¿½ï¿½ï¿½', supportedScopes: ['none'], supportedTargets: ['government_type'], outputScope: 'government_type', isIterator: true },
  { name: 'every_in_global_list', description: 'Iterate through all items in global list. list = name or variable = name', supportedScopes: ['none'], isIterator: true, syntax: "every_in_global_list = { limit = { <triggers> } <effects> }" },
  { name: 'every_in_list', description: 'Iterate through all items in list. list = name or variable = name', supportedScopes: ['none'], isIterator: true, syntax: "every_in_list = { limit = { <triggers> } <effects> }" },
  { name: 'every_in_local_list', description: 'Iterate through all items in local list. list = name or variable = name', supportedScopes: ['none'], isIterator: true, syntax: "every_in_local_list = { limit = { <triggers> } <effects> }" },
  { name: 'every_independent_ruler', description: 'Independent rulers list with a COUNT tier or above who hold land', supportedScopes: ['none'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_independent_ruler = { limit = { <triggers> } <effects> }" },
  { name: 'every_inspiration', description: 'Iterate through all inspirations in the world', supportedScopes: ['none'], supportedTargets: ['inspiration'], outputScope: 'inspiration', isIterator: true, syntax: "every_inspiration = { limit = { <triggers> } <effects> }" },
  { name: 'every_inspired_character', description: 'Iterate through all characters with an inspirations in the world', supportedScopes: ['none'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_inspired_character = { limit = { <triggers> } <effects> }" },
  { name: 'every_kingdom', description: 'Iterate through all kingdoms in the game', supportedScopes: ['none'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_kingdom = { limit = { <triggers> } <effects> }" },
  { name: 'every_living_character', description: 'Iterate through all living characters', supportedScopes: ['none'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_living_character = { limit = { <triggers> } <effects> }" },
  { name: 'every_mercenary_company', description: 'Iterate through all mercenary companies', supportedScopes: ['none'], supportedTargets: ['mercenary_company'], outputScope: 'mercenary_company', isIterator: true, syntax: "every_mercenary_company = { limit = { <triggers> } <effects> }" },
  { name: 'every_open_invite_activity', description: 'Iterate through all open invite activities in the world', supportedScopes: ['none'], supportedTargets: ['activity'], outputScope: 'activity', isIterator: true, syntax: "every_open_invite_activity = { limit = { <triggers> } <effects> }" },
  { name: 'every_player', description: 'Iterate through all player characters', supportedScopes: ['none'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_player = { limit = { <triggers> } <effects> }" },
  { name: 'every_pool_character', description: 'Iterate through all characters in the pool of the given province', supportedScopes: ['none'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_pool_character = { limit = { <triggers> } <effects> }" },
  { name: 'every_province', description: 'Iterate through all provinces (skips non-land and impassable provinces)', supportedScopes: ['none'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, syntax: "every_province = { limit = { <triggers> } <effects> }" },
  { name: 'every_religion_global', description: 'Iterate through all religions in the game', supportedScopes: ['none'], supportedTargets: ['religion'], outputScope: 'religion', isIterator: true, syntax: "every_religion_global = { limit = { <triggers> } <effects> }" },
  { name: 'every_ruler', description: 'Rulers list with a COUNT tier o above', supportedScopes: ['none'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_ruler = { limit = { <triggers> } <effects> }" },
  { name: 'every_special_building_province', description: 'Iterate through all provinces with a special building slot (built or un-built)', supportedScopes: ['none'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, syntax: "every_special_building_province = { limit = { <triggers> } <effects> }" },
  { name: 'every_trait', description: '(Eï¿½ï¿½ï¿½', supportedScopes: ['none'], supportedTargets: ['trait'], outputScope: 'trait', isIterator: true },
  { name: 'every_trait_in_category', description: 'Iterate through all traits in a given category', supportedScopes: ['none'], supportedTargets: ['trait'], outputScope: 'trait', isIterator: true, syntax: "any_trait_in_category = { category = fame/health/etc }\nevery_trait_in_category = { limit = { <triggers> } <effects> }" },
  { name: 'every_vassal_contract', description: 'ï¿½ï¿½ï¿½', supportedScopes: ['none'], supportedTargets: ['vassal_contract'], outputScope: 'vassal_contract', isIterator: true },
  { name: 'hidden_effect', description: 'Effect not shown in tooltips', supportedScopes: ['none'] },
  { name: 'hidden_effect_new_object', description: 'Suppress errors for effects using to-be created objects (like artifacts or characters) in tooltips. The effects inside are hidden from the tooltip, with no description generated whatsoever!', supportedScopes: ['none'] },
  { name: 'if', description: 'Executes enclosed effects if limit criteria are met', supportedScopes: ['none'], syntax: "if = { limit = { <triggers> } <effects> }" },
  { name: 'invalidate_activity', description: 'Invalidate and destroy the target activity, running its on_invalidate effect', supportedScopes: ['none'], supportedTargets: ['activity'], syntax: "invalidate_activity = scope:activity" },
  { name: 'multiply_focus_progress', description: 'Multiplies focus progress', supportedScopes: ['none'] },
  { name: 'open_interaction_window', description: 'Tries to open the defined view.', supportedScopes: ['none'], syntax: "interaction = interaction_key - the interaction object key to open\nredirect = [yes|no] - yes by default, redirect the actor and recipients ( only works if secondary_actor and secondary_recipient are not setup or are invalid)\nactor = character_actor - must be defined, must coincide with the current player\nrecipient = character_actor - must be defined\nsecondary_actor = character_secondary_actor - optional\nsecondary_recipient = character_secondary_recipient - optional\ntarget_title = title - optional" },
  { name: 'open_view', description: 'Tries to open the defined view without scope data.', supportedScopes: ['none'], syntax: "Take care to set player if effect is executed not through UI but through synchronized code. Else all the window will open for all players.\nopen_view = {\nview = <view name>\nview_message = <view specific instruction> # optional\nplayer = scope:character # optional, else shows for all players who execute the effect\n}simplified: open_view = <view name>" },
  { name: 'open_view_data', description: 'Tries to open the defined view with scope data.', supportedScopes: ['none'], syntax: "Take care to set player if effect is executed not through UI but through synchronized code. Else all the window will open for all players.\nopen_view_data = {\nview = <view name>\nview_message = <view specific instruction> # optional\nplayer = scope:character # optional, else shows for all players who execute the effect\n}\nsimplified: open_view_data = <view name>\nfor example: scope:faith = { open_view_data = faith_conversion }" },
  { name: 'ordered_accolade_type', description: 'ï¿½Bï¿½,', supportedScopes: ['none'], supportedTargets: ['accolade_type'], outputScope: 'accolade_type', isIterator: true },
  { name: 'ordered_activity', description: 'Iterate through all activities in the world', supportedScopes: ['none'], supportedTargets: ['activity'], outputScope: 'activity', isIterator: true, syntax: "ordered_activity = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_activity_type', description: 'VS_OUTPUT_FULLSCREEN FullscreenVertexShader( VS_INPUT_FULLSCREEN Input )', supportedScopes: ['none'], supportedTargets: ['activity_type'], outputScope: 'activity_type', isIterator: true, syntax: "{\nVS_OUTPUT_FULLSCREEN VertexOut;\nVertexOut.position = float4( Input.position, 0.0, 1.0 );\nVertexOut.uv = Input.position.xy * 0.5 + 0.5;\nVertexOut.uv.y = 1.0 - VertexOut.uv.y;\nreturn VertexOut;\n}" },
  { name: 'ordered_artifact', description: 'Iterate through all existing artifacts', supportedScopes: ['none'], supportedTargets: ['artifact'], outputScope: 'artifact', isIterator: true, syntax: "ordered_artifact = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_barony', description: 'Iterate through all baronies in the game', supportedScopes: ['none'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_barony = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_character_with_royal_court', description: 'Iterate through all characters with a royal court', supportedScopes: ['none'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_character_with_royal_court = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_county', description: 'Iterate through all counties in the game', supportedScopes: ['none'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_county = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_county_in_region', description: 'Iterate through all counties in the region. Put \'region = region_name\' inside it', supportedScopes: ['none'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_county_in_region = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_culture_global', description: 'Iterate through all cultures in the game', supportedScopes: ['none'], supportedTargets: ['culture'], outputScope: 'culture', isIterator: true, syntax: "ordered_culture_global = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_culture_pillar', description: 'ï¿½ï¿½,', supportedScopes: ['none'], supportedTargets: ['culture_pillar'], outputScope: 'culture_pillar', isIterator: true },
  { name: 'ordered_culture_tradition', description: 'ï¿½Mï¿½ï¿½ï¿½', supportedScopes: ['none'], supportedTargets: ['culture_tradition'], outputScope: 'culture_tradition', isIterator: true },
  { name: 'ordered_decision', description: 'ï¿½ï¿½ï¿½=ï¿½', supportedScopes: ['none'], supportedTargets: ['decision'], outputScope: 'decision', isIterator: true },
  { name: 'ordered_doctrine', description: 'ï¿½ï¿½ï¿½=ï¿½', supportedScopes: ['none'], supportedTargets: ['doctrine'], outputScope: 'doctrine', isIterator: true },
  { name: 'ordered_duchy', description: 'Iterate through all duchies in the game', supportedScopes: ['none'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_duchy = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_empire', description: 'Iterate through all empires in the game', supportedScopes: ['none'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_empire = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_government_type', description: 'BlendState', supportedScopes: ['none'], supportedTargets: ['government_type'], outputScope: 'government_type', isIterator: true },
  { name: 'ordered_in_global_list', description: 'Iterate through all items in global list. list = name or variable = name', supportedScopes: ['none'], isIterator: true, syntax: "ordered_in_global_list = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_in_list', description: 'Iterate through all items in list. list = name or variable = name', supportedScopes: ['none'], isIterator: true, syntax: "ordered_in_list = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_in_local_list', description: 'Iterate through all items in local list. list = name or variable = name', supportedScopes: ['none'], isIterator: true, syntax: "ordered_in_local_list = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_independent_ruler', description: 'Independent rulers list with a COUNT tier or above who hold land', supportedScopes: ['none'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_independent_ruler = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_inspiration', description: 'Iterate through all inspirations in the world', supportedScopes: ['none'], supportedTargets: ['inspiration'], outputScope: 'inspiration', isIterator: true, syntax: "ordered_inspiration = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_inspired_character', description: 'Iterate through all characters with an inspirations in the world', supportedScopes: ['none'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_inspired_character = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_kingdom', description: 'Iterate through all kingdoms in the game', supportedScopes: ['none'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_kingdom = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_living_character', description: 'Iterate through all living characters', supportedScopes: ['none'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_living_character = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_mercenary_company', description: 'Iterate through all mercenary companies', supportedScopes: ['none'], supportedTargets: ['mercenary_company'], outputScope: 'mercenary_company', isIterator: true, syntax: "ordered_mercenary_company = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_open_invite_activity', description: 'Iterate through all open invite activities in the world', supportedScopes: ['none'], supportedTargets: ['activity'], outputScope: 'activity', isIterator: true, syntax: "ordered_open_invite_activity = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_player', description: 'Iterate through all player characters', supportedScopes: ['none'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_player = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_pool_character', description: 'Iterate through all characters in the pool of the given province', supportedScopes: ['none'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_pool_character = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_province', description: 'Iterate through all provinces (skips non-land and impassable provinces)', supportedScopes: ['none'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, syntax: "ordered_province = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_religion_global', description: 'Iterate through all religions in the game', supportedScopes: ['none'], supportedTargets: ['religion'], outputScope: 'religion', isIterator: true, syntax: "ordered_religion_global = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_ruler', description: 'Rulers list with a COUNT tier o above', supportedScopes: ['none'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_ruler = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_special_building_province', description: 'Iterate through all provinces with a special building slot (built or un-built)', supportedScopes: ['none'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, syntax: "ordered_special_building_province = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_trait', description: 'ï¿½ï¿½ï¿½=ï¿½', supportedScopes: ['none'], supportedTargets: ['trait'], outputScope: 'trait', isIterator: true },
  { name: 'ordered_trait_in_category', description: 'Iterate through all traits in a given category', supportedScopes: ['none'], supportedTargets: ['trait'], outputScope: 'trait', isIterator: true, syntax: "any_trait_in_category = { category = fame/health/etc }\nordered_trait_in_category = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }" },
  { name: 'ordered_vassal_contract', description: 'pï¿½Bï¿½,', supportedScopes: ['none'], supportedTargets: ['vassal_contract'], outputScope: 'vassal_contract', isIterator: true },
  { name: 'pan_camera_to_province', description: 'Pans the camera to the specified province', supportedScopes: ['none'], supportedTargets: ['province'], syntax: "pan_camera_to_province = scope:army.location" },
  { name: 'pan_camera_to_title', description: 'Pans the camera to the specified title', supportedScopes: ['none'], supportedTargets: ['landed_title'], syntax: "pan_camera_to_title = capital_barony" },
  { name: 'random', description: 'a random effect, random = { chance = X modifier = Y effects... }', supportedScopes: ['none'], syntax: "where X is a chance of the enclosed effects being fired and can be modified by optional value modifier list (AKA MTTH) Y" },
  { name: 'random_accolade_type', description: 'ï¿½ï¿½ï¿½', supportedScopes: ['none'], supportedTargets: ['accolade_type'], outputScope: 'accolade_type', isIterator: true },
  { name: 'random_activity', description: 'Iterate through all activities in the world', supportedScopes: ['none'], supportedTargets: ['activity'], outputScope: 'activity', isIterator: true, syntax: "random_activity = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_activity_type', description: 'ï¿½ï¿½ï¿½', supportedScopes: ['none'], supportedTargets: ['activity_type'], outputScope: 'activity_type', isIterator: true },
  { name: 'random_artifact', description: 'Iterate through all existing artifacts', supportedScopes: ['none'], supportedTargets: ['artifact'], outputScope: 'artifact', isIterator: true, syntax: "random_artifact = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_barony', description: 'Iterate through all baronies in the game', supportedScopes: ['none'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_barony = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_character_with_royal_court', description: 'Iterate through all characters with a royal court', supportedScopes: ['none'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_character_with_royal_court = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_county', description: 'Iterate through all counties in the game', supportedScopes: ['none'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_county_in_region', description: 'Iterate through all counties in the region. Put \'region = region_name\' inside it', supportedScopes: ['none'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_county_in_region = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_culture_global', description: 'Iterate through all cultures in the game', supportedScopes: ['none'], supportedTargets: ['culture'], outputScope: 'culture', isIterator: true, syntax: "random_culture_global = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_culture_pillar', description: 'ï¿½ï¿½ï¿½', supportedScopes: ['none'], supportedTargets: ['culture_pillar'], outputScope: 'culture_pillar', isIterator: true },
  { name: 'random_culture_tradition', description: '[2023-10-12 16:38:53.498] [Clausewitz Debug] [debug] [pdx_gui_assetfactory.cpp:684] [LoadAssetsGUI] Loading of "gui/preload/textformatting.gui" is complete', supportedScopes: ['none'], supportedTargets: ['culture_tradition'], outputScope: 'culture_tradition', isIterator: true },
  { name: 'random_decision', description: 'ï¿½ï¿½ï¿½', supportedScopes: ['none'], supportedTargets: ['decision'], outputScope: 'decision', isIterator: true },
  { name: 'random_doctrine', description: 'ï¿½ï¿½ï¿½', supportedScopes: ['none'], supportedTargets: ['doctrine'], outputScope: 'doctrine', isIterator: true },
  { name: 'random_duchy', description: 'Iterate through all duchies in the game', supportedScopes: ['none'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_duchy = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_empire', description: 'Iterate through all empires in the game', supportedScopes: ['none'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_empire = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_government_type', description: '[2023-10-12 16:38:54.883] [Clausewitz Debug] [debug] [pdx_gui_assetfactory.cpp:675] [LoadAssetsGUI] Loading "gui/tool_property_ranged_types.gui"', supportedScopes: ['none'], supportedTargets: ['government_type'], outputScope: 'government_type', isIterator: true },
  { name: 'random_in_global_list', description: 'Iterate through all items in global list. list = name or variable = name', supportedScopes: ['none'], isIterator: true, syntax: "random_in_global_list = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_in_list', description: 'Iterate through all items in list. list = name or variable = name', supportedScopes: ['none'], isIterator: true, syntax: "random_in_list = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_in_local_list', description: 'Iterate through all items in local list. list = name or variable = name', supportedScopes: ['none'], isIterator: true, syntax: "random_in_local_list = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_independent_ruler', description: 'Independent rulers list with a COUNT tier or above who hold land', supportedScopes: ['none'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_independent_ruler = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_inspiration', description: 'Iterate through all inspirations in the world', supportedScopes: ['none'], supportedTargets: ['inspiration'], outputScope: 'inspiration', isIterator: true, syntax: "random_inspiration = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_inspired_character', description: 'Iterate through all characters with an inspirations in the world', supportedScopes: ['none'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_inspired_character = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_kingdom', description: 'Iterate through all kingdoms in the game', supportedScopes: ['none'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_kingdom = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_list', description: 'a random list effect', supportedScopes: ['none'], isIterator: true, syntax: "random_list = { X1 = { trigger = { enables/disable this effect} modifier/compare_modifier/opinion_modifier = Y1 effect1 } X2 = { trigger = { enables/disable this effect} modifier/compare_modifier/opinion_modifier = Y2 effect2 } ... }\nSelects one effect from the list and fires it. The effects are weighted by numbers X1, X2... (the higher the number, the higher the chance of the effect being picked).\nThe chances can be modified by optional value modifier lists Y1, Y2... (AKA MTTH)" },
  { name: 'random_living_character', description: 'Iterate through all living characters', supportedScopes: ['none'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_living_character = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_log_scopes', description: 'Log the current scope to the random log when this effect executes. Only use temprorarily for debugging purposes as it can introduce localized strings into the Scopes._Random log. yes = full scope info, no=only current scope', supportedScopes: ['none'], isIterator: true },
  { name: 'random_mercenary_company', description: 'Iterate through all mercenary companies', supportedScopes: ['none'], supportedTargets: ['mercenary_company'], outputScope: 'mercenary_company', isIterator: true, syntax: "random_mercenary_company = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_open_invite_activity', description: 'Iterate through all open invite activities in the world', supportedScopes: ['none'], supportedTargets: ['activity'], outputScope: 'activity', isIterator: true, syntax: "random_open_invite_activity = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_player', description: 'Iterate through all player characters', supportedScopes: ['none'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_player = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_pool_character', description: 'Iterate through all characters in the pool of the given province', supportedScopes: ['none'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_pool_character = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_province', description: 'Iterate through all provinces (skips non-land and impassable provinces)', supportedScopes: ['none'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, syntax: "random_province = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_religion_global', description: 'Iterate through all religions in the game', supportedScopes: ['none'], supportedTargets: ['religion'], outputScope: 'religion', isIterator: true, syntax: "random_religion_global = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_ruler', description: 'Rulers list with a COUNT tier o above', supportedScopes: ['none'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_ruler = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_special_building_province', description: 'Iterate through all provinces with a special building slot (built or un-built)', supportedScopes: ['none'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, syntax: "random_special_building_province = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_trait', description: '8ï¿½ï¿½ï¿½ï¿½', supportedScopes: ['none'], supportedTargets: ['trait'], outputScope: 'trait', isIterator: true },
  { name: 'random_trait_in_category', description: 'Iterate through all traits in a given category', supportedScopes: ['none'], supportedTargets: ['trait'], outputScope: 'trait', isIterator: true, syntax: "any_trait_in_category = { category = fame/health/etc }\nrandom_trait_in_category = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_vassal_contract', description: '[2023-10-12 16:38:54.881] [Clausewitz Debug] [debug] [pdx_gui_assetfactory.cpp:684] [LoadAssetsGUI] Loading of "gui/texticons_religion.gui" is complete', supportedScopes: ['none'], supportedTargets: ['vassal_contract'], outputScope: 'vassal_contract', isIterator: true },
  { name: 'remove_from_list', description: 'Removes the current scope from a named list remove_from_list = <string>', supportedScopes: ['none'] },
  { name: 'remove_global_variable', description: 'Removes a variable', supportedScopes: ['none'], syntax: "remove_variable = variable_name" },
  { name: 'remove_list_global_variable', description: 'Removes the target from a variable list', supportedScopes: ['none'], syntax: "remove_list_variable = { name = X target = Y }\nWhere X is the name of the variable\nWhere Y is an event target" },
  { name: 'remove_list_local_variable', description: 'Removes the target from a variable list', supportedScopes: ['none'], syntax: "remove_list_variable = { name = X target = Y }\nWhere X is the name of the variable\nWhere Y is an event target" },
  { name: 'remove_list_variable', description: 'Removes the target from a variable list', supportedScopes: ['none'], syntax: "remove_list_variable = { name = X target = Y }\nWhere X is the name of the variable\nWhere Y is an event target" },
  { name: 'remove_local_variable', description: 'Removes a variable', supportedScopes: ['none'], syntax: "remove_variable = variable_name" },
  { name: 'remove_title_law', description: 'remove law from scoped title. This will leave the law group empty, so only do this if you\'re getting rid of a law group. DOES NOT apply law removal costs and effects.', supportedScopes: ['none'], syntax: "remove_title_law = princely_elective_succession_law" },
  { name: 'remove_title_law_effects', description: 'remove law from scoped title. This will leave the law group empty, so only do this if you\'re getting rid of a law group. DOES apply law removal costs and effects.', supportedScopes: ['none'], syntax: "remove_title_law = princely_elective_succession_law" },
  { name: 'remove_variable', description: 'Removes a variable', supportedScopes: ['none'], syntax: "remove_variable = variable_name" },
  { name: 'resolve_title_and_vassal_change', description: 'resolve_title_and_vassal_change = scope:change', supportedScopes: ['none'], supportedTargets: ['title_and_vassal_change'], syntax: "Execute and destory the target title and vassal change, the change cannot be used after calling this effect" },
  { name: 'round_global_variable', description: 'Rounds a variable to the nearest specified value', supportedScopes: ['none'], syntax: "round_variable = { name = X nearest = Y }\nWhere X is the name of the variable\nWhere Y is a script value" },
  { name: 'round_local_variable', description: 'Rounds a variable to the nearest specified value', supportedScopes: ['none'], syntax: "round_variable = { name = X nearest = Y }\nWhere X is the name of the variable\nWhere Y is a script value" },
  { name: 'round_variable', description: 'Rounds a variable to the nearest specified value', supportedScopes: ['none'], syntax: "round_variable = { name = X nearest = Y }\nWhere X is the name of the variable\nWhere Y is a script value" },
  { name: 'run_interaction', description: 'Execute/send the given interaction', supportedScopes: ['none'], syntax: "interaction = interaction_key - the interaction object key to run\nredirect = [yes|no] - yes by default, redirect the actor and recipients ( only works if secondary_actor and secondary_recipient are not setup or are invalid)\nactor = character_actor - must be defined\nrecipient = character_actor - must be defined\nsecondary_actor = character_secontary_actor - optional\nsecondary_recipient = character_secondary_recipient - optional\nexecute_threshold = accept/maybe/decline - will be executed immediately if the AI response is at least this\nsend_threshold = accept/maybe/decline - will be sent if the AI response is at least this\nAt least one of execute_threshold and send_threshold must be set" },
  { name: 'save_opinion_value_as', description: 'Saves the scoped character\'s opinion of the target character as an arbitrarily-named target to be referenced later in the (unbroken) event chain', supportedScopes: ['none'], syntax: "save_opinion_value_as = { name = <string> target = x }" },
  { name: 'save_scope_as', description: 'Saves the current scope as an arbitrarily-named target to be referenced later in the (unbroken) event chain', supportedScopes: ['none'], syntax: "save_event_target_as = <string>" },
  { name: 'save_scope_value_as', description: 'Saves a numerical or bool value as an arbitrarily-named target to be referenced later in the (unbroken) event chain', supportedScopes: ['none'], syntax: "save_scope_value_as = { name = <string> value = x }" },
  { name: 'save_temporary_opinion_value_as', description: 'Saves the scoped character\'s opinion of the target character as an arbitrarily-named target to be referenced later in the in the same effect', supportedScopes: ['none'], syntax: "save_temporary_opinion_value_as = { name = <string> target = x" },
  { name: 'save_temporary_scope_as', description: 'Saves the current scope as an arbitrarily-named temporary target to be referenced later in the same effect', supportedScopes: ['none'], syntax: "save_temporary_event_target_as = <string>" },
  { name: 'save_temporary_scope_value_as', description: 'Saves a numerical or bool value as an arbitrarily-named temporary target to be referenced later in the same effect', supportedScopes: ['none'], syntax: "save_temporary_scope_value_as = { name = <string> value = x }" },
  { name: 'set_focus_progress', description: 'Sets focus progress', supportedScopes: ['none'] },
  { name: 'set_generated_asexuality_chance', description: 'Sets the chance for a generated character to be asexual', supportedScopes: ['none'], syntax: "set_generated_asexuality_chance = 20" },
  { name: 'set_generated_bisexuality_chance', description: 'Sets the chance for a generated character to be bisexual', supportedScopes: ['none'], syntax: "set_generated_bisexuality_chance = 20" },
  { name: 'set_generated_homosexuality_chance', description: 'Sets the chance for a generated character to be homosexual', supportedScopes: ['none'], syntax: "set_generated_homosexuality_chance = 20" },
  { name: 'set_global_variable', description: 'Sets a variable', supportedScopes: ['none'], syntax: "set_variable = { name = X value = Y days = Z }\nWhere X is the name of the variable used to then access it\nWhere Y is any event target, bool, value, script value or flag (flag:W)\nAn optional days where Z is the number of days or script value\nThis variable will be accessible with <type_>var:X. With type being in a scope object or in a top scope\nCan also be used as set_variable = X (equivalent to set_variable = { name = X value = yes })" },
  { name: 'set_local_variable', description: 'Sets a variable', supportedScopes: ['none'], syntax: "set_variable = { name = X value = Y days = Z }\nWhere X is the name of the variable used to then access it\nWhere Y is any event target, bool, value, script value or flag (flag:W)\nAn optional days where Z is the number of days or script value\nThis variable will be accessible with <type_>var:X. With type being in a scope object or in a top scope\nCan also be used as set_variable = X (equivalent to set_variable = { name = X value = yes })" },
  { name: 'set_pregnancy_gender', description: 'Set the gender of the unborn child', supportedScopes: ['none'], syntax: "set_pregnancy_gender = female/male/random" },
  { name: 'set_variable', description: 'Sets a variable', supportedScopes: ['none'], syntax: "set_variable = { name = X value = Y days = Z }\nWhere X is the name of the variable used to then access it\nWhere Y is any event target, bool, value, script value or flag (flag:W)\nAn optional days where Z is the number of days or script value\nThis variable will be accessible with <type_>var:X. With type being in a scope object or in a top scope\nCan also be used as set_variable = X (equivalent to set_variable = { name = X value = yes })" },
  { name: 'setup_claim_cb', description: '= { attacker = scope:attacker', supportedScopes: ['none'], syntax: "defender = scope:defender\nclaimant = scope:claimant\nchange = scope:change victory = yes/no\ntake_occupied = yes/no } , this effect will add a scope:cb_prestige_factor with a value based on what's being taken\ncivil_war = yes # Will vassalize people based on their capital location rather than being fully contained. Won't steal land from people not vassalized" },
  { name: 'setup_de_jure_cb', description: '= { attacker = scope:attacker', supportedScopes: ['none'], syntax: "defender = scope:defender\nchange = scope:change\nvictory = yes/no\ntitle = some title - Optional; will make it target a specific dejure title rather than *everything* that is dejure the attacker's\n}, this effect will add a scope:cb_prestige_factor with a value based on what's being taken" },
  { name: 'setup_invasion_cb', description: '= { attacker = scope:attacker', supportedScopes: ['none'], syntax: "defender = scope:defender\nchange = scope:change victory = yes/no\ntake_occupied = yes/no } , this effect will add a scope:cb_prestige_factor with a value based on what's being taken" },
  { name: 'show_as_tooltip', description: 'Effect only shown in tooltips (but not executed)', supportedScopes: ['none'] },
  { name: 'start_struggle', description: 'Start a struggle, start_struggle = { struggle_type = X start_phase = Y }where X is a struggle type, Y is a phase', supportedScopes: ['none'] },
  { name: 'start_tutorial_lesson', description: 'Starts the tutorial lesson with the given key. Does nothing if the tutorial is not running, the lesson is completed (or already running), or the lesson cannot be triggered (e.g. trigger fails)', supportedScopes: ['none'] },
  { name: 'switch', description: 'Switch on a trigger for the evaluation of another trigger with an optional fallback trigger.', supportedScopes: ['none'], syntax: "switch = {\ntrigger = simple_assign_trigger\ncase_1 = { <effects> }\ncase_2 = { <effects> }\ncase_n = { <effects> }\nfallback = { <effects> }" },
  { name: 'trigger_event', description: 'triggers an event or on_action', supportedScopes: ['none'], syntax: "trigger_event = {\nid = <event ID>                               # or:\non_action = <on_action name>                  # or:\nsaved_event_id = <event target with event ID> # example: scope:my_flag_name\n# optionally, the event can be delayed via one of those choices:    days/months/years = <num>\ndays/months/years = { <num> <num> }           # pick a value randomly from the range\ntrigger_on_next_date = \"<year>.<month>.<day>\" # trigger on a specific date in the future\ntrigger_on_next_date = \"<month>.<day>\"        # trigger the next time this date is reached (this or next year)\ndelayed = yes                                 # delay to the next tick\n}" },
  { name: 'try_create_important_action', description: 'Tries to create an important action notification. Will keep the current one if already exists.', supportedScopes: ['none'], syntax: "important_action_type = important_action_type_key - the important action object key to create. Must be defined.\nscope_name = object - optional, saves the object as the named scope to be be used by the important action effect" },
  { name: 'try_create_suggestion', description: 'Tries to create an suggestuib notification. Will keep the current one if already exists.', supportedScopes: ['none'], syntax: "suggestion_type = suggestion_type_key - the suggestion action object key to create. Must be defined.\nactor = character_actor - optional, can be used by the suggestion effect\nrecipient = character_actor - optional, can be used by the suggestion effect\nsecondary_actor = character_secontary_actor - optional, can be used by the suggestion effect\nsecondary_recipient = character_secondary_recipient - optional, can be used by the suggestion effect\nlanded_title = landed_title - optional, can be used by the suggestion effect" },
  { name: 'while', description: 'Repeats enclosed effects while limit criteria are met or until set iteration count is reached', supportedScopes: ['none'], syntax: "while = { limit = { <triggers> } <effects> }\nwhile = { count = 3 <effects> }\nDefault max of 1000." },
];

/**
 * All effects combined
 */
export const allEffects: EffectDefinition[] = [
  ...characterEffects,
  ...landedtitleEffects,
  ...provinceEffects,
  ...dynastyEffects,
  ...dynastyhouseEffects,
  ...cultureEffects,
  ...faithEffects,
  ...religionEffects,
  ...armyEffects,
  ...schemeEffects,
  ...warEffects,
  ...activityEffects,
  ...artifactEffects,
  ...generalEffects,
];

/**
 * Get effects valid for a specific scope
 */
export function getEffectsForScope(scope: ScopeType): EffectDefinition[] {
  return allEffects.filter(effect => {
    if (effect.supportedScopes.includes('none')) return true;
    return effect.supportedScopes.includes(scope);
  });
}

/**
 * Build a map for quick lookup
 */
export const effectsMap = new Map<string, EffectDefinition>(
  allEffects.map(e => [e.name, e])
);
