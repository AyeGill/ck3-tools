/**
 * CK3 Effect Definitions (Auto-generated)
 * 
 * Effects are commands that modify game state.
 * Each effect has a list of scopes where it can be used.
 * 
 * Source: Local files from /Users/eigil/Projects/Gottfried/vscode-ck3-tools/src/data/script_docs
 * Total effects: 1886
 */

import { ScopeType } from './scopes';

export interface EffectDefinition {
  name: string;
  description: string;
  supportedScopes: ScopeType[];
  supportedTargets?: ScopeType[];
  outputScope?: ScopeType;
  isIterator?: boolean;
  syntax?: string;
  parameters?: string[];
}

/**
 * Effects for character scope (862 effects)
 */
export const characterEffects: EffectDefinition[] = [
  { name: 'accept_activity_invite', description: 'accept_activity_invite = activity', supportedScopes: ['character'], supportedTargets: ['activity'], syntax: "The scoped character accepts the invitation to the target activity, using their default travel plan." },
  { name: 'accept_activity_invite_without_travel', description: 'accept_activity_invite_without_travel = activity', supportedScopes: ['character'], supportedTargets: ['activity'], syntax: "The scoped character accepts the invitation to the target activity, without adding a travel plan.\nThe character will need to be at the location or they will be kicked out of the activity." },
  { name: 'accept_task_contract', description: 'accept_task_contract = TASK_CONTRACT_SCOPE', supportedScopes: ['character'], supportedTargets: ['task_contract'] },
  { name: 'add_amenity_level', description: 'add_amenity_level = { type = food value = 2 }', supportedScopes: ['character'], syntax: "Increases the amenity type by the given value for the scoped character" },
  { name: 'add_barter_goods', description: 'adds barter goods to a character', supportedScopes: ['character'] },
  { name: 'add_character_flag', description: 'adds a character flag', supportedScopes: ['character'], syntax: "usage:\nadd_character_flag = X\nadd_character_flag = { flag = X days/weeks/years = Y }\nwhere X is the name of the flag and Y is a value or value interval \"{ min max }\"" },
  { name: 'add_character_modifier', description: 'Add a modifier to a character', supportedScopes: ['character'], syntax: "add_character_modifier = name\nadd_character_modifier = { modifier = name days/weeks/months/years = int }\nYou can also add an optional 'desc' field. This is a dynamic description that'll be used for your timed modifier" },
  { name: 'add_contact', description: 'Add the target character to the scoped character\'s list of contacts', supportedScopes: ['character'], supportedTargets: ['character'], syntax: "add_contact = CHARACTER_SCOPE" },
  { name: 'add_courtier', description: 'Add the target character to the scope character\'s court', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'add_dead_character_flag', description: 'add_dead_character_flag = {', supportedScopes: ['character'], syntax: "flag = <name> - name of the flag\nyears/weeks/days = { <min_number> <max_number> } - years/weeks/days this flag is supposed to last\n}\nAdds a flag to a dead character. A duration is required.", parameters: ['flag'] },
  { name: 'add_diplomacy_lifestyle_perk_points', description: 'Adds lifestyle per points to the given character', supportedScopes: ['character'] },
  { name: 'add_diplomacy_lifestyle_xp', description: 'Adds lifestyle XP to the given character', supportedScopes: ['character'] },
  { name: 'add_dread', description: 'adds (or removes) dread to a character', supportedScopes: ['character'] },
  { name: 'add_gold', description: 'adds gold to a character', supportedScopes: ['character'] },
  { name: 'add_hook', description: 'Adds a hook on a character', supportedScopes: ['character'], syntax: "add_hook = { type = X, target = Y, secret = Z, days/months/years = W  }\nNote: days/months/years optional (taken from hook type otherwise) and can be a value or an interval, secret required for hook types that require it.\nDoes send a toast to the player if it's involved." },
  { name: 'add_hook_no_toast', description: 'Adds a hook on a character', supportedScopes: ['character'], syntax: "add_hook = { type = X, target = Y, secret = Z, days/months/years = W  }\nNote: days/months/years optional (taken from hook type otherwise) and can be a value or an interval, secret required for hook types that require it.\nDoes NOT send a toast to the player." },
  { name: 'add_intrigue_lifestyle_perk_points', description: 'Adds lifestyle per points to the given character', supportedScopes: ['character'] },
  { name: 'add_intrigue_lifestyle_xp', description: 'Adds lifestyle XP to the given character', supportedScopes: ['character'] },
  { name: 'add_joined_faction_discontent', description: 'add_joined_faction_discontent = X adds (or subtracts) discontent to the factions the scope character is in', supportedScopes: ['character'] },
  { name: 'add_knows_of_killer', description: 'Adds the right hand side character as knowing of the killer of the scoped object', supportedScopes: ['character'], supportedTargets: ['character'], syntax: "dead_person = { add_knows_of_killer = root }", parameters: ['dead_person'] },
  { name: 'add_learning_lifestyle_perk_points', description: 'Adds lifestyle per points to the given character', supportedScopes: ['character'] },
  { name: 'add_learning_lifestyle_xp', description: 'Adds lifestyle XP to the given character', supportedScopes: ['character'] },
  { name: 'add_legitimacy', description: 'Add or remove legitimacy to the scoped living playable character', supportedScopes: ['character'] },
  { name: 'add_long_term_gold', description: 'Add gold to \'long term\' AI budget category, respecting maximums, overflow goes into Short Term budget. (gold will be created out of nowhere)character, add_long_term_gold = X', supportedScopes: ['character'] },
  { name: 'add_martial_lifestyle_perk_points', description: 'Adds lifestyle per points to the given character', supportedScopes: ['character'] },
  { name: 'add_martial_lifestyle_xp', description: 'Adds lifestyle XP to the given character', supportedScopes: ['character'] },
  { name: 'add_opinion', description: 'Adds a temporary opinion modifier, add_opinion = { modifier = X days/months/years = Y target = Z }', supportedScopes: ['character'], syntax: "X is a scripted modifier name. Y can be a value or a range \"{ A B }\" If no timeout are specified, the modifier's scripted default timeout will be used." },
  { name: 'add_perk', description: 'Adds the perk for this character', supportedScopes: ['character'] },
  { name: 'add_personal_artifact_claim', description: 'Adds a personal claim on the target artifact to the scoped character', supportedScopes: ['character'], supportedTargets: ['artifact'] },
  { name: 'add_piety', description: 'gives (or takes) piety to a character', supportedScopes: ['character'] },
  { name: 'add_piety_and_experience', description: 'gives (or takes) piety and experience of a character, whether positive or negative', supportedScopes: ['character'] },
  { name: 'add_piety_experience', description: 'gives (or takes) piety experience to a character', supportedScopes: ['character'] },
  { name: 'add_piety_level', description: 'increases (or decreases) the piety level of a character', supportedScopes: ['character'] },
  { name: 'add_piety_no_experience', description: 'gives (or takes) piety without experience to a character', supportedScopes: ['character'] },
  { name: 'add_pressed_claim', description: 'gives a pressed claim to a character', supportedScopes: ['character'], supportedTargets: ['landed_title'] },
  { name: 'add_prestige', description: 'gives (or takes) prestige to a character', supportedScopes: ['character'] },
  { name: 'add_prestige_and_experience', description: 'gives (or takes) prestige and experience of a character, whether positive or negative', supportedScopes: ['character'] },
  { name: 'add_prestige_experience', description: 'gives (or takes) prestige experience to a character', supportedScopes: ['character'] },
  { name: 'add_prestige_level', description: 'increases (or decreases) the prestige level of a character', supportedScopes: ['character'] },
  { name: 'add_prestige_no_experience', description: 'gives (or takes) prestige without experience to a character', supportedScopes: ['character'] },
  { name: 'add_realm_law', description: 'Adds the given law to the scoped character', supportedScopes: ['character'] },
  { name: 'add_realm_law_skip_effects', description: 'Adds the given law to the scoped character. Skips the cost and the pass effect, and the revoke effects of the current law', supportedScopes: ['character'] },
  { name: 'add_relation_flag', description: 'Adds a flag to an existing relation', supportedScopes: ['character'], syntax: "add_relation_flag = {\nrelation = scripted_relation\nflag = flag_name (declared in the relation's script)\ntarget = other_character\n}", parameters: ['relation', 'flag', 'target'] },
  { name: 'add_reserved_gold', description: 'Add gold to \'reserved\' AI budget category, respecting maximums, overflow goes into Short Term budget. (gold will be created out of nowhere)character, add_reserved_gold = X', supportedScopes: ['character'] },
  { name: 'add_scheme_cooldown', description: 'Sets a scheme cooldown for the scope character towards = { target=target_character type=scheme_type days/weeks/months/years = duration }', supportedScopes: ['character'] },
  { name: 'add_secret', description: 'Adds a secret', supportedScopes: ['character'], syntax: "add_secret = { type = X target = Y }\nNote that if you create a Secret in the immediate effect, the tooltips for other effects run in that Secret's scope (such as reveal_to) are likely to be displayed incorrectly, or not to be displayed at all. This is due to the game generating the tooltip before it actually has a Secret that exists to work off of.\nTest rigorously and use custom tooltips if necessary. Creating a Secret in the immediate and then running effects on it in an event option should produce perfectly normal tooltips." },
  { name: 'add_short_term_gold', description: 'Add gold to \'short term\' AI budget category, respecting maximums, overflow goes into Short Term budget. (gold will be created out of nowhere)character, add_short_term_gold = X', supportedScopes: ['character'] },
  { name: 'add_stewardship_lifestyle_perk_points', description: 'Adds lifestyle per points to the given character', supportedScopes: ['character'] },
  { name: 'add_stewardship_lifestyle_xp', description: 'Adds lifestyle XP to the given character', supportedScopes: ['character'] },
  { name: 'add_stress', description: 'increases (or decreases) stress of a character', supportedScopes: ['character'] },
  { name: 'add_subject_standing', description: 'Adds the given amount of subject standing to the scope character\'s current subject contract', supportedScopes: ['character'], syntax: "add_subject_standing = { add = learning max = 10 }" },
  { name: 'add_targeting_factions_discontent', description: 'add_targeting_factions_discontent = X adds (or subtracts) discontent to all the factions that are targeting the scope character', supportedScopes: ['character'] },
  { name: 'add_to_activity', description: 'add_to_activity = activity', supportedScopes: ['character'], supportedTargets: ['activity'], syntax: "The scoped character is invited to and accepts an invitation to join the target activity, using their default travel plan" },
  { name: 'add_to_activity_without_travel', description: 'add_to_activity = activity', supportedScopes: ['character'], supportedTargets: ['activity'], syntax: "The scoped character is invited to and accepts an invitation to join the target activity, without adding a travel plan.\nThe character will need to be at the location or they will be kicked out of the activity." },
  { name: 'add_to_agent_slot', description: 'Adds a character to a specific agent slot', supportedScopes: ['character'] },
  { name: 'add_trait', description: 'Adds a trait to a character (the trait will not be added and no tooltip will be shown if the character isn\'t eligible for the trait, i.e. when already having the trait, having an opposing trait, not fulfilling the trait\'s is_potential trigger or being outside of the trait\'s range)', supportedScopes: ['character'], supportedTargets: ['trait'] },
  { name: 'add_trait_force_tooltip', description: 'Adds a trait to a character (if the add_trait effect would not add the trait - i.e. when already having the trait, having an opposing trait, not fulfilling the trait\'s is_potential trigger or being outside of the trait\'s range - a tooltip will be shown but the trait will not be added)', supportedScopes: ['character'], supportedTargets: ['trait'] },
  { name: 'add_trait_xp', description: 'Adds XP to the trait level track for the scoped character. Track name is required if the trait has multiple tracks, otherwise should not be provided.', supportedScopes: ['character'], syntax: "add_trait_xp = { trait = <trait_key> track = <track_key> value = <script_value> }" },
  { name: 'add_treasury', description: 'adds treasury to a character', supportedScopes: ['character'] },
  { name: 'add_treasury_or_gold', description: 'adds treasury if exists, otherwise gold to character', supportedScopes: ['character'] },
  { name: 'add_truce_both_ways', description: 'Sets the both-way truce against the specified character', supportedScopes: ['character'], syntax: "'character' specifies the target character\n'override' says whether it should replace the previous truce even if shorter\n'years / months / days' sets the duration of the truce\n'result' specifies the result from the scope character's point of view ('white_peace' by default)\n'casus_belli' sets the casus belli scope that caused the truce, mutually exclusive with 'name'\n'name' sets a custom description. Dynamic description with the current scope\n'war' sets the war that caused the truce, mutually exclusive with 'casus_belli'\nadd_truce_both_ways = { character = X years/months/days = Y override = yes/no result = victory/defeat/white_peace casus_belli/war = Z }" },
  { name: 'add_truce_one_way', description: 'Sets the truce against the specified character', supportedScopes: ['character'], syntax: "'character' specifies the target character\n'override' says whether it should replace the previous truce even if shorter\n'years / months / days' sets the duration of the truce\n'result' specifies the result from the scope character's point of view ('white_peace' by default)\n'casus_belli' sets the casus belli scope that caused the truce, mutually exclusive with 'name'\n'name' sets a custom description. Dynamic description with the current scope\nadd_truce_one_way = { character = X years/months/days = Y override = yes/no result = victory/defeat/white_peace casus_belli/war = Z }" },
  { name: 'add_tyranny', description: 'adds (or removes) tyranny to (or from) a character', supportedScopes: ['character'] },
  { name: 'add_unpressed_claim', description: 'gives an unpressed claim to a character', supportedScopes: ['character'], supportedTargets: ['landed_title'] },
  { name: 'add_visiting_courtier', description: 'Add the target character as the scope character\'s guest', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'add_wanderer_lifestyle_perk_points', description: 'Adds lifestyle per points to the given character', supportedScopes: ['character'] },
  { name: 'add_wanderer_lifestyle_xp', description: 'Adds lifestyle XP to the given character', supportedScopes: ['character'] },
  { name: 'add_war_chest_gold', description: 'Add gold to \'war chest\' AI budget category, respecting maximums, overflow goes into Short Term budget. (gold will be created out of nowhere)character, add_war_chest_gold = X', supportedScopes: ['character'] },
  { name: 'adopt', description: 'Set scoped character as parent ot the targetscope:new_parent = { adopt = scope:offspring }', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'ai_attempt_to_build_building_effect', description: 'Force the AI to evaluate possible buildings they can build/upgrade within their domain and start construction if they can afford it.i_attempt_to_build_building_effect = yes', supportedScopes: ['character'] },
  { name: 'ai_attempt_to_host_activity', description: 'Force the AI to re-evaluate the given activity type and see if they want to host it. This overrides the ai_check_interval and activity cooldown.', supportedScopes: ['character'], supportedTargets: ['activity_type'], syntax: "ai_attempt_to_host_activity = activity_type" },
  { name: 'ai_start_best_war', description: 'Starts the \'best\' AI scored war possible, from the list of filtered possible wars available to the AI character.', supportedScopes: ['character'], syntax: "ai_start_best_war  = {\n# Optional list of CBs that the war must have\tcb = { <valid_casus_belli_type1> <valid_casus_belli_type2> }\n# If the cb target data from the AI should be recalculated. Otherwise uses current calculated data. (only use if needed!)   recalculate_cb_targets = no\n# Filter possible wars, called with scopes:\n# root - Current AI character\n# scope:target_character - CB Target Character\n# scope:target_title - CB (first) Target Title\n# scope:target_titles - Target Titles list\n# scope:claimant - Character that is Claimant for CB (if present)\n# scope:casus_belli_type - CB type\n# scope:has_hostage - Boolean if target_character has a hostage for current AI character\n# scope:score - AI score for CB\nis_valid = { ... }\n# Effect called when war was successfully started (scopes are similar to is_valid)\ton_success = { ... }\n# Effect called when no war was found or successfully started\ton_failure = { ... }\n}", parameters: ['is_valid'] },
  { name: 'allow_alliance', description: 'Allows (previously broken) alliance with the target character', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'allow_in_scheme', description: 'Allow the character to join the scheme as an agent', supportedScopes: ['character'], supportedTargets: ['scheme'] },
  { name: 'apply_ai_vassal_admin_province_obligation_liege_most_desired', description: 'Apply the new level for the most desired AI obligation level the liege in the contract wants', supportedScopes: ['character'] },
  { name: 'apply_ai_vassal_admin_province_obligation_vassal_most_desired', description: 'Apply the new level for the most desired AI obligation level the vassal in the contract wants', supportedScopes: ['character'] },
  { name: 'apply_ai_vassal_obligation_liege_most_desired', description: 'Apply the new level for the most desired AI obligation level the liege in the contract wants', supportedScopes: ['character'] },
  { name: 'apply_ai_vassal_obligation_vassal_most_desired', description: 'Apply the new level for the most desired AI obligation level the vassal in the contract wants', supportedScopes: ['character'] },
  { name: 'appoint_court_position', description: 'Appoints the target character in target court position within scoped character\'s court', supportedScopes: ['character'], syntax: "recipient = character scope - target character to receive the title\ncourt_position = court position type - court position type to assign the receiver", parameters: ['recipient', 'court_position'] },
  { name: 'assign_council_task', description: 'Assigns the target character to the council task', supportedScopes: ['character'], syntax: "assign_council_task = {\ncouncil_task = council_task_scope\ntarget = character_taking_the_position    fire_on_actions = [yes]\n}", parameters: ['council_task', 'target'] },
  { name: 'assign_councillor_type', description: 'Assigns the target character to a council position of a specific type.', supportedScopes: ['character'], syntax: "If 'remove_existing_councillor = yes', any existing councillor is removed before assigning. (not fired)\nassign_councillor_type = {\ntype = <council_position_type_key>\ntarget = character_taking_the_position\nfire_on_actions = [yes]\nremove_existing_councillor = [no]\n}", parameters: ['type', 'target', 'fire_on_actions', 'remove_existing_councillor'] },
  { name: 'banish', description: 'The character gets banished.', supportedScopes: ['character'] },
  { name: 'becomes_independent', description: 'becomes and independent ruler. becomes_independent = { change = \'previously created title_and_vassal_change\'', supportedScopes: ['character'] },
  { name: 'break_alliance', description: 'Breaks the alliance with the target character', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'cancel_truce_both_ways', description: 'Ends the truce against the specified character, and theirs against the scoped character. cancel_truce_both_ways = scope:character', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'cancel_truce_one_way', description: 'Ends the truce against the specified character. cancel_truce_one_way = scope:character', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'change_age', description: 'Changes the character\'s age by the given amount. Sets age to 0 if it\'d end up below 0. Note that this will completely bypass birthday on-actions, age-related health, and so on, just like the console command', supportedScopes: ['character'], syntax: "Usage: change_age = script value" },
  { name: 'change_current_court_grandeur', description: 'Changes the current court grandeur of a character with a royal court, clamped between NRoyalCourt::COURT_GRANDEUR_MIN and NRoyalCourt::COURT_GRANDEUR_MAX.', supportedScopes: ['character'] },
  { name: 'change_current_weight', description: 'Change the current weight of the scoped character', supportedScopes: ['character'], syntax: "change_current_weight = 20" },
  { name: 'change_diarchy_swing', description: 'Change scales of power swing for the active diarchy', supportedScopes: ['character'], syntax: "change_diarchy_swing = -5" },
  { name: 'change_first_name', description: 'Change the first name of a character', supportedScopes: ['character'], syntax: "change_first_name = <dynamic_description>\nchange_first_name = { template_character = scope:character } # copy name from the template character" },
  { name: 'change_government', description: 'changes the government type of a ruler', supportedScopes: ['character'] },
  { name: 'change_influence', description: 'changes influence of a character', supportedScopes: ['character'] },
  { name: 'change_influence_and_experience', description: 'changes influence (without experience) of a character', supportedScopes: ['character'] },
  { name: 'change_influence_experience', description: 'changes influence experience of a character', supportedScopes: ['character'] },
  { name: 'change_influence_level', description: 'changes the influence level of a character', supportedScopes: ['character'] },
  { name: 'change_influence_no_experience', description: 'changes influence and experience of a character, whether positive or negative', supportedScopes: ['character'] },
  { name: 'change_liege', description: '= { liege = \'Character that should become the new liege\' change = \'previously created title_and_vassal_change\', adds a liege change', supportedScopes: ['character'] },
  { name: 'change_merit', description: 'changes merit of a character - always includes proportional experience, whether positive or negative', supportedScopes: ['character'] },
  { name: 'change_merit_experience', description: 'changes merit experience of a character', supportedScopes: ['character'] },
  { name: 'change_merit_level', description: 'changes the merit level of a character', supportedScopes: ['character'] },
  { name: 'change_merit_no_experience', description: 'changes merit (without experience) of a character', supportedScopes: ['character'] },
  { name: 'change_prison_type', description: 'Changes the charater\'s prison type. Scoped character is the prisoner. Accepts any static modifier (see also improson effect).', supportedScopes: ['character'], syntax: "change_prison_type = house_arrest" },
  { name: 'change_strife_opinion', description: 'Change strife opinion caused by the scoped character', supportedScopes: ['character'], syntax: "scope:diarch = { change_strife_opinion = 15 }" },
  { name: 'change_target_weight', description: 'Change the target weight of the scoped character', supportedScopes: ['character'], syntax: "change_target_weight = 20" },
  { name: 'change_trait_rank', description: 'Changes the trait rank = { trait = trait_group rank = change max = maximum new rank }', supportedScopes: ['character'] },
  { name: 'clear_appointment_timeout', description: 'Remove any existing timeout a character\'s participation in any appointment.', supportedScopes: ['character'], syntax: "clear_appointment_timeout = yes" },
  { name: 'clear_designated_heir', description: 'Remove any currently set designated heir of a character.', supportedScopes: ['character'], syntax: "clear_designated_heir = yes" },
  { name: 'clear_forced_vote', description: 'Clears forced voting', supportedScopes: ['character'], syntax: "clear_forced_vote = yes" },
  { name: 'complete_activity_intent', description: 'complete_activity_intent = bool', supportedScopes: ['character'], syntax: "Complete the scoped character's current intent in their involved activity" },
  { name: 'consume_banish_reasons', description: '\'Consume\' all banish reasons that the scoped character has on the target character. Until they get a new reason, they cannot banish the target again.', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'consume_divorce_reasons', description: '\'Consume\' all divorce reason that the scoped character has on the target character. Until they get a new reason, they cannot divorce the target again.', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'consume_execute_reasons', description: '\'Consume\' all execute reasons that the scoped character has on the target character. Until they get a new reason, they cannot execute the target again.', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'consume_imprisonment_reasons', description: '\'Consume\' all imprisonment reasons that the scoped character has on the target character. Until they get a new reason, they cannot imprison the target again.', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'consume_revoke_title_reason', description: '\'Consume\' 1 revoke title reason that the scoped character has on the target character.', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'copy_inheritable_appearance_from', description: 'copies the inheritable appearance attributes (inheritable genes in the character\'s DNA string) from the target character to the scoped character', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'copy_localized_text', description: 'Copies a piece of localized text from the target character for the given key.', supportedScopes: ['character'], syntax: "copy_localized_text = { key = key target = character }" },
  { name: 'create_alliance', description: 'Create an alliance between the scoped character and the target. The allied through characters determine who gets checked against for if the alliance should persist or not.', supportedScopes: ['character'], syntax: "create_alliance = {\ntarget = scope\nallied_through_owner = scope\nallied_through_target = scope\n}\nOR as a short hand use just the target to use the owner and target as the allied through characters\ncreate_alliance = scope", parameters: ['target', 'allied_through_owner', 'allied_through_target'] },
  { name: 'create_artifact', description: 'Creates a new artifact and adds it to the inventory of the given character', supportedScopes: ['character'], syntax: "Be aware that we make use of the current scopes implicitly. This is done in common/artifacts/visuals\nname = dynamic description - artifact name\ndescription = dynamic description - artifact description\nrarity = enum - artifact rarity, ex. legendary\ntype = flag - inventory slot type, ex. trinket\nmodifier = static modifier - applied to the character whom wields this artifact\ndurability = script value - new durability, will be max by default\nmax_durability = script value - Optional. A value for the max durability, which would override the one normally assigned by the defines\ndecaying = yes/no - Optional. Set if artifact decays with time. Yes by default\nhistory = artifact history entry - custom history entry to denote for example that this is artifact was reforged by someone else than the owner\ntype = artifact history entry type - available types:\ncreated_before_history\ncreated\nprize_created\ndiscovered\ncreator_discovered\nclaimed_by_house\ngiven\nstolen\ninherited\nconquest\ntaken_in_siege\ntaken_in_battle\nwon_in_duel\npurchased\nprize_awarded\nransomed\nreforged\ntemplate = artifact scripted template - a scripted base template with triggers and modifiers\nvisuals = artifact visual type - how this artifact should appear visually\ngenerate_history = bool - automatically generate a new history entry if none has been scripted?\nquality = script value - new quality, used in AI scoring\nwealth = script value - new wealth, used in AI scoring\ncreator = character scope - set a custom creator of the artifact ( default is the owner )\nvisuals_source = scope containing landed title, dynasty or house - set a source of coat of arms graphics for the artifact\n(only few artifact models actually make use of it. Most notable - banners)\nsave_scope_as = new artifact - an optional way to get a reference to the newly created artifact\ntitle_history = title - history entries of the given title will be added to the artifact history\ntitle_history_date = game date - from which date onwards to copy historical entries from given title\ncreator = character scope - set a custom creator of the artifact ( default is the owner )", parameters: ['name', 'description', 'rarity', 'type', 'modifier', 'durability', 'max_durability', 'decaying', 'history', 'template', 'visuals', 'generate_history', 'quality', 'wealth', 'creator', 'visuals_source', 'title_history', 'title_history_date'] },
  { name: 'create_cadet_branch', description: 'The scope character creates a cadet branch of the house they are in.', supportedScopes: ['character'], syntax: "usage:\n<founding character> = {\ncreate_cadet_branch = {\nname = <dynamic_description> # optional\ncoat_of_arms = <coa key> # optional\nspread_to_descendants = <yes/no> # optional, default: yes\nsave_scope_as = <name>\n}\n}\nNote: The used character must belong to a house, but not be the head of that house.", parameters: ['name', 'coat_of_arms', 'spread_to_descendants'] },
  { name: 'create_character_memory', description: 'Creates a memory for the character of a given type and participants plus an optional duration. Saved as scope:new_memory.', supportedScopes: ['character'], syntax: "create_character_memory = { type = memory_type participants = { tag = scope } duration = { years = 3 } }" },
  { name: 'create_confederation', description: 'Creates a confederation and adds the scoped character as a member.', supportedScopes: ['character'], syntax: "The confederation will be saved to scope:new_confederation\nusage:\ncreate_confederation = {\nname = key/dynamic description\ntype = <confederation type> # Optional. Type of confederation to create.\nleader = <house> # Optional. House that leads the confederation.\n}", parameters: ['name', 'type', 'leader'] },
  { name: 'create_divergent_culture', description: 'Creates a new divergent culture from the scope character\'s culture. The new culture will keep all pillars and traditions of the parent culture ï¿½ it is up to the user to add or remove pillars and traditions as appropriate.The new divergent culture is saved as scope:new_culture.', supportedScopes: ['character'], syntax: "create_divergent_culture = yes" },
  { name: 'create_divergent_culture_with_side_effects', description: 'Creates a new divergent culture from the scope character\'s culture. This also incurs the cost, does conversion, and such, just as if you\'d diverged via the UI. Unlike create_divergent_culture, it will change ethos and suchThe new culture is NOT saved as a scope due to technical limitations.', supportedScopes: ['character'], syntax: "create_divergent_culture_with_side_effects = yes" },
  { name: 'create_divergent_culture_with_side_effects_excluding_cost', description: 'Creates a new divergent culture from the scope character\'s culture. Ignores the cost, does conversion, and such, just as if you\'d diverged via the UI. Unlike create_divergent_culture, it will change ethos and suchThe new culture is NOT saved as a scope due to technical limitations.', supportedScopes: ['character'], syntax: "create_divergent_culture_with_side_effects_excluding_cost = yes" },
  { name: 'create_dynasty', description: 'Create a new dynasty (and house) with the scope character as it\'s head.', supportedScopes: ['character'], syntax: "usage:\n<founding character> = {\ncreate_dynasty = {\nprefix = <loc key> # optional\nname = <dynamic_description> # optional\ncoat_of_arms = <coa key> # optional\nspread_to_descendants = <yes/no> # optional, default: yes\nsave_scope_as = <scope name> #optional\n}\n}\nNote: The used character may not be the head of the dynasty or house that they are leaving.", parameters: ['prefix', 'name', 'coat_of_arms', 'spread_to_descendants'] },
  { name: 'create_faction', description: 'the scoped character creates a faction of the specified type against the specified target, create_faction = { type = X target = Y }', supportedScopes: ['character'] },
  { name: 'create_hybrid_culture', description: 'Creates a new hybrid culture from the scope character\'s culture and the RHS culture. The new culture will have a random mix of pillars and traditions from both, like when the AI hybridizes. The new hybrid culture is saved as scope:new_culture.', supportedScopes: ['character'], supportedTargets: ['culture'], syntax: "create_hybrid_culture = culture:anglo-saxon" },
  { name: 'create_hybrid_culture_with_side_effects', description: 'Creates a new hybrid culture from the scope character\'s culture and the RHS culture. The new culture will have a random mix of pillars and traditions from both, like when the AI hybridizes. This also incurs the cost, does conversion, and such, just as if you\'d hybridized via the UI. The new hybrid culture is NOT saved as a scope due to technical limitations.', supportedScopes: ['character'], supportedTargets: ['culture'], syntax: "create_hybrid_culture_with_side_effects = culture:anglo-saxon" },
  { name: 'create_inspiration', description: 'create_inspiration = inspiration_type', supportedScopes: ['character'], syntax: "Creates an inspiration of a given type owned by scoped character, new inspiration is saved as scope:new_inspiration\ncreate_inspiration = { type = inspiration_type gold = script_value }\nAs above but overrides the base cost compared to the one defined in the type" },
  { name: 'create_legend', description: 'Creates a new legend owned by the scoped character.', supportedScopes: ['character'], syntax: "create_legend = {\ntype = heroic\nquality = famed\nchronicle = chronicle_type\nproperties = {\n<key> = scope\n<key> = scope\n# Where each <key> must match to the property of that chronicle type\n# and the resulting scope object must be of the type of that property\n}\nprotagonist = character # optional, defaults to scoped character\nsave_scope_as = new_legend # optional\n}", parameters: ['type', 'quality', 'chronicle', 'properties', 'protagonist'] },
  { name: 'create_legend_seed', description: 'Creates a new legend ssed owned by the scoped character.', supportedScopes: ['character'], syntax: "create_legend_seed = {\ntype = heroic\nquality = famed\nchronicle = chronicle_type\nproperties = {\n<key> = scope\n<key> = scope\n# Where each <key> must match to the property of that chronicle type\n# and the resulting scope object must be of the type of that property\n}\n}", parameters: ['type', 'quality', 'chronicle', 'properties'] },
  { name: 'create_maa_regiment', description: 'Create MaA regiment for a ruler.', supportedScopes: ['character'], syntax: "If title is set, MaA will be created as title troops\nscope:ruler = {\ncreate_maa_regiment = light_footmen\ncreate_maa_regiment = {\ntype = light_footmen          # mutually exclusive with type_of\ntype_of = scope:maa_regiment  # mutually exclusive with type. Take MaA type from the scoped regiment\ncheck_can_recruit = no\ntitle = scope:title\nsize = 5\n}\n}", parameters: ['type', 'type_of', 'check_can_recruit', 'title', 'size'] },
  { name: 'create_story', description: 'creates and initializes a story cycle with the current character as owner', supportedScopes: ['character'], syntax: "create_story = story_type\ncreate_story = {\ntype = story_type\nsave_scope_as/save_temporary_scope_as = scope_name # optional way to get a reference to the new story}", parameters: ['type'] },
  { name: 'create_task_contract', description: 'create_task_contract = {', supportedScopes: ['character'], syntax: "#Mandatory parameters\ntask_contract_type = TYPE_NAME\ntask_task_contract_tier = VALUE\nlocation = PROVINCE_SCOPE\n#Optional parameters\ntask_contract_employer = CHARACTER_SCOPE\ndestination = PROVINCE_SCOPE\ntarget = CHARACTER_SCOPE\nsave_scope_as = new_task_contract # optional\n}", parameters: ['task_contract_type', 'task_task_contract_tier', 'location', 'task_contract_employer', 'destination', 'target'] },
  { name: 'death', description: 'kills a character, death = { killer = X death_reason = Y artifact = Z }, where X is a character and Y is one of the death reason keys. Optionally artifact Z will be used as the killing artifact instead of the defaulted one from the killer\'s slot for that death reason\'s definition. Or death = natural which will pick a natural death reason to kill the character from.', supportedScopes: ['character'] },
  { name: 'decline_activity_invite', description: 'decline_activity_invite = activity', supportedScopes: ['character'], supportedTargets: ['activity'], syntax: "The scoped character declines the invitation to the target activity" },
  { name: 'depose', description: 'The character gets deposed.', supportedScopes: ['character'] },
  { name: 'depose_diarch', description: 'Current scoped diarch is deposed and replaced with the next from the line of succession', supportedScopes: ['character'], syntax: "depose_diarch = yes/no" },
  { name: 'designate_diarch', description: 'Designated target character as a future diarch', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'destroy_all_event_troops', description: 'Destroys ALL event troop regiments belonging to the scoped character.', supportedScopes: ['character'], syntax: "destroy_all_event_troops = yes/no" },
  { name: 'destroy_title', description: 'Destroys a title', supportedScopes: ['character'], supportedTargets: ['landed_title'] },
  { name: 'enact_treasury_budgets', description: 'Calculate and set budget base-rate values based on allocation modifiers and current income.', supportedScopes: ['character'], syntax: "Will apply cost and opinion effects.\nenact_treasury_budgets = yes" },
  { name: 'enact_treasury_budgets_init', description: 'Calculate and set budget base-rate values based on allocation modifiers and current income.', supportedScopes: ['character'], syntax: "Will NOT cost anything NOR apply opinion effects. Will recalculate modifiers.\nenact_treasury_budgets_init = yes" },
  { name: 'enact_treasury_budgets_no_costs', description: 'Calculate and set budget base-rate values based on allocation modifiers and current income.', supportedScopes: ['character'], syntax: "Will NOT cost anything or apply opinion effects.\nenact_treasury_budgets_no_costs = yes" },
  { name: 'enact_treasury_budgets_no_costs_no_opinion_effects', description: 'Calculate and set budget base-rate values based on allocation modifiers and current income.', supportedScopes: ['character'], syntax: "Will NOT cost anything NOR apply opinion effects.\nenact_treasury_budgets_no_costs_no_opinion_effects = yes" },
  { name: 'enact_treasury_budgets_no_opinion_effects', description: 'Calculate and set budget base-rate values based on allocation modifiers and current income.', supportedScopes: ['character'], syntax: "Will apply costs, but no opinion effects.\nenact_treasury_budgets_no_opinion_effects = yes" },
  { name: 'end_diarchy', description: 'End diarchy for the character', supportedScopes: ['character'], syntax: "end_diarchy = yes/no" },
  { name: 'end_pregnancy', description: 'end a pregnancy', supportedScopes: ['character'] },
  { name: 'end_tributary', description: 'Ends the scoped character\'s current tributary contract.', supportedScopes: ['character'] },
  { name: 'every_acclaimed_knight', description: 'Iterate through all acclaimed knights employed by a given character', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_acclaimed_knight = { limit = { <triggers> } <effects> }" },
  { name: 'every_accolade', description: 'Iterate through all ( active and inactive ) Accolades of a given liege character\'s Acclaimed Knights', supportedScopes: ['character'], supportedTargets: ['accolade'], outputScope: 'accolade', isIterator: true, syntax: "every_accolade = { limit = { <triggers> } <effects> }" },
  { name: 'every_active_accolade', description: 'Iterate through all active Accolades of a given liege character\'s Acclaimed Knights', supportedScopes: ['character'], supportedTargets: ['accolade'], outputScope: 'accolade', isIterator: true, syntax: "Optionally specify an accolade parameter filter\nany_active_accolade = { accolade_parameter = accolade_organize_army_bonus }\nevery_active_accolade = { limit = { <triggers> } <effects> }", parameters: ['any_active_accolade'] },
  { name: 'every_alert_creatable_title', description: 'Iterate through all titles that can be created by the character. (only for alerts)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_alert_creatable_title = { limit = { <triggers> } <effects> }" },
  { name: 'every_alert_usurpable_title', description: 'Iterate through all titles that can be usurped by the character. (only for alerts)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_alert_usurpable_title = { limit = { <triggers> } <effects> }" },
  { name: 'every_ally', description: 'Iterate through all allies', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_ally = { limit = { <triggers> } <effects> }" },
  { name: 'every_ancestor', description: 'Iterate through all the ancestors of the scope character up to 5 generations', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_ancestor = { limit = { <triggers> } <effects> }" },
  { name: 'every_army', description: 'Iterate through all armies', supportedScopes: ['character'], supportedTargets: ['army'], outputScope: 'army', isIterator: true, syntax: "every_army = { limit = { <triggers> } <effects> }" },
  { name: 'every_available_task_contract', description: 'Iterate through all task contracts of location of root province', supportedScopes: ['character'], supportedTargets: ['task_contract'], outputScope: 'task_contract', isIterator: true, syntax: "every_available_task_contract = { limit = { <triggers> } <effects> }" },
  { name: 'every_character_active_contract', description: 'Gets all accepted task contracts of the root character', supportedScopes: ['character'], supportedTargets: ['task_contract'], outputScope: 'task_contract', isIterator: true, syntax: "Optionally specify a contract type filter\nany_character_active_contract = { task_contract_type = laamp_raid_contract }\nevery_character_active_contract = { limit = { <triggers> } <effects> }", parameters: ['any_character_active_contract'] },
  { name: 'every_character_artifact', description: 'Iterate through all artifacts in a given characters inventory', supportedScopes: ['character'], supportedTargets: ['artifact'], outputScope: 'artifact', isIterator: true, syntax: "every_character_artifact = { limit = { <triggers> } <effects> }" },
  { name: 'every_character_epidemic', description: 'Gets epidemics affecting the scoped character', supportedScopes: ['character'], supportedTargets: ['epidemic'], outputScope: 'epidemic', isIterator: true, syntax: "every_character_epidemic = { limit = { <triggers> } <effects> }" },
  { name: 'every_character_situation', description: 'Iterate through all situations that a character is participating in', supportedScopes: ['character'], supportedTargets: ['situation'], outputScope: 'situation', isIterator: true, syntax: "every_character_situation = { limit = { <triggers> } <effects> }" },
  { name: 'every_character_struggle', description: 'Iterate through all struggles that character is involved in. Optional: Narrow down the involvement status *_chracter_struggle = { involvement = involved | interloper }', supportedScopes: ['character'], supportedTargets: ['struggle'], outputScope: 'struggle', isIterator: true, syntax: "every_character_struggle = { limit = { <triggers> } <effects> }" },
  { name: 'every_character_task_contract', description: 'Gets all task contracts of the scoped character', supportedScopes: ['character'], supportedTargets: ['task_contract'], outputScope: 'task_contract', isIterator: true, syntax: "Optionally specify a contract type filter\nany_character_task_contract = { task_contract_type = laamp_raid_contract }\nevery_character_task_contract = { limit = { <triggers> } <effects> }", parameters: ['any_character_task_contract'] },
  { name: 'every_character_to_title_neighboring_and_across_water_county', description: 'Scopes from a character to a neighboring county (incl. across water, looking trough the de Jure lieges)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_character_to_title_neighboring_and_across_water_county = { limit = { <triggers> } <effects> }" },
  { name: 'every_character_to_title_neighboring_and_across_water_duchy', description: 'Scopes from a character to a neighboring duchy (incl. across water, looking trough the de Jure lieges)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_character_to_title_neighboring_and_across_water_duchy = { limit = { <triggers> } <effects> }" },
  { name: 'every_character_to_title_neighboring_and_across_water_empire', description: 'Scopes from a character to a neighboring empire (incl. across water, looking trough the de Jure lieges)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_character_to_title_neighboring_and_across_water_empire = { limit = { <triggers> } <effects> }" },
  { name: 'every_character_to_title_neighboring_and_across_water_kingdom', description: 'Scopes from a character to a neighboring kingdom (incl. across water, looking trough the de Jure lieges)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_character_to_title_neighboring_and_across_water_kingdom = { limit = { <triggers> } <effects> }" },
  { name: 'every_character_to_title_neighboring_county', description: 'Scopes from a character to a neighboring county (looking trough the de Jure lieges)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_character_to_title_neighboring_county = { limit = { <triggers> } <effects> }" },
  { name: 'every_character_to_title_neighboring_duchy', description: 'Scopes from a character to a neighboring duchy (looking trough the de Jure lieges)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_character_to_title_neighboring_duchy = { limit = { <triggers> } <effects> }" },
  { name: 'every_character_to_title_neighboring_empire', description: 'Scopes from a character to a neighboring empire (looking trough the de Jure lieges)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_character_to_title_neighboring_empire = { limit = { <triggers> } <effects> }" },
  { name: 'every_character_to_title_neighboring_kingdom', description: 'Scopes from a character to a neighboring kingdom (looking trough the de Jure lieges)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_character_to_title_neighboring_kingdom = { limit = { <triggers> } <effects> }" },
  { name: 'every_character_trait', description: 'Iterate through all traits a character has', supportedScopes: ['character'], supportedTargets: ['trait'], outputScope: 'trait', isIterator: true, syntax: "every_character_trait = { limit = { <triggers> } <effects> }" },
  { name: 'every_character_war', description: 'Wars of the scoped character', supportedScopes: ['character'], supportedTargets: ['war'], outputScope: 'war', isIterator: true, syntax: "every_character_war = { limit = { <triggers> } <effects> }" },
  { name: 'every_child', description: 'Iterate through all children', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_child = { limit = { <triggers> } <effects> }" },
  { name: 'every_claim', description: 'Iterate through the titles of all claims held by a character; parameters: explicit = yes/no/all pressed = yes/no/all', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_claim = { limit = { <triggers> } <effects> }" },
  { name: 'every_claimed_artifact', description: 'Iterate through all claimed artifacts of the scoped character', supportedScopes: ['character'], supportedTargets: ['artifact'], outputScope: 'artifact', isIterator: true, syntax: "every_claimed_artifact = { limit = { <triggers> } <effects> }" },
  { name: 'every_close_family_member', description: 'Iterate through all the close family [father, mother, siblings, children, grandparents]', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_close_family_member = { limit = { <triggers> } <effects> }" },
  { name: 'every_close_or_extended_family_member', description: 'Iterate through all the close and extended relatives [father, mother, siblings, children, grandparents, uncles/aunts, nephew/niece, cousins]', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_close_or_extended_family_member = { limit = { <triggers> } <effects> }" },
  { name: 'every_concubine', description: 'Iterate through all concubines', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_concubine = { limit = { <triggers> } <effects> }" },
  { name: 'every_consort', description: 'Iterate through all consorts (concubines and spouses)', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_consort = { limit = { <triggers> } <effects> }" },
  { name: 'every_contact', description: 'Iterate through all contact characters of the root character', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_contact = { limit = { <triggers> } <effects> }" },
  { name: 'every_councillor', description: 'Iterate through all councillors', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_councillor = { limit = { <triggers> } <effects> }" },
  { name: 'every_court_position_candidate', description: 'Iterate through all valid candidates for a court position type.', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "*_court_position_candidate = {\ncourt_position = bodyguard_court_position\nOR\ncourt_position = scope:my_scoped_court_position_type\n...\n}\nevery_court_position_candidate = { limit = { <triggers> } <effects> }", parameters: ['court_position'] },
  { name: 'every_court_position_employer', description: 'Iterates through all characters that employ the scoped character in any court position.', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_court_position_employer = { limit = { <triggers> } <effects> }" },
  { name: 'every_court_position_holder', description: 'Iterates through all characters employed by the scoped character in the target court position.', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_court_position_holder = { limit = { <triggers> } <effects> }" },
  { name: 'every_courtier', description: 'Iterate through all courtiers', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_courtier = { limit = { <triggers> } <effects> }" },
  { name: 'every_courtier_away', description: 'Iterate through all courtiers that are away', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_courtier_away = { limit = { <triggers> } <effects> }" },
  { name: 'every_courtier_or_guest', description: 'Iterate through all courtiers and guests (pool and foreign court guests)', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_courtier_or_guest = { limit = { <triggers> } <effects> }" },
  { name: 'every_de_jure_claim', description: 'Iterate through all de jure claims for a character', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_de_jure_claim = { limit = { <triggers> } <effects> }" },
  { name: 'every_diarchy_succession_character', description: 'Iterate through all character in the diarchy line of succession.If there\'s no active diarchy or active one doesn\'t have succession,it iterates over regency candidates', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_diarchy_succession_character = { limit = { <triggers> } <effects> }" },
  { name: 'every_diplomacy_councillor', description: 'Iterate through all diplomacy-based councillors', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_diplomacy_councillor = { limit = { <triggers> } <effects> }" },
  { name: 'every_directly_owned_province', description: 'Iterate through all directly owned provinces', supportedScopes: ['character'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, syntax: "every_directly_owned_province = { limit = { <triggers> } <effects> }" },
  { name: 'every_election_title', description: 'Iterate through all titles the scoped character can vote on', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_election_title = { limit = { <triggers> } <effects> }" },
  { name: 'every_equipped_character_artifact', description: 'Iterate through all equipped artifacts in a given characters inventory', supportedScopes: ['character'], supportedTargets: ['artifact'], outputScope: 'artifact', isIterator: true, syntax: "every_equipped_character_artifact = { limit = { <triggers> } <effects> }" },
  { name: 'every_extended_family_member', description: 'Iterate through all the extended family [uncles/aunts, nephew/niece, cousins]', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_extended_family_member = { limit = { <triggers> } <effects> }" },
  { name: 'every_foreign_court_guest', description: 'Iterate through all guests visiting from another court (in contrast to pool_guest they have a liege)', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_foreign_court_guest = { limit = { <triggers> } <effects> }" },
  { name: 'every_former_concubine', description: 'Iterate through all former concubines. Not persisted past death', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_former_concubine = { limit = { <triggers> } <effects> }" },
  { name: 'every_former_concubinist', description: 'Iterate through all former concubinists. Not persisted past death', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_former_concubinist = { limit = { <triggers> } <effects> }" },
  { name: 'every_former_spouse', description: 'Iterate through all former spouses', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_former_spouse = { limit = { <triggers> } <effects> }" },
  { name: 'every_general_councillor', description: 'Iterate through all councillors that are not related to a skill', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_general_councillor = { limit = { <triggers> } <effects> }" },
  { name: 'every_heir', description: 'Heirs of the scoped character', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_heir = { limit = { <triggers> } <effects> }" },
  { name: 'every_heir_title', description: 'Iterate through all titles the scoped character is heir to', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_heir_title = { limit = { <triggers> } <effects> }" },
  { name: 'every_held_title', description: 'Iterate through all held landed titles. Optionally specify a tier filter', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "any/every/ordered/random_held_title = { title_tier >= county }\nevery_held_title = { limit = { <triggers> } <effects> }" },
  { name: 'every_hired_mercenary', description: 'Iterate through all hired mercenary companies', supportedScopes: ['character'], supportedTargets: ['mercenary_company'], outputScope: 'mercenary_company', isIterator: true, syntax: "every_hired_mercenary = { limit = { <triggers> } <effects> }" },
  { name: 'every_home_court_hostage', description: 'Iterate through all hostages currently abroad', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_home_court_hostage = { limit = { <triggers> } <effects> }" },
  { name: 'every_hooked_character', description: 'Iterate through all characters this character has a hook on', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_hooked_character = { limit = { <triggers> } <effects> }" },
  { name: 'every_hostile_raider', description: 'Iterate through anyone the character is hostile to due to their top-liege\'s realm having been raided', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_hostile_raider = { limit = { <triggers> } <effects> }" },
  { name: 'every_intrigue_councillor', description: 'Iterate through all intrigue-based councillors', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_intrigue_councillor = { limit = { <triggers> } <effects> }" },
  { name: 'every_invited_activity', description: 'Iterate through all activities a character has been invited to', supportedScopes: ['character'], supportedTargets: ['activity'], outputScope: 'activity', isIterator: true, syntax: "every_invited_activity = { limit = { <triggers> } <effects> }" },
  { name: 'every_knight', description: 'Iterate through all knights', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_knight = { limit = { <triggers> } <effects> }" },
  { name: 'every_known_secret', description: 'Iterate through all secrets known by the character', supportedScopes: ['character'], supportedTargets: ['secret'], outputScope: 'secret', isIterator: true, syntax: "every_known_secret = { limit = { <triggers> } <effects> }" },
  { name: 'every_land_neighboring_realm_with_tributaries', description: 'A realm with a different top liege neighboring the realm of the scope character\'s top liege; switches to the realm\'s top title. Can be based on borders a day or two out of date. Includes land borders extended due to tributaries.', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_land_neighboring_realm_with_tributaries = { limit = { <triggers> } <effects> }" },
  { name: 'every_land_neighboring_realm_with_tributaries_owner', description: 'A realm with a different top liege neighboring the realm of the scope character\'s top liege; switches to the holder of the realm. Can be based on borders a day or two out of date. Includes land borders extended due to tributaries.', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_land_neighboring_realm_with_tributaries_owner = { limit = { <triggers> } <effects> }" },
  { name: 'every_learning_councillor', description: 'Iterate through all learning-based councillors', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_learning_councillor = { limit = { <triggers> } <effects> }" },
  { name: 'every_liege_or_above', description: 'Iterate through all lieges above a character (skipping the character themselves)', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_liege_or_above = { limit = { <triggers> } <effects> }" },
  { name: 'every_maa_regiment', description: 'Iterate through all MaA regiments', supportedScopes: ['character'], supportedTargets: ['regiment'], outputScope: 'regiment', isIterator: true, syntax: "every_maa_regiment = { limit = { <triggers> } <effects> }" },
  { name: 'every_martial_councillor', description: 'Iterate through all martial-based councillors', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_martial_councillor = { limit = { <triggers> } <effects> }" },
  { name: 'every_memory', description: 'Iterate through all memories of a character', supportedScopes: ['character'], supportedTargets: ['character_memory'], outputScope: 'character_memory', isIterator: true, syntax: "Optionally specify a memory type filter\nany_memory = { memory_type = completed_rites_of_passage }\nevery_memory = { limit = { <triggers> } <effects> }", parameters: ['any_memory'] },
  { name: 'every_neighboring_and_across_water_realm_owner', description: 'A sub-realm or realm bordering the scope character\'s realm (including across water). Returns counts and above.', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_neighboring_and_across_water_realm_owner = { limit = { <triggers> } <effects> }" },
  { name: 'every_neighboring_and_across_water_realm_same_rank_owner', description: 'A sub-realm or realm bordering the scope character\'s realm (including across water) and has the same rank as the scope character (look for lieges of he owner of the land if necessary)', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_neighboring_and_across_water_realm_same_rank_owner = { limit = { <triggers> } <effects> }" },
  { name: 'every_neighboring_and_across_water_top_liege_realm', description: 'A realm with a different top liege neighboring the realm of the scope character\'s top liege (including across water); switches to the realm\'s top title. Can be based on borders a day or two out of date', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_neighboring_and_across_water_top_liege_realm = { limit = { <triggers> } <effects> }" },
  { name: 'every_neighboring_and_across_water_top_liege_realm_owner', description: 'A realm with a different top liege neighboring the realm of the scope character\'s top liege (including across water); switches to the holder of the realm. Can be based on borders a day or two out of date', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_neighboring_and_across_water_top_liege_realm_owner = { limit = { <triggers> } <effects> }" },
  { name: 'every_neighboring_and_across_water_top_suzerain_realm', description: 'A realm with a different top suzerain neighboring the realm of the scope character\'s top suzerain (including across water); switches to the realm\'s top title. Can be based on borders a day or two out of date', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_neighboring_and_across_water_top_suzerain_realm = { limit = { <triggers> } <effects> }" },
  { name: 'every_neighboring_and_across_water_top_suzerain_realm_owner', description: 'A realm with a different top suzerain neighboring the realm of the scope character\'s top suzerain (including across water); switches to the holder of the realm. Can be based on borders a day or two out of date', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_neighboring_and_across_water_top_suzerain_realm_owner = { limit = { <triggers> } <effects> }" },
  { name: 'every_neighboring_realm_owner', description: 'A sub-realm or realm bordering the scope character\'s realm. Returns counts and above.', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_neighboring_realm_owner = { limit = { <triggers> } <effects> }" },
  { name: 'every_neighboring_realm_same_rank_owner', description: 'A sub-realm or realm bordering the scope character\'s realm and has the same rank as the scope character (look for lieges of he owner of the land if necessary)', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_neighboring_realm_same_rank_owner = { limit = { <triggers> } <effects> }" },
  { name: 'every_neighboring_realm_with_tributaries_owner', description: 'A realm with a different top liege neighboring the realm of the scope character\'s top liege; switches to the holder of the realm. Can be based on borders a day or two out of date. Includes land and water borders extended by including tributaries.', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_neighboring_realm_with_tributaries_owner = { limit = { <triggers> } <effects> }" },
  { name: 'every_neighboring_top_liege_realm', description: 'A realm with a different top liege neighboring the realm of the scope character\'s top liege; switches to the realm\'s top title. Can be based on borders a day or two out of date', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_neighboring_top_liege_realm = { limit = { <triggers> } <effects> }" },
  { name: 'every_neighboring_top_liege_realm_owner', description: 'A realm with a different top liege neighboring the realm of the scope character\'s top liege; switches to the holder of the realm. Can be based on borders a day or two out of date', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_neighboring_top_liege_realm_owner = { limit = { <triggers> } <effects> }" },
  { name: 'every_neighboring_top_suzerain_realm', description: 'A realm with a different top suzerain neighboring the realm of the scope character\'s top suzerain; switches to the realm\'s top title. Can be based on borders a day or two out of date', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_neighboring_top_suzerain_realm = { limit = { <triggers> } <effects> }" },
  { name: 'every_neighboring_top_suzerain_realm_owner', description: 'A realm with a different top suzerain neighboring the realm of the scope character\'s top suzerain; switches to the holder of the realm. Can be based on borders a day or two out of date', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_neighboring_top_suzerain_realm_owner = { limit = { <triggers> } <effects> }" },
  { name: 'every_noble_family', description: 'Iterate through all noble family titles in the realm of scoped character.', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "If the character is not independent this will return an empty list.\nevery_noble_family = { limit = { <triggers> } <effects> }" },
  { name: 'every_opposite_sex_spouse_candidate', description: 'Iterate through all the spouse candidates of the opposite sex of a character.', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "WARNING: THIS IS VERY SLOW DO NOT DO IT OFTEN.\nevery_opposite_sex_spouse_candidate = { limit = { <triggers> } <effects> }" },
  { name: 'every_owned_story', description: 'Iterate through all owned stories for a character', supportedScopes: ['character'], supportedTargets: ['story'], outputScope: 'story', isIterator: true, syntax: "Optionally specify a story type filter\nany_owned_story = { type = story_cycle_pet_cat }\nevery_owned_story = { limit = { <triggers> } <effects> }", parameters: ['any_owned_story'] },
  { name: 'every_parent', description: 'Iterate through all (both) parents', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_parent = { limit = { <triggers> } <effects> }" },
  { name: 'every_patroned_holy_order', description: 'Iterate through all holy orders that the scoped character is a patron of', supportedScopes: ['character'], supportedTargets: ['holy_order'], outputScope: 'holy_order', isIterator: true, syntax: "every_patroned_holy_order = { limit = { <triggers> } <effects> }" },
  { name: 'every_personal_claimed_artifact', description: 'Iterate through all personally claimed artifacts of the scoped character', supportedScopes: ['character'], supportedTargets: ['artifact'], outputScope: 'artifact', isIterator: true, syntax: "every_personal_claimed_artifact = { limit = { <triggers> } <effects> }" },
  { name: 'every_pinned_character', description: 'Iterate through characters this player has pinned', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_pinned_character = { limit = { <triggers> } <effects> }" },
  { name: 'every_pinning_character', description: 'Iterate through characters whose player has this character pinned', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_pinning_character = { limit = { <triggers> } <effects> }" },
  { name: 'every_played_character', description: 'Iterate through all characters the player playing this character has played. Matches the game over legacy, except for excluding the currently played character', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_played_character = { limit = { <triggers> } <effects> }" },
  { name: 'every_player_heir', description: 'Iterate through player heirs, capped at the first 10', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_player_heir = { limit = { <triggers> } <effects> }" },
  { name: 'every_player_legend_library', description: 'Get all legends in a player character library.', supportedScopes: ['character'], supportedTargets: ['legend'], outputScope: 'legend', isIterator: true, syntax: "every_player_legend_library = { limit = { <triggers> } <effects> }" },
  { name: 'every_pool_guest', description: 'Iterate through all guests visiting the court from the pool (in contrast to foreign_court_guest they don\'t have a liege)', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_pool_guest = { limit = { <triggers> } <effects> }" },
  { name: 'every_potential_marriage_option', description: 'Iterate through all potential selectable marriage or betrohed options', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_potential_marriage_option = { limit = { <triggers> } <effects> }" },
  { name: 'every_powerful_family', description: 'Iterate through all powerful families in this character\'s realm.', supportedScopes: ['character'], supportedTargets: ['dynasty_house'], outputScope: 'dynasty_house', isIterator: true, syntax: "If the character is not independent this will return an empty list.\nevery_powerful_family = { limit = { <triggers> } <effects> }" },
  { name: 'every_powerful_vassal', description: 'Iterate through the all powerful vassals of a character', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_powerful_vassal = { limit = { <triggers> } <effects> }" },
  { name: 'every_pretender_title', description: 'Iterate through all landed titles character is pretender to', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_pretender_title = { limit = { <triggers> } <effects> }" },
  { name: 'every_primary_war_enemy', description: 'Iterate through all primary war enemies', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_primary_war_enemy = { limit = { <triggers> } <effects> }" },
  { name: 'every_prisoner', description: 'Iterate through all prisoners', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_prisoner = { limit = { <triggers> } <effects> }" },
  { name: 'every_prowess_councillor', description: 'Iterate through all prowess-based councillors', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_prowess_councillor = { limit = { <triggers> } <effects> }" },
  { name: 'every_raid_target', description: 'Iterate through anyone the character is hostile to due to having raided them. Only returns top lieges', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_raid_target = { limit = { <triggers> } <effects> }" },
  { name: 'every_realm_border_county', description: 'Iterate through all counties that are on the edge of your realm bordering a different neighboring realm.', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_realm_border_county = { limit = { <triggers> } <effects> }" },
  { name: 'every_realm_county', description: 'Iterate through all counties in the realm. Based on top liege', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_realm_county = { limit = { <triggers> } <effects> }" },
  { name: 'every_realm_de_jure_duchy', description: 'Iterate through all de jure duchies that have at least one county in the realm. Based on top liege', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_realm_de_jure_duchy = { limit = { <triggers> } <effects> }" },
  { name: 'every_realm_de_jure_empire', description: 'Iterate through all de jure empire that have at least one county in the realm. Based on top liege', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_realm_de_jure_empire = { limit = { <triggers> } <effects> }" },
  { name: 'every_realm_de_jure_kingdom', description: 'Iterate through all de jure kingdom that have at least one county in the realm. Based on top liege', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_realm_de_jure_kingdom = { limit = { <triggers> } <effects> }" },
  { name: 'every_realm_province', description: 'Iterate through all realm provinces of a character', supportedScopes: ['character'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, syntax: "every_realm_province = { limit = { <triggers> } <effects> }" },
  { name: 'every_relation', description: 'Iterate through scripted relations of a given type or multiple types, if someone is multiple relations they will only be in the list once', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_relation = { limit = { <triggers> } <effects> }" },
  { name: 'every_same_sex_spouse_candidate', description: 'Iterate through all the spouse candidates of the same sex of a character.', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "WARNING: THIS IS VERY SLOW DO NOT DO IT OFTEN.\nevery_same_sex_spouse_candidate = { limit = { <triggers> } <effects> }" },
  { name: 'every_scheme', description: 'Iterate through all schemes owned by the character', supportedScopes: ['character'], supportedTargets: ['scheme'], outputScope: 'scheme', isIterator: true, syntax: "Optionally specify a type filter\nrandom_scheme = { type = befriend }\nevery_scheme = { limit = { <triggers> } <effects> }", parameters: ['random_scheme'] },
  { name: 'every_secret', description: 'Iterate through all secrets of the character', supportedScopes: ['character'], supportedTargets: ['secret'], outputScope: 'secret', isIterator: true, syntax: "Optionally specify a secret type filter\nrandom_secret = { type = secret_lover }\nevery_secret = { limit = { <triggers> } <effects> }", parameters: ['random_secret'] },
  { name: 'every_sibling', description: 'Iterate through all siblings', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_sibling = { limit = { <triggers> } <effects> }" },
  { name: 'every_sponsored_inspiration', description: 'Iterate through all sponsored inspirations', supportedScopes: ['character'], supportedTargets: ['inspiration'], outputScope: 'inspiration', isIterator: true, syntax: "every_sponsored_inspiration = { limit = { <triggers> } <effects> }" },
  { name: 'every_spouse', description: 'Iterate through all spouses', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_spouse = { limit = { <triggers> } <effects> }" },
  { name: 'every_spouse_candidate', description: 'Iterate through all the spouse candidates of a character.', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "WARNING: THIS IS VERY SLOW DO NOT DO IT OFTEN.\nevery_spouse_candidate = { limit = { <triggers> } <effects> }" },
  { name: 'every_stewardship_councillor', description: 'Iterate through all stewardship-based councillors', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_stewardship_councillor = { limit = { <triggers> } <effects> }" },
  { name: 'every_sub_realm_barony', description: 'Iterate through all baronies in sub-realm, counting only titles that either hold land or have dejure vassals that hold land.', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_sub_realm_barony = { limit = { <triggers> } <effects> }" },
  { name: 'every_sub_realm_county', description: 'Iterate through all counties in sub-realm, counting only titles that either hold land or have dejure vassals that hold land.', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_sub_realm_county = { limit = { <triggers> } <effects> }" },
  { name: 'every_sub_realm_duchy', description: 'Iterate through all duchies in sub-realm, counting only titles that either hold land or have dejure vassals that hold land.', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_sub_realm_duchy = { limit = { <triggers> } <effects> }" },
  { name: 'every_sub_realm_empire', description: 'Iterate through all empires in sub-realm, counting only titles that either hold land or have dejure vassals that hold land.', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_sub_realm_empire = { limit = { <triggers> } <effects> }" },
  { name: 'every_sub_realm_kingdom', description: 'Iterate through all kingdoms in sub-realm, counting only titles that either hold land or have dejure vassals that hold land.', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_sub_realm_kingdom = { limit = { <triggers> } <effects> }" },
  { name: 'every_sub_realm_title', description: 'Iterate through all titles in sub-realm, counting only titles that either hold land or have dejure vassals that hold land.', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_sub_realm_title = { limit = { <triggers> } <effects> }" },
  { name: 'every_subject', description: 'Iterate through all vassals and tributaries', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_subject = { limit = { <triggers> } <effects> }" },
  { name: 'every_succession_appointment_invested_candidate', description: 'Iterate through all candidates supported by the scoped investor character for any title', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "It may contain people outside of investor's top realm or no longer valid for appointment\nevery_succession_appointment_invested_candidate = { limit = { <triggers> } <effects> }" },
  { name: 'every_succession_appointment_invested_title', description: 'Iterate through all titles that has candidates supported by the scoped investor', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "It may contain titles outside of investor's top realm, and so invalid for appointment,\nand candidates may be already dead\nevery_succession_appointment_invested_title = { limit = { <triggers> } <effects> }" },
  { name: 'every_targeting_faction', description: 'Iterate through all factions targeting the scope character', supportedScopes: ['character'], supportedTargets: ['faction'], outputScope: 'faction', isIterator: true, syntax: "Optionally specify a faction type filter\nany_targeting_faction = { faction_type = independence_faction }\nevery_targeting_faction = { limit = { <triggers> } <effects> }", parameters: ['any_targeting_faction'] },
  { name: 'every_targeting_scheme', description: 'Iterate through all schemes targeting the character', supportedScopes: ['character'], supportedTargets: ['scheme'], outputScope: 'scheme', isIterator: true, syntax: "every_targeting_scheme = { limit = { <triggers> } <effects> }" },
  { name: 'every_targeting_secret', description: 'Iterate through all secrets that target the specified scope', supportedScopes: ['character'], supportedTargets: ['secret'], outputScope: 'secret', isIterator: true, syntax: "every_targeting_secret = { limit = { <triggers> } <effects> }" },
  { name: 'every_tax_collector', description: 'Iterates through all Tax Collectors employed by the scoped character', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_tax_collector = { limit = { <triggers> } <effects> }" },
  { name: 'every_tax_collector_vassal', description: 'Iterates through all Vassals the scoped Character is the Tax Collector for', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_tax_collector_vassal = { limit = { <triggers> } <effects> }" },
  { name: 'every_tax_slot', description: 'Iterates through all Tax Slots the scoped character has', supportedScopes: ['character'], supportedTargets: ['tax_slot'], outputScope: 'tax_slot', isIterator: true, syntax: "every_tax_slot = { limit = { <triggers> } <effects> }" },
  { name: 'every_top_realm_border_county', description: 'Iterate through all counties that are on the edge of your realm bordering a different neighboring top realm.', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_top_realm_border_county = { limit = { <triggers> } <effects> }" },
  { name: 'every_traveling_family_member', description: 'Iterate though all characters that should travel with the scoped one (when moving between courts for instance); includes the scoped character', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_traveling_family_member = { limit = { <triggers> } <effects> }" },
  { name: 'every_tributary', description: 'Iterate through all tributaries', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_tributary = { limit = { <triggers> } <effects> }" },
  { name: 'every_truce_holder', description: 'Iterate through all characters that have a truce on this character', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_truce_holder = { limit = { <triggers> } <effects> }" },
  { name: 'every_truce_target', description: 'Iterate through all characters this character has a truce on', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_truce_target = { limit = { <triggers> } <effects> }" },
  { name: 'every_unassigned_taxpayers', description: 'Iterates through all unassigned taxpayers for scoped Character', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_unassigned_taxpayers = { limit = { <triggers> } <effects> }" },
  { name: 'every_unspent_known_secret', description: 'Iterate through all unspent secrets known by the character', supportedScopes: ['character'], supportedTargets: ['secret'], outputScope: 'secret', isIterator: true, syntax: "every_unspent_known_secret = { limit = { <triggers> } <effects> }" },
  { name: 'every_vassal', description: 'Iterate through all DIRECT vassals', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "Optionally specify a vassal stance filter\nany_vassal = { vassal_stance = parochial }\nevery_vassal = { limit = { <triggers> } <effects> }", parameters: ['any_vassal'] },
  { name: 'every_vassal_or_below', description: 'Iterate through ALL vassals, not just direct vassals', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "Optionally specify a vassal stance filter\nany_vassal_or_below = { vassal_stance = parochial }\nevery_vassal_or_below = { limit = { <triggers> } <effects> }", parameters: ['any_vassal_or_below'] },
  { name: 'every_war_ally', description: 'Iterate through all direct war allies', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_war_ally = { limit = { <triggers> } <effects> }" },
  { name: 'every_war_enemy', description: 'Iterate through all direct war enemies', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_war_enemy = { limit = { <triggers> } <effects> }" },
  { name: 'every_warden_hostage', description: 'Iterate through all hostages having this warden', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_warden_hostage = { limit = { <triggers> } <effects> }" },
  { name: 'execute_decision', description: 'Execute the specified decision for the scoped character', supportedScopes: ['character'], supportedTargets: ['decision'] },
  { name: 'finish_council_task', description: 'The councillor finish the current assigned task successfully.', supportedScopes: ['character'] },
  { name: 'fire_councillor', description: 'The scope character fires the target character from the council.', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'fire_councillor_skip_effects', description: 'The scope character fires the target character from the council without running on_actions.', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'fire_tax_collector', description: 'The scoped character fires the target character.', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'forbid_from_scheme', description: 'Forbid the scope character from joining the target scheme as an agent (and kick the character out if already in the scheme)', supportedScopes: ['character'], supportedTargets: ['scheme'] },
  { name: 'force_add_to_agent_slot', description: 'Adds a character as an agent to a scheme agent slot and forces them to stay', supportedScopes: ['character'], syntax: "{\nagent_slot = target_Slot\ndays/months/years = duration\n}", parameters: ['agent_slot'] },
  { name: 'force_character_skill_recalculation', description: 'Forces a character\'s skills to be recalculated immediately, bypassing the wait for the daily tick.', supportedScopes: ['character'], syntax: "NOTE: Only use this when *absolutely* necessary, as it will impact performance negatively if misused\nUsage: force_character_skill_recalculation = yes/no" },
  { name: 'force_step_down_landed_titles', description: 'Make ruler step down - less harsh than abdicate or depose.', supportedScopes: ['character'], syntax: "If ruler has any title that allows them to remain landless playable, then pass\nall landed titles to heirs - counties and any higher tier title with dejure land.\nKeep all titular titles.\nIf no such title exists, then it works identical to depose\nscope:ruler = {\nforce_step_down_landed_titles = yes\n}" },
  { name: 'force_vote_as', description: 'Forces the character to vote the same as the target', supportedScopes: ['character'], syntax: "force_vote_as = { target = someone days/months/years = x }" },
  { name: 'fund_great_project_contribution', description: 'Funds a specific Contribution for a Great Project. Will fail if the character can\'t fund the Contribution.', supportedScopes: ['character'], syntax: "Needs the Contribution object as parameter, the key by itself is not enough. Once funded, Contributions can't be retracted or refunded.\n<scope:character> = {\nfund_great_project_contribution = {\ncontribution = scope:great_project_contribution\ncost = yes/no ( optional, defaults to 'yes, if 'no' will not apply the cost of the contribution )\ncheck_can_contribute = yes/no ( optional, defaults to 'yes', if 'no' will not check if the character can fund the Contribution )\n}\n}", parameters: ['contribution', 'cost', 'check_can_contribute'] },
  { name: 'get_title', description: 'gives a title to a character', supportedScopes: ['character'], supportedTargets: ['landed_title'] },
  { name: 'give_domain_to_herders', description: 'Give each county in the scoped character\'s domain to herders and destroy all held duchy titles and above.', supportedScopes: ['character'], syntax: "give_domain_to_herds = yes", parameters: ['give_domain_to_herds'] },
  { name: 'give_nickname', description: 'Give a nickname to this character', supportedScopes: ['character'] },
  { name: 'give_noble_family_title', description: 'Give a noble family title to the <root> character.', supportedScopes: ['character'], syntax: "usage:\ngive_noble_family_title = {\nname = key/dynamic description\ntier = <county/duchy> # Optional. Defaults to duchy.\narticle = SOME_TITLE_NAME_ARTICLE\ngovernment = administrative_government # optional government, default is administrative\nsave_scope_as = <name>\n}", parameters: ['name', 'tier', 'article', 'government'] },
  { name: 'imprison', description: 'Imprisons the target character as this character\'s prisoner, imprison = { target = X reason = Y type = Z }, where X is a character, Y is a flag, Z is a static modifier', supportedScopes: ['character'] },
  { name: 'infect_with_epidemic', description: 'Infect the scoped character with the target epidemic.', supportedScopes: ['character'], supportedTargets: ['epidemic'], syntax: "infect_with_epidemic = epidemic" },
  { name: 'invalidate_diarch_if_needed', description: 'Immediately check if diarch should be invalidated', supportedScopes: ['character'], syntax: "If needed, current scoped diarch is removed and replaced\nwith the next one from the line of succession\nscope:diarch = { invalidate_diarch_if_needed = yes/no }" },
  { name: 'invite_to_activity', description: 'invite_to_activity = activity', supportedScopes: ['character'], supportedTargets: ['activity'], syntax: "The scoped character is invited to the target activity" },
  { name: 'join_faction', description: 'the character in the scope joins the assigned faction', supportedScopes: ['character'], supportedTargets: ['faction'] },
  { name: 'join_faction_forced', description: 'the character in the scope is forced to join a faction by a character for a defined time,', supportedScopes: ['character'], syntax: "join_faction_forced = {\nfaction = X\nforced_by = Y\ndays/months/years = duration\n}", parameters: ['faction', 'forced_by'] },
  { name: 'join_faction_skip_check', description: 'the character in the scope joins the assigned faction skiping the can_character_join trigger', supportedScopes: ['character'], supportedTargets: ['faction'] },
  { name: 'learn_court_language_of', description: 'The character learns the court language of the target characterlearn_court_language_of = scope:target_character', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'learn_language', description: 'The character learns the languagelearn_language = language_norwegian', supportedScopes: ['character'] },
  { name: 'learn_language_of_culture', description: 'The character learns the language of the target culturelearn_language_of_culture = scope:target_culture', supportedScopes: ['character'], supportedTargets: ['culture'] },
  { name: 'leave_faction', description: 'the charcter in the scope leaves the assigned faction', supportedScopes: ['character'], supportedTargets: ['faction'] },
  { name: 'make_claim_strong', description: 'makes a claim strong (character adds the claim if not having it already)', supportedScopes: ['character'], supportedTargets: ['landed_title'] },
  { name: 'make_claim_weak', description: 'makes a claim weak (character adds the claim if not having it already)', supportedScopes: ['character'], supportedTargets: ['landed_title'] },
  { name: 'make_concubine', description: 'Makes the target character a concubine of the scope character, the target should not be imprisoned', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'make_pregnant', description: 'makes a character pregnant', supportedScopes: ['character'], syntax: "father= 'the real father'\nnumber_of_children= X\nknown_bastard=yes/no", parameters: ['father', 'number_of_children', 'known_bastard'] },
  { name: 'make_pregnant_no_checks', description: 'makes a character pregnant. Doesn\'t error on things like celibacy', supportedScopes: ['character'], syntax: "father= 'the real father'\nnumber_of_children= X\nknown_bastard=yes/no", parameters: ['father', 'number_of_children', 'known_bastard'] },
  { name: 'make_trait_active', description: 'Activates an inactive trait. Tooltip will not be shown if the character cannot have the trait.', supportedScopes: ['character'], supportedTargets: ['trait'] },
  { name: 'make_trait_active_force_tooltip', description: 'Activates an inactive trait. Tooltip will be shown even if the character cannot have the trait.', supportedScopes: ['character'], supportedTargets: ['trait'] },
  { name: 'make_trait_inactive', description: 'Makes a current trait of a character inactive. Tooltip will not be shown if the character doesn\'t have the trait.', supportedScopes: ['character'], supportedTargets: ['trait'] },
  { name: 'make_trait_inactive_force_tooltip', description: 'Makes a current trait of a character inactive. Tooltip will be shown even if the character doesn\'t have the trait.', supportedScopes: ['character'], supportedTargets: ['trait'] },
  { name: 'make_unprunable', description: 'The scope character will no longer be prunable after their death. Use with care, as this will make everyone related to them unprunable too. So you should only use this if someone absolutely *needs* to stick around several years after their death. Example: make_unprunable = yes', supportedScopes: ['character'] },
  { name: 'marry', description: 'Marries the scoped character to the target character.', supportedScopes: ['character'], supportedTargets: ['character'], syntax: "marry = target" },
  { name: 'marry_matrilineal', description: 'Marries the scoped character to the target character matrilineally.', supportedScopes: ['character'], supportedTargets: ['character'], syntax: "marry_matrilineal = target" },
  { name: 'move_budget_gold', description: 'Move gold from one AI budget category to the other, will not move more than is available in the source budget or what can fit in the target budget.character, move_budget_gold = { gold = X from = Z to = Y }', supportedScopes: ['character'], syntax: "('budget_war_chest', 'budget_reserved', 'budget_short_term', 'budget_long_term')" },
  { name: 'move_budget_treasury', description: 'Move treasury from one AI budget category to the other, will not move more than is available in the source budget or what can fit in the target budget.character, move_budget_treasury = { treasury = X from = Z to = Y }', supportedScopes: ['character'], syntax: "('budget_war_chest', 'budget_reserved', 'budget_short_term', 'budget_long_term')" },
  { name: 'move_to_pool', description: 'The scoped character (courtier or guest) leaves their current court and moves into the pool', supportedScopes: ['character'], syntax: "scope:guest = { move_to_pool = yes }" },
  { name: 'move_to_pool_at', description: 'The scoped character (courtier/guest/pool character) leaves their current court (if any) and moves into the pool of the specified province', supportedScopes: ['character'], supportedTargets: ['province'], syntax: "scope:guest = { move_to_pool_at = scope:some_province }" },
  { name: 'open_appoint_court_position_window', description: 'Opens the appointment window for the specified court position with scoped character as liege', supportedScopes: ['character'] },
  { name: 'ordered_acclaimed_knight', description: 'Iterate through all acclaimed knights employed by a given character', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_acclaimed_knight = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_accolade', description: 'Iterate through all ( active and inactive ) Accolades of a given liege character\'s Acclaimed Knights', supportedScopes: ['character'], supportedTargets: ['accolade'], outputScope: 'accolade', isIterator: true, syntax: "ordered_accolade = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_active_accolade', description: 'Iterate through all active Accolades of a given liege character\'s Acclaimed Knights', supportedScopes: ['character'], supportedTargets: ['accolade'], outputScope: 'accolade', isIterator: true, syntax: "Optionally specify an accolade parameter filter\nany_active_accolade = { accolade_parameter = accolade_organize_army_bonus }\nordered_active_accolade = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['any_active_accolade', 'order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_alert_creatable_title', description: 'Iterate through all titles that can be created by the character. (only for alerts)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_alert_creatable_title = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_alert_usurpable_title', description: 'Iterate through all titles that can be usurped by the character. (only for alerts)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_alert_usurpable_title = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_ally', description: 'Iterate through all allies', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_ally = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_ancestor', description: 'Iterate through all the ancestors of the scope character up to 5 generations', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_ancestor = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_army', description: 'Iterate through all armies', supportedScopes: ['character'], supportedTargets: ['army'], outputScope: 'army', isIterator: true, syntax: "ordered_army = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_available_task_contract', description: 'Iterate through all task contracts of location of root province', supportedScopes: ['character'], supportedTargets: ['task_contract'], outputScope: 'task_contract', isIterator: true, syntax: "ordered_available_task_contract = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_character_active_contract', description: 'Gets all accepted task contracts of the root character', supportedScopes: ['character'], supportedTargets: ['task_contract'], outputScope: 'task_contract', isIterator: true, syntax: "Optionally specify a contract type filter\nany_character_active_contract = { task_contract_type = laamp_raid_contract }\nordered_character_active_contract = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['any_character_active_contract', 'order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_character_artifact', description: 'Iterate through all artifacts in a given characters inventory', supportedScopes: ['character'], supportedTargets: ['artifact'], outputScope: 'artifact', isIterator: true, syntax: "ordered_character_artifact = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_character_epidemic', description: 'Gets epidemics affecting the scoped character', supportedScopes: ['character'], supportedTargets: ['epidemic'], outputScope: 'epidemic', isIterator: true, syntax: "ordered_character_epidemic = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_character_situation', description: 'Iterate through all situations that a character is participating in', supportedScopes: ['character'], supportedTargets: ['situation'], outputScope: 'situation', isIterator: true, syntax: "ordered_character_situation = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_character_struggle', description: 'Iterate through all struggles that character is involved in. Optional: Narrow down the involvement status *_chracter_struggle = { involvement = involved | interloper }', supportedScopes: ['character'], supportedTargets: ['struggle'], outputScope: 'struggle', isIterator: true, syntax: "ordered_character_struggle = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_character_task_contract', description: 'Gets all task contracts of the scoped character', supportedScopes: ['character'], supportedTargets: ['task_contract'], outputScope: 'task_contract', isIterator: true, syntax: "Optionally specify a contract type filter\nany_character_task_contract = { task_contract_type = laamp_raid_contract }\nordered_character_task_contract = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['any_character_task_contract', 'order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_character_to_title_neighboring_and_across_water_county', description: 'Scopes from a character to a neighboring county (incl. across water, looking trough the de Jure lieges)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_character_to_title_neighboring_and_across_water_county = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_character_to_title_neighboring_and_across_water_duchy', description: 'Scopes from a character to a neighboring duchy (incl. across water, looking trough the de Jure lieges)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_character_to_title_neighboring_and_across_water_duchy = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_character_to_title_neighboring_and_across_water_empire', description: 'Scopes from a character to a neighboring empire (incl. across water, looking trough the de Jure lieges)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_character_to_title_neighboring_and_across_water_empire = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_character_to_title_neighboring_and_across_water_kingdom', description: 'Scopes from a character to a neighboring kingdom (incl. across water, looking trough the de Jure lieges)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_character_to_title_neighboring_and_across_water_kingdom = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_character_to_title_neighboring_county', description: 'Scopes from a character to a neighboring county (looking trough the de Jure lieges)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_character_to_title_neighboring_county = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_character_to_title_neighboring_duchy', description: 'Scopes from a character to a neighboring duchy (looking trough the de Jure lieges)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_character_to_title_neighboring_duchy = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_character_to_title_neighboring_empire', description: 'Scopes from a character to a neighboring empire (looking trough the de Jure lieges)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_character_to_title_neighboring_empire = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_character_to_title_neighboring_kingdom', description: 'Scopes from a character to a neighboring kingdom (looking trough the de Jure lieges)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_character_to_title_neighboring_kingdom = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_character_trait', description: 'Iterate through all traits a character has', supportedScopes: ['character'], supportedTargets: ['trait'], outputScope: 'trait', isIterator: true, syntax: "ordered_character_trait = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_character_war', description: 'Wars of the scoped character', supportedScopes: ['character'], supportedTargets: ['war'], outputScope: 'war', isIterator: true, syntax: "ordered_character_war = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_child', description: 'Iterate through all children', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_child = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_claim', description: 'Iterate through the titles of all claims held by a character; parameters: explicit = yes/no/all pressed = yes/no/all', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_claim = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_claimed_artifact', description: 'Iterate through all claimed artifacts of the scoped character', supportedScopes: ['character'], supportedTargets: ['artifact'], outputScope: 'artifact', isIterator: true, syntax: "ordered_claimed_artifact = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_close_family_member', description: 'Iterate through all the close family [father, mother, siblings, children, grandparents]', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_close_family_member = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_close_or_extended_family_member', description: 'Iterate through all the close and extended relatives [father, mother, siblings, children, grandparents, uncles/aunts, nephew/niece, cousins]', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_close_or_extended_family_member = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_concubine', description: 'Iterate through all concubines', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_concubine = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_consort', description: 'Iterate through all consorts (concubines and spouses)', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_consort = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_contact', description: 'Iterate through all contact characters of the root character', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_contact = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_councillor', description: 'Iterate through all councillors', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_councillor = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_court_position_candidate', description: 'Iterate through all valid candidates for a court position type.', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "*_court_position_candidate = {\ncourt_position = bodyguard_court_position\nOR\ncourt_position = scope:my_scoped_court_position_type\n...\n}\nordered_court_position_candidate = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['court_position', 'order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_court_position_employer', description: 'Iterates through all characters that employ the scoped character in any court position.', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_court_position_employer = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_court_position_holder', description: 'Iterates through all characters employed by the scoped character in the target court position.', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_court_position_holder = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_courtier', description: 'Iterate through all courtiers', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_courtier = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_courtier_away', description: 'Iterate through all courtiers that are away', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_courtier_away = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_courtier_or_guest', description: 'Iterate through all courtiers and guests (pool and foreign court guests)', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_courtier_or_guest = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_de_jure_claim', description: 'Iterate through all de jure claims for a character', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_de_jure_claim = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_diarchy_succession_character', description: 'Iterate through all character in the diarchy line of succession.If there\'s no active diarchy or active one doesn\'t have succession,it iterates over regency candidates', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_diarchy_succession_character = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_diplomacy_councillor', description: 'Iterate through all diplomacy-based councillors', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_diplomacy_councillor = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_directly_owned_province', description: 'Iterate through all directly owned provinces', supportedScopes: ['character'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, syntax: "ordered_directly_owned_province = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_election_title', description: 'Iterate through all titles the scoped character can vote on', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_election_title = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_equipped_character_artifact', description: 'Iterate through all equipped artifacts in a given characters inventory', supportedScopes: ['character'], supportedTargets: ['artifact'], outputScope: 'artifact', isIterator: true, syntax: "ordered_equipped_character_artifact = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_extended_family_member', description: 'Iterate through all the extended family [uncles/aunts, nephew/niece, cousins]', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_extended_family_member = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_foreign_court_guest', description: 'Iterate through all guests visiting from another court (in contrast to pool_guest they have a liege)', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_foreign_court_guest = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_former_concubine', description: 'Iterate through all former concubines. Not persisted past death', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_former_concubine = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_former_concubinist', description: 'Iterate through all former concubinists. Not persisted past death', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_former_concubinist = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_former_spouse', description: 'Iterate through all former spouses', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_former_spouse = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_general_councillor', description: 'Iterate through all councillors that are not related to a skill', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_general_councillor = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_heir', description: 'Heirs of the scoped character', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_heir = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_heir_title', description: 'Iterate through all titles the scoped character is heir to', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_heir_title = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_held_title', description: 'Iterate through all held landed titles. Optionally specify a tier filter', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "any/every/ordered/random_held_title = { title_tier >= county }\nordered_held_title = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_hired_mercenary', description: 'Iterate through all hired mercenary companies', supportedScopes: ['character'], supportedTargets: ['mercenary_company'], outputScope: 'mercenary_company', isIterator: true, syntax: "ordered_hired_mercenary = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_home_court_hostage', description: 'Iterate through all hostages currently abroad', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_home_court_hostage = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_hooked_character', description: 'Iterate through all characters this character has a hook on', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_hooked_character = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_hostile_raider', description: 'Iterate through anyone the character is hostile to due to their top-liege\'s realm having been raided', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_hostile_raider = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_intrigue_councillor', description: 'Iterate through all intrigue-based councillors', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_intrigue_councillor = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_invited_activity', description: 'Iterate through all activities a character has been invited to', supportedScopes: ['character'], supportedTargets: ['activity'], outputScope: 'activity', isIterator: true, syntax: "ordered_invited_activity = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_knight', description: 'Iterate through all knights', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_knight = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_known_secret', description: 'Iterate through all secrets known by the character', supportedScopes: ['character'], supportedTargets: ['secret'], outputScope: 'secret', isIterator: true, syntax: "ordered_known_secret = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_land_neighboring_realm_with_tributaries', description: 'A realm with a different top liege neighboring the realm of the scope character\'s top liege; switches to the realm\'s top title. Can be based on borders a day or two out of date. Includes land borders extended due to tributaries.', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_land_neighboring_realm_with_tributaries = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_land_neighboring_realm_with_tributaries_owner', description: 'A realm with a different top liege neighboring the realm of the scope character\'s top liege; switches to the holder of the realm. Can be based on borders a day or two out of date. Includes land borders extended due to tributaries.', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_land_neighboring_realm_with_tributaries_owner = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_learning_councillor', description: 'Iterate through all learning-based councillors', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_learning_councillor = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_liege_or_above', description: 'Iterate through all lieges above a character (skipping the character themselves)', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_liege_or_above = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_maa_regiment', description: 'Iterate through all MaA regiments', supportedScopes: ['character'], supportedTargets: ['regiment'], outputScope: 'regiment', isIterator: true, syntax: "ordered_maa_regiment = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_martial_councillor', description: 'Iterate through all martial-based councillors', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_martial_councillor = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_memory', description: 'Iterate through all memories of a character', supportedScopes: ['character'], supportedTargets: ['character_memory'], outputScope: 'character_memory', isIterator: true, syntax: "Optionally specify a memory type filter\nany_memory = { memory_type = completed_rites_of_passage }\nordered_memory = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['any_memory', 'order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_neighboring_and_across_water_realm_owner', description: 'A sub-realm or realm bordering the scope character\'s realm (including across water). Returns counts and above.', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_neighboring_and_across_water_realm_owner = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_neighboring_and_across_water_realm_same_rank_owner', description: 'A sub-realm or realm bordering the scope character\'s realm (including across water) and has the same rank as the scope character (look for lieges of he owner of the land if necessary)', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_neighboring_and_across_water_realm_same_rank_owner = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_neighboring_and_across_water_top_liege_realm', description: 'A realm with a different top liege neighboring the realm of the scope character\'s top liege (including across water); switches to the realm\'s top title. Can be based on borders a day or two out of date', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_neighboring_and_across_water_top_liege_realm = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_neighboring_and_across_water_top_liege_realm_owner', description: 'A realm with a different top liege neighboring the realm of the scope character\'s top liege (including across water); switches to the holder of the realm. Can be based on borders a day or two out of date', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_neighboring_and_across_water_top_liege_realm_owner = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_neighboring_and_across_water_top_suzerain_realm', description: 'A realm with a different top suzerain neighboring the realm of the scope character\'s top suzerain (including across water); switches to the realm\'s top title. Can be based on borders a day or two out of date', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_neighboring_and_across_water_top_suzerain_realm = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_neighboring_and_across_water_top_suzerain_realm_owner', description: 'A realm with a different top suzerain neighboring the realm of the scope character\'s top suzerain (including across water); switches to the holder of the realm. Can be based on borders a day or two out of date', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_neighboring_and_across_water_top_suzerain_realm_owner = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_neighboring_realm_owner', description: 'A sub-realm or realm bordering the scope character\'s realm. Returns counts and above.', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_neighboring_realm_owner = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_neighboring_realm_same_rank_owner', description: 'A sub-realm or realm bordering the scope character\'s realm and has the same rank as the scope character (look for lieges of he owner of the land if necessary)', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_neighboring_realm_same_rank_owner = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_neighboring_realm_with_tributaries_owner', description: 'A realm with a different top liege neighboring the realm of the scope character\'s top liege; switches to the holder of the realm. Can be based on borders a day or two out of date. Includes land and water borders extended by including tributaries.', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_neighboring_realm_with_tributaries_owner = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_neighboring_top_liege_realm', description: 'A realm with a different top liege neighboring the realm of the scope character\'s top liege; switches to the realm\'s top title. Can be based on borders a day or two out of date', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_neighboring_top_liege_realm = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_neighboring_top_liege_realm_owner', description: 'A realm with a different top liege neighboring the realm of the scope character\'s top liege; switches to the holder of the realm. Can be based on borders a day or two out of date', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_neighboring_top_liege_realm_owner = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_neighboring_top_suzerain_realm', description: 'A realm with a different top suzerain neighboring the realm of the scope character\'s top suzerain; switches to the realm\'s top title. Can be based on borders a day or two out of date', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_neighboring_top_suzerain_realm = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_neighboring_top_suzerain_realm_owner', description: 'A realm with a different top suzerain neighboring the realm of the scope character\'s top suzerain; switches to the holder of the realm. Can be based on borders a day or two out of date', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_neighboring_top_suzerain_realm_owner = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_noble_family', description: 'Iterate through all noble family titles in the realm of scoped character.', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "If the character is not independent this will return an empty list.\nordered_noble_family = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_opposite_sex_spouse_candidate', description: 'Iterate through all the spouse candidates of the opposite sex of a character.', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "WARNING: THIS IS VERY SLOW DO NOT DO IT OFTEN.\nordered_opposite_sex_spouse_candidate = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_owned_story', description: 'Iterate through all owned stories for a character', supportedScopes: ['character'], supportedTargets: ['story'], outputScope: 'story', isIterator: true, syntax: "Optionally specify a story type filter\nany_owned_story = { type = story_cycle_pet_cat }\nordered_owned_story = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['any_owned_story', 'order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_parent', description: 'Iterate through all (both) parents', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_parent = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_patroned_holy_order', description: 'Iterate through all holy orders that the scoped character is a patron of', supportedScopes: ['character'], supportedTargets: ['holy_order'], outputScope: 'holy_order', isIterator: true, syntax: "ordered_patroned_holy_order = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_personal_claimed_artifact', description: 'Iterate through all personally claimed artifacts of the scoped character', supportedScopes: ['character'], supportedTargets: ['artifact'], outputScope: 'artifact', isIterator: true, syntax: "ordered_personal_claimed_artifact = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_pinned_character', description: 'Iterate through characters this player has pinned', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_pinned_character = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_pinning_character', description: 'Iterate through characters whose player has this character pinned', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_pinning_character = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_played_character', description: 'Iterate through all characters the player playing this character has played. Matches the game over legacy, except for excluding the currently played character', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_played_character = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_player_heir', description: 'Iterate through player heirs, capped at the first 10', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_player_heir = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_player_legend_library', description: 'Get all legends in a player character library.', supportedScopes: ['character'], supportedTargets: ['legend'], outputScope: 'legend', isIterator: true, syntax: "ordered_player_legend_library = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_pool_guest', description: 'Iterate through all guests visiting the court from the pool (in contrast to foreign_court_guest they don\'t have a liege)', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_pool_guest = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_potential_marriage_option', description: 'Iterate through all potential selectable marriage or betrohed options', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_potential_marriage_option = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_powerful_family', description: 'Iterate through all powerful families in this character\'s realm.', supportedScopes: ['character'], supportedTargets: ['dynasty_house'], outputScope: 'dynasty_house', isIterator: true, syntax: "If the character is not independent this will return an empty list.\nordered_powerful_family = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_powerful_vassal', description: 'Iterate through the all powerful vassals of a character', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_powerful_vassal = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_pretender_title', description: 'Iterate through all landed titles character is pretender to', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_pretender_title = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_primary_war_enemy', description: 'Iterate through all primary war enemies', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_primary_war_enemy = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_prisoner', description: 'Iterate through all prisoners', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_prisoner = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_prowess_councillor', description: 'Iterate through all prowess-based councillors', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_prowess_councillor = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_raid_target', description: 'Iterate through anyone the character is hostile to due to having raided them. Only returns top lieges', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_raid_target = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_realm_border_county', description: 'Iterate through all counties that are on the edge of your realm bordering a different neighboring realm.', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_realm_border_county = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_realm_county', description: 'Iterate through all counties in the realm. Based on top liege', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_realm_county = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_realm_de_jure_duchy', description: 'Iterate through all de jure duchies that have at least one county in the realm. Based on top liege', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_realm_de_jure_duchy = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_realm_de_jure_empire', description: 'Iterate through all de jure empire that have at least one county in the realm. Based on top liege', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_realm_de_jure_empire = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_realm_de_jure_kingdom', description: 'Iterate through all de jure kingdom that have at least one county in the realm. Based on top liege', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_realm_de_jure_kingdom = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_realm_province', description: 'Iterate through all realm provinces of a character', supportedScopes: ['character'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, syntax: "ordered_realm_province = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_relation', description: 'Iterate through scripted relations of a given type or multiple types, if someone is multiple relations they will only be in the list once', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_relation = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_same_sex_spouse_candidate', description: 'Iterate through all the spouse candidates of the same sex of a character.', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "WARNING: THIS IS VERY SLOW DO NOT DO IT OFTEN.\nordered_same_sex_spouse_candidate = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_scheme', description: 'Iterate through all schemes owned by the character', supportedScopes: ['character'], supportedTargets: ['scheme'], outputScope: 'scheme', isIterator: true, syntax: "Optionally specify a type filter\nrandom_scheme = { type = befriend }\nordered_scheme = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['random_scheme', 'order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_secret', description: 'Iterate through all secrets of the character', supportedScopes: ['character'], supportedTargets: ['secret'], outputScope: 'secret', isIterator: true, syntax: "Optionally specify a secret type filter\nrandom_secret = { type = secret_lover }\nordered_secret = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['random_secret', 'order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_sibling', description: 'Iterate through all siblings', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_sibling = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_sponsored_inspiration', description: 'Iterate through all sponsored inspirations', supportedScopes: ['character'], supportedTargets: ['inspiration'], outputScope: 'inspiration', isIterator: true, syntax: "ordered_sponsored_inspiration = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_spouse', description: 'Iterate through all spouses', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_spouse = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_spouse_candidate', description: 'Iterate through all the spouse candidates of a character.', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "WARNING: THIS IS VERY SLOW DO NOT DO IT OFTEN.\nordered_spouse_candidate = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_stewardship_councillor', description: 'Iterate through all stewardship-based councillors', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_stewardship_councillor = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_sub_realm_barony', description: 'Iterate through all baronies in sub-realm, counting only titles that either hold land or have dejure vassals that hold land.', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_sub_realm_barony = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_sub_realm_county', description: 'Iterate through all counties in sub-realm, counting only titles that either hold land or have dejure vassals that hold land.', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_sub_realm_county = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_sub_realm_duchy', description: 'Iterate through all duchies in sub-realm, counting only titles that either hold land or have dejure vassals that hold land.', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_sub_realm_duchy = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_sub_realm_empire', description: 'Iterate through all empires in sub-realm, counting only titles that either hold land or have dejure vassals that hold land.', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_sub_realm_empire = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_sub_realm_kingdom', description: 'Iterate through all kingdoms in sub-realm, counting only titles that either hold land or have dejure vassals that hold land.', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_sub_realm_kingdom = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_sub_realm_title', description: 'Iterate through all titles in sub-realm, counting only titles that either hold land or have dejure vassals that hold land.', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_sub_realm_title = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_subject', description: 'Iterate through all vassals and tributaries', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_subject = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_succession_appointment_invested_candidate', description: 'Iterate through all candidates supported by the scoped investor character for any title', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "It may contain people outside of investor's top realm or no longer valid for appointment\nordered_succession_appointment_invested_candidate = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_succession_appointment_invested_title', description: 'Iterate through all titles that has candidates supported by the scoped investor', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "It may contain titles outside of investor's top realm, and so invalid for appointment,\nand candidates may be already dead\nordered_succession_appointment_invested_title = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_targeting_faction', description: 'Iterate through all factions targeting the scope character', supportedScopes: ['character'], supportedTargets: ['faction'], outputScope: 'faction', isIterator: true, syntax: "Optionally specify a faction type filter\nany_targeting_faction = { faction_type = independence_faction }\nordered_targeting_faction = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['any_targeting_faction', 'order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_targeting_scheme', description: 'Iterate through all schemes targeting the character', supportedScopes: ['character'], supportedTargets: ['scheme'], outputScope: 'scheme', isIterator: true, syntax: "ordered_targeting_scheme = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_targeting_secret', description: 'Iterate through all secrets that target the specified scope', supportedScopes: ['character'], supportedTargets: ['secret'], outputScope: 'secret', isIterator: true, syntax: "ordered_targeting_secret = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_tax_collector', description: 'Iterates through all Tax Collectors employed by the scoped character', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_tax_collector = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_tax_collector_vassal', description: 'Iterates through all Vassals the scoped Character is the Tax Collector for', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_tax_collector_vassal = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_tax_slot', description: 'Iterates through all Tax Slots the scoped character has', supportedScopes: ['character'], supportedTargets: ['tax_slot'], outputScope: 'tax_slot', isIterator: true, syntax: "ordered_tax_slot = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_top_realm_border_county', description: 'Iterate through all counties that are on the edge of your realm bordering a different neighboring top realm.', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_top_realm_border_county = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_traveling_family_member', description: 'Iterate though all characters that should travel with the scoped one (when moving between courts for instance); includes the scoped character', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_traveling_family_member = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_tributary', description: 'Iterate through all tributaries', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_tributary = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_truce_holder', description: 'Iterate through all characters that have a truce on this character', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_truce_holder = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_truce_target', description: 'Iterate through all characters this character has a truce on', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_truce_target = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_unassigned_taxpayers', description: 'Iterates through all unassigned taxpayers for scoped Character', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_unassigned_taxpayers = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_unspent_known_secret', description: 'Iterate through all unspent secrets known by the character', supportedScopes: ['character'], supportedTargets: ['secret'], outputScope: 'secret', isIterator: true, syntax: "ordered_unspent_known_secret = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_vassal', description: 'Iterate through all DIRECT vassals', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "Optionally specify a vassal stance filter\nany_vassal = { vassal_stance = parochial }\nordered_vassal = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['any_vassal', 'order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_vassal_or_below', description: 'Iterate through ALL vassals, not just direct vassals', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "Optionally specify a vassal stance filter\nany_vassal_or_below = { vassal_stance = parochial }\nordered_vassal_or_below = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['any_vassal_or_below', 'order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_war_ally', description: 'Iterate through all direct war allies', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_war_ally = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_war_enemy', description: 'Iterate through all direct war enemies', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_war_enemy = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_warden_hostage', description: 'Iterate through all hostages having this warden', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_warden_hostage = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'overlord_contract_set_obligation_level', description: 'change the obligation level of the scoped character\'s overlord contract', supportedScopes: ['character'], syntax: "vassal_contract_set_obligation_level = { type = name level = 1 } # index to obligation level\nvassal_contract_set_obligation_level = { type = name level = feudal_obligation_low }\nvassal_contract_set_obligation_level = { type = name level = scope:obligation }", parameters: ['vassal_contract_set_obligation_level'] },
  { name: 'pay_gold_to_treasury', description: 'the scoped character pays gold to the target character receiving treasury', supportedScopes: ['character'], syntax: "pay_gold_to_treasury = { target = X value = Y }" },
  { name: 'pay_herd', description: 'the scoped character pays herd to the target character', supportedScopes: ['character'], syntax: "pay_herd = { target = X value = Y }" },
  { name: 'pay_long_term_gold', description: 'the scope character pays gold to the target character, pay_long_term_gold = { target = X gold = Y } (from AI budget category \'long term\' first, then rest)', supportedScopes: ['character'] },
  { name: 'pay_long_term_income', description: 'the scope character immediately pays gold corresponding to their income to the target character, pay_long_term_income = { target = X days/months/years = Y } (AI budget \'long term\' first, then rest)', supportedScopes: ['character'] },
  { name: 'pay_long_term_treasury', description: 'the scope character pays treasury to the target character, pay_long_term_treasury = { target = X treasury = Y } (from AI budget category \'long term\' first, then rest). If target character does not have treasury, they will receive gold instead.', supportedScopes: ['character'] },
  { name: 'pay_long_term_treasury_income', description: 'the scope character immediately pays treasury corresponding to their income to the target character, pay_long_term_treasury_income = { target = X days/months/years = Y } (AI budget \'long term\' first, then rest)', supportedScopes: ['character'] },
  { name: 'pay_reserved_gold', description: 'the scope character pays gold to the target character, pay_reserved_gold = { target = X gold = Y } (from AI budget category \'reserved\' first, then rest)', supportedScopes: ['character'] },
  { name: 'pay_reserved_income', description: 'the scope character immediately pays gold corresponding to their income to the target character, pay_reserved_income = { target = X days/months/years = Y } (AI budget \'reserved\' first, then rest)', supportedScopes: ['character'] },
  { name: 'pay_reserved_treasury', description: 'the scope character pays treasury to the target character, pay_reserved_treasury = { target = X treasury = Y } (from AI budget category \'reserved\' first, then rest). If target character does not have treasury, they will receive gold instead.', supportedScopes: ['character'] },
  { name: 'pay_reserved_treasury_income', description: 'the scope character immediately pays treasury corresponding to their income to the target character, pay_reserved_treasury_income = { target = X days/months/years = Y } (AI budget \'reserved\' first, then rest)', supportedScopes: ['character'] },
  { name: 'pay_short_term_gold', description: 'the scope character pays gold to the target character, pay_short_term_gold = { target = X gold = Y } (from AI budget category \'short term\' first, then rest)', supportedScopes: ['character'] },
  { name: 'pay_short_term_income', description: 'the scope character immediately pays gold corresponding to their income to the target character, pay_short_term_income = { target = X days/months/years = Y } (AI budget \'short term\' first, then rest)', supportedScopes: ['character'] },
  { name: 'pay_short_term_treasury', description: 'the scope character pays treasury to the target character, pay_short_term_treasury = { target = X treasury = Y } (from AI budget category \'short term\' first, then rest). If target character does not have treasury, they will receive gold instead.', supportedScopes: ['character'] },
  { name: 'pay_short_term_treasury_income', description: 'the scope character immediately pays treasury corresponding to their income to the target character, pay_short_term_treasury_income = { target = X days/months/years = Y } (AI budget \'short term\' first, then rest)', supportedScopes: ['character'] },
  { name: 'pay_treasury', description: 'The scoped character pays treasury to the target character. If target character does not have treasury, they will receive gold instead.', supportedScopes: ['character'], syntax: "Takes from the 'short_term' budget for treasury.\nusage:\npayer_character = {\npay_treasury = {\ntarget = X value = Y\n}\n}", parameters: ['payer_character', 'target'] },
  { name: 'pay_treasury_or_gold', description: 'the scoped character pays treasury if exists, otherwise gold', supportedScopes: ['character'], syntax: "the target character receives treasury if exists, otherwise gold\npay_treasury_or_gold = { target = X value = Y }" },
  { name: 'pay_treasury_to_gold', description: 'the scoped character pays treasury to the target character receiving gold', supportedScopes: ['character'], syntax: "pay_treasury_to_gold = { target = X value = Y }" },
  { name: 'pay_war_chest_gold', description: 'the scope character pays gold to the target character, pay_war_chest_gold = { target = X gold = Y } (from AI budget category \'war chest\' first, then rest)', supportedScopes: ['character'] },
  { name: 'pay_war_chest_income', description: 'the scope character immediately pays gold corresponding to their income to the target character, pay_war_chest_income = { target = X days/months/years = Y } (AI budget \'war chest\' first, then rest)', supportedScopes: ['character'] },
  { name: 'pay_war_chest_treasury', description: 'the scope character pays treasury to the target character, pay_war_chest_treasury = { target = X treasury = Y } (from AI budget category \'war chest\' first, then rest). If target character does not have treasury, they will receive gold instead.', supportedScopes: ['character'] },
  { name: 'pay_war_chest_treasury_income', description: 'the scope character immediately pays treasury corresponding to their income to the target character, pay_war_chest_treasury_income = { target = X days/months/years = Y } (AI budget \'war chest\' first, then rest)', supportedScopes: ['character'] },
  { name: 'play_music_cue', description: 'Plays the specified music cue.', supportedScopes: ['character'] },
  { name: 'play_sound_effect', description: 'Plays the specified sound effect.', supportedScopes: ['character'] },
  { name: 'populate_task_contracts_for_area', description: 'Populate area around location with task contracts up to specified amount', supportedScopes: ['character'], syntax: "populate_task_contracts_for_area = {\nlocation = scope:province\namount = { value = 5 }\ngroup = { rescue assasination gardening }\n}", parameters: ['location', 'amount', 'group'] },
  { name: 'random_acclaimed_knight', description: 'Iterate through all acclaimed knights employed by a given character', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_acclaimed_knight = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_accolade', description: 'Iterate through all ( active and inactive ) Accolades of a given liege character\'s Acclaimed Knights', supportedScopes: ['character'], supportedTargets: ['accolade'], outputScope: 'accolade', isIterator: true, syntax: "random_accolade = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_active_accolade', description: 'Iterate through all active Accolades of a given liege character\'s Acclaimed Knights', supportedScopes: ['character'], supportedTargets: ['accolade'], outputScope: 'accolade', isIterator: true, syntax: "Optionally specify an accolade parameter filter\nany_active_accolade = { accolade_parameter = accolade_organize_army_bonus }\nrandom_active_accolade = { limit = { <triggers> } (optional) weight = { mtth } <effects> }", parameters: ['any_active_accolade'] },
  { name: 'random_alert_creatable_title', description: 'Iterate through all titles that can be created by the character. (only for alerts)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_alert_creatable_title = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_alert_usurpable_title', description: 'Iterate through all titles that can be usurped by the character. (only for alerts)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_alert_usurpable_title = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_ally', description: 'Iterate through all allies', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_ally = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_ancestor', description: 'Iterate through all the ancestors of the scope character up to 5 generations', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_ancestor = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_army', description: 'Iterate through all armies', supportedScopes: ['character'], supportedTargets: ['army'], outputScope: 'army', isIterator: true, syntax: "random_army = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_available_task_contract', description: 'Iterate through all task contracts of location of root province', supportedScopes: ['character'], supportedTargets: ['task_contract'], outputScope: 'task_contract', isIterator: true, syntax: "random_available_task_contract = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_character_active_contract', description: 'Gets all accepted task contracts of the root character', supportedScopes: ['character'], supportedTargets: ['task_contract'], outputScope: 'task_contract', isIterator: true, syntax: "Optionally specify a contract type filter\nany_character_active_contract = { task_contract_type = laamp_raid_contract }\nrandom_character_active_contract = { limit = { <triggers> } (optional) weight = { mtth } <effects> }", parameters: ['any_character_active_contract'] },
  { name: 'random_character_artifact', description: 'Iterate through all artifacts in a given characters inventory', supportedScopes: ['character'], supportedTargets: ['artifact'], outputScope: 'artifact', isIterator: true, syntax: "random_character_artifact = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_character_epidemic', description: 'Gets epidemics affecting the scoped character', supportedScopes: ['character'], supportedTargets: ['epidemic'], outputScope: 'epidemic', isIterator: true, syntax: "random_character_epidemic = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_character_situation', description: 'Iterate through all situations that a character is participating in', supportedScopes: ['character'], supportedTargets: ['situation'], outputScope: 'situation', isIterator: true, syntax: "random_character_situation = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_character_struggle', description: 'Iterate through all struggles that character is involved in. Optional: Narrow down the involvement status *_chracter_struggle = { involvement = involved | interloper }', supportedScopes: ['character'], supportedTargets: ['struggle'], outputScope: 'struggle', isIterator: true, syntax: "random_character_struggle = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_character_task_contract', description: 'Gets all task contracts of the scoped character', supportedScopes: ['character'], supportedTargets: ['task_contract'], outputScope: 'task_contract', isIterator: true, syntax: "Optionally specify a contract type filter\nany_character_task_contract = { task_contract_type = laamp_raid_contract }\nrandom_character_task_contract = { limit = { <triggers> } (optional) weight = { mtth } <effects> }", parameters: ['any_character_task_contract'] },
  { name: 'random_character_to_title_neighboring_and_across_water_county', description: 'Scopes from a character to a neighboring county (incl. across water, looking trough the de Jure lieges)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_character_to_title_neighboring_and_across_water_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_character_to_title_neighboring_and_across_water_duchy', description: 'Scopes from a character to a neighboring duchy (incl. across water, looking trough the de Jure lieges)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_character_to_title_neighboring_and_across_water_duchy = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_character_to_title_neighboring_and_across_water_empire', description: 'Scopes from a character to a neighboring empire (incl. across water, looking trough the de Jure lieges)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_character_to_title_neighboring_and_across_water_empire = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_character_to_title_neighboring_and_across_water_kingdom', description: 'Scopes from a character to a neighboring kingdom (incl. across water, looking trough the de Jure lieges)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_character_to_title_neighboring_and_across_water_kingdom = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_character_to_title_neighboring_county', description: 'Scopes from a character to a neighboring county (looking trough the de Jure lieges)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_character_to_title_neighboring_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_character_to_title_neighboring_duchy', description: 'Scopes from a character to a neighboring duchy (looking trough the de Jure lieges)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_character_to_title_neighboring_duchy = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_character_to_title_neighboring_empire', description: 'Scopes from a character to a neighboring empire (looking trough the de Jure lieges)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_character_to_title_neighboring_empire = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_character_to_title_neighboring_kingdom', description: 'Scopes from a character to a neighboring kingdom (looking trough the de Jure lieges)', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_character_to_title_neighboring_kingdom = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_character_trait', description: 'Iterate through all traits a character has', supportedScopes: ['character'], supportedTargets: ['trait'], outputScope: 'trait', isIterator: true, syntax: "random_character_trait = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_character_war', description: 'Wars of the scoped character', supportedScopes: ['character'], supportedTargets: ['war'], outputScope: 'war', isIterator: true, syntax: "random_character_war = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_child', description: 'Iterate through all children', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_child = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_claim', description: 'Iterate through the titles of all claims held by a character; parameters: explicit = yes/no/all pressed = yes/no/all', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_claim = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_claimed_artifact', description: 'Iterate through all claimed artifacts of the scoped character', supportedScopes: ['character'], supportedTargets: ['artifact'], outputScope: 'artifact', isIterator: true, syntax: "random_claimed_artifact = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_close_family_member', description: 'Iterate through all the close family [father, mother, siblings, children, grandparents]', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_close_family_member = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_close_or_extended_family_member', description: 'Iterate through all the close and extended relatives [father, mother, siblings, children, grandparents, uncles/aunts, nephew/niece, cousins]', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_close_or_extended_family_member = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_concubine', description: 'Iterate through all concubines', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_concubine = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_consort', description: 'Iterate through all consorts (concubines and spouses)', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_consort = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_contact', description: 'Iterate through all contact characters of the root character', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_contact = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_councillor', description: 'Iterate through all councillors', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_councillor = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_court_position_candidate', description: 'Iterate through all valid candidates for a court position type.', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "*_court_position_candidate = {\ncourt_position = bodyguard_court_position\nOR\ncourt_position = scope:my_scoped_court_position_type\n...\n}\nrandom_court_position_candidate = { limit = { <triggers> } (optional) weight = { mtth } <effects> }", parameters: ['court_position'] },
  { name: 'random_court_position_employer', description: 'Iterates through all characters that employ the scoped character in any court position.', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_court_position_employer = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_court_position_holder', description: 'Iterates through all characters employed by the scoped character in the target court position.', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_court_position_holder = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_courtier', description: 'Iterate through all courtiers', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_courtier = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_courtier_away', description: 'Iterate through all courtiers that are away', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_courtier_away = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_courtier_or_guest', description: 'Iterate through all courtiers and guests (pool and foreign court guests)', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_courtier_or_guest = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_de_jure_claim', description: 'Iterate through all de jure claims for a character', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_de_jure_claim = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_diarchy_succession_character', description: 'Iterate through all character in the diarchy line of succession.If there\'s no active diarchy or active one doesn\'t have succession,it iterates over regency candidates', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_diarchy_succession_character = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_diplomacy_councillor', description: 'Iterate through all diplomacy-based councillors', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_diplomacy_councillor = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_directly_owned_province', description: 'Iterate through all directly owned provinces', supportedScopes: ['character'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, syntax: "random_directly_owned_province = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_election_title', description: 'Iterate through all titles the scoped character can vote on', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_election_title = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_equipped_character_artifact', description: 'Iterate through all equipped artifacts in a given characters inventory', supportedScopes: ['character'], supportedTargets: ['artifact'], outputScope: 'artifact', isIterator: true, syntax: "random_equipped_character_artifact = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_extended_family_member', description: 'Iterate through all the extended family [uncles/aunts, nephew/niece, cousins]', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_extended_family_member = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_foreign_court_guest', description: 'Iterate through all guests visiting from another court (in contrast to pool_guest they have a liege)', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_foreign_court_guest = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_former_concubine', description: 'Iterate through all former concubines. Not persisted past death', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_former_concubine = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_former_concubinist', description: 'Iterate through all former concubinists. Not persisted past death', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_former_concubinist = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_former_spouse', description: 'Iterate through all former spouses', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_former_spouse = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_general_councillor', description: 'Iterate through all councillors that are not related to a skill', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_general_councillor = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_heir', description: 'Heirs of the scoped character', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_heir = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_heir_title', description: 'Iterate through all titles the scoped character is heir to', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_heir_title = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_held_title', description: 'Iterate through all held landed titles. Optionally specify a tier filter', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "any/every/ordered/random_held_title = { title_tier >= county }\nrandom_held_title = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_hired_mercenary', description: 'Iterate through all hired mercenary companies', supportedScopes: ['character'], supportedTargets: ['mercenary_company'], outputScope: 'mercenary_company', isIterator: true, syntax: "random_hired_mercenary = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_home_court_hostage', description: 'Iterate through all hostages currently abroad', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_home_court_hostage = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_hooked_character', description: 'Iterate through all characters this character has a hook on', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_hooked_character = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_hostile_raider', description: 'Iterate through anyone the character is hostile to due to their top-liege\'s realm having been raided', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_hostile_raider = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_intrigue_councillor', description: 'Iterate through all intrigue-based councillors', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_intrigue_councillor = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_invited_activity', description: 'Iterate through all activities a character has been invited to', supportedScopes: ['character'], supportedTargets: ['activity'], outputScope: 'activity', isIterator: true, syntax: "random_invited_activity = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_knight', description: 'Iterate through all knights', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_knight = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_known_secret', description: 'Iterate through all secrets known by the character', supportedScopes: ['character'], supportedTargets: ['secret'], outputScope: 'secret', isIterator: true, syntax: "random_known_secret = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_land_neighboring_realm_with_tributaries', description: 'A realm with a different top liege neighboring the realm of the scope character\'s top liege; switches to the realm\'s top title. Can be based on borders a day or two out of date. Includes land borders extended due to tributaries.', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_land_neighboring_realm_with_tributaries = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_land_neighboring_realm_with_tributaries_owner', description: 'A realm with a different top liege neighboring the realm of the scope character\'s top liege; switches to the holder of the realm. Can be based on borders a day or two out of date. Includes land borders extended due to tributaries.', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_land_neighboring_realm_with_tributaries_owner = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_learning_councillor', description: 'Iterate through all learning-based councillors', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_learning_councillor = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_liege_or_above', description: 'Iterate through all lieges above a character (skipping the character themselves)', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_liege_or_above = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_maa_regiment', description: 'Iterate through all MaA regiments', supportedScopes: ['character'], supportedTargets: ['regiment'], outputScope: 'regiment', isIterator: true, syntax: "random_maa_regiment = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_martial_councillor', description: 'Iterate through all martial-based councillors', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_martial_councillor = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_memory', description: 'Iterate through all memories of a character', supportedScopes: ['character'], supportedTargets: ['character_memory'], outputScope: 'character_memory', isIterator: true, syntax: "Optionally specify a memory type filter\nany_memory = { memory_type = completed_rites_of_passage }\nrandom_memory = { limit = { <triggers> } (optional) weight = { mtth } <effects> }", parameters: ['any_memory'] },
  { name: 'random_neighboring_and_across_water_realm_owner', description: 'A sub-realm or realm bordering the scope character\'s realm (including across water). Returns counts and above.', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_neighboring_and_across_water_realm_owner = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_neighboring_and_across_water_realm_same_rank_owner', description: 'A sub-realm or realm bordering the scope character\'s realm (including across water) and has the same rank as the scope character (look for lieges of he owner of the land if necessary)', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_neighboring_and_across_water_realm_same_rank_owner = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_neighboring_and_across_water_top_liege_realm', description: 'A realm with a different top liege neighboring the realm of the scope character\'s top liege (including across water); switches to the realm\'s top title. Can be based on borders a day or two out of date', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_neighboring_and_across_water_top_liege_realm = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_neighboring_and_across_water_top_liege_realm_owner', description: 'A realm with a different top liege neighboring the realm of the scope character\'s top liege (including across water); switches to the holder of the realm. Can be based on borders a day or two out of date', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_neighboring_and_across_water_top_liege_realm_owner = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_neighboring_and_across_water_top_suzerain_realm', description: 'A realm with a different top suzerain neighboring the realm of the scope character\'s top suzerain (including across water); switches to the realm\'s top title. Can be based on borders a day or two out of date', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_neighboring_and_across_water_top_suzerain_realm = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_neighboring_and_across_water_top_suzerain_realm_owner', description: 'A realm with a different top suzerain neighboring the realm of the scope character\'s top suzerain (including across water); switches to the holder of the realm. Can be based on borders a day or two out of date', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_neighboring_and_across_water_top_suzerain_realm_owner = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_neighboring_realm_owner', description: 'A sub-realm or realm bordering the scope character\'s realm. Returns counts and above.', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_neighboring_realm_owner = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_neighboring_realm_same_rank_owner', description: 'A sub-realm or realm bordering the scope character\'s realm and has the same rank as the scope character (look for lieges of he owner of the land if necessary)', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_neighboring_realm_same_rank_owner = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_neighboring_realm_with_tributaries_owner', description: 'A realm with a different top liege neighboring the realm of the scope character\'s top liege; switches to the holder of the realm. Can be based on borders a day or two out of date. Includes land and water borders extended by including tributaries.', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_neighboring_realm_with_tributaries_owner = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_neighboring_top_liege_realm', description: 'A realm with a different top liege neighboring the realm of the scope character\'s top liege; switches to the realm\'s top title. Can be based on borders a day or two out of date', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_neighboring_top_liege_realm = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_neighboring_top_liege_realm_owner', description: 'A realm with a different top liege neighboring the realm of the scope character\'s top liege; switches to the holder of the realm. Can be based on borders a day or two out of date', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_neighboring_top_liege_realm_owner = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_neighboring_top_suzerain_realm', description: 'A realm with a different top suzerain neighboring the realm of the scope character\'s top suzerain; switches to the realm\'s top title. Can be based on borders a day or two out of date', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_neighboring_top_suzerain_realm = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_neighboring_top_suzerain_realm_owner', description: 'A realm with a different top suzerain neighboring the realm of the scope character\'s top suzerain; switches to the holder of the realm. Can be based on borders a day or two out of date', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_neighboring_top_suzerain_realm_owner = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_noble_family', description: 'Iterate through all noble family titles in the realm of scoped character.', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "If the character is not independent this will return an empty list.\nrandom_noble_family = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_opposite_sex_spouse_candidate', description: 'Iterate through all the spouse candidates of the opposite sex of a character.', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "WARNING: THIS IS VERY SLOW DO NOT DO IT OFTEN.\nrandom_opposite_sex_spouse_candidate = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_owned_story', description: 'Iterate through all owned stories for a character', supportedScopes: ['character'], supportedTargets: ['story'], outputScope: 'story', isIterator: true, syntax: "Optionally specify a story type filter\nany_owned_story = { type = story_cycle_pet_cat }\nrandom_owned_story = { limit = { <triggers> } (optional) weight = { mtth } <effects> }", parameters: ['any_owned_story'] },
  { name: 'random_parent', description: 'Iterate through all (both) parents', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_parent = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_patroned_holy_order', description: 'Iterate through all holy orders that the scoped character is a patron of', supportedScopes: ['character'], supportedTargets: ['holy_order'], outputScope: 'holy_order', isIterator: true, syntax: "random_patroned_holy_order = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_personal_claimed_artifact', description: 'Iterate through all personally claimed artifacts of the scoped character', supportedScopes: ['character'], supportedTargets: ['artifact'], outputScope: 'artifact', isIterator: true, syntax: "random_personal_claimed_artifact = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_pinned_character', description: 'Iterate through characters this player has pinned', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_pinned_character = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_pinning_character', description: 'Iterate through characters whose player has this character pinned', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_pinning_character = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_played_character', description: 'Iterate through all characters the player playing this character has played. Matches the game over legacy, except for excluding the currently played character', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_played_character = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_player_heir', description: 'Iterate through player heirs, capped at the first 10', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_player_heir = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_player_legend_library', description: 'Get all legends in a player character library.', supportedScopes: ['character'], supportedTargets: ['legend'], outputScope: 'legend', isIterator: true, syntax: "random_player_legend_library = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_pool_guest', description: 'Iterate through all guests visiting the court from the pool (in contrast to foreign_court_guest they don\'t have a liege)', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_pool_guest = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_potential_marriage_option', description: 'Iterate through all potential selectable marriage or betrohed options', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_potential_marriage_option = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_powerful_family', description: 'Iterate through all powerful families in this character\'s realm.', supportedScopes: ['character'], supportedTargets: ['dynasty_house'], outputScope: 'dynasty_house', isIterator: true, syntax: "If the character is not independent this will return an empty list.\nrandom_powerful_family = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_powerful_vassal', description: 'Iterate through the all powerful vassals of a character', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_powerful_vassal = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_pretender_title', description: 'Iterate through all landed titles character is pretender to', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_pretender_title = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_primary_war_enemy', description: 'Iterate through all primary war enemies', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_primary_war_enemy = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_prisoner', description: 'Iterate through all prisoners', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_prisoner = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_prowess_councillor', description: 'Iterate through all prowess-based councillors', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_prowess_councillor = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_raid_target', description: 'Iterate through anyone the character is hostile to due to having raided them. Only returns top lieges', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_raid_target = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_realm_border_county', description: 'Iterate through all counties that are on the edge of your realm bordering a different neighboring realm.', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_realm_border_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_realm_county', description: 'Iterate through all counties in the realm. Based on top liege', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_realm_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_realm_de_jure_duchy', description: 'Iterate through all de jure duchies that have at least one county in the realm. Based on top liege', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_realm_de_jure_duchy = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_realm_de_jure_empire', description: 'Iterate through all de jure empire that have at least one county in the realm. Based on top liege', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_realm_de_jure_empire = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_realm_de_jure_kingdom', description: 'Iterate through all de jure kingdom that have at least one county in the realm. Based on top liege', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_realm_de_jure_kingdom = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_realm_province', description: 'Iterate through all realm provinces of a character', supportedScopes: ['character'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, syntax: "random_realm_province = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_relation', description: 'Iterate through scripted relations of a given type or multiple types, if someone is multiple relations they will only be in the list once', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_relation = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_same_sex_spouse_candidate', description: 'Iterate through all the spouse candidates of the same sex of a character.', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "WARNING: THIS IS VERY SLOW DO NOT DO IT OFTEN.\nrandom_same_sex_spouse_candidate = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_scheme', description: 'Iterate through all schemes owned by the character', supportedScopes: ['character'], supportedTargets: ['scheme'], outputScope: 'scheme', isIterator: true, syntax: "Optionally specify a type filter\nrandom_scheme = { type = befriend }\nrandom_scheme = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_secret', description: 'Iterate through all secrets of the character', supportedScopes: ['character'], supportedTargets: ['secret'], outputScope: 'secret', isIterator: true, syntax: "Optionally specify a secret type filter\nrandom_secret = { type = secret_lover }\nrandom_secret = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_sibling', description: 'Iterate through all siblings', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_sibling = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_sponsored_inspiration', description: 'Iterate through all sponsored inspirations', supportedScopes: ['character'], supportedTargets: ['inspiration'], outputScope: 'inspiration', isIterator: true, syntax: "random_sponsored_inspiration = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_spouse', description: 'Iterate through all spouses', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_spouse = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_spouse_candidate', description: 'Iterate through all the spouse candidates of a character.', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "WARNING: THIS IS VERY SLOW DO NOT DO IT OFTEN.\nrandom_spouse_candidate = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_stewardship_councillor', description: 'Iterate through all stewardship-based councillors', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_stewardship_councillor = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_sub_realm_barony', description: 'Iterate through all baronies in sub-realm, counting only titles that either hold land or have dejure vassals that hold land.', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_sub_realm_barony = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_sub_realm_county', description: 'Iterate through all counties in sub-realm, counting only titles that either hold land or have dejure vassals that hold land.', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_sub_realm_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_sub_realm_duchy', description: 'Iterate through all duchies in sub-realm, counting only titles that either hold land or have dejure vassals that hold land.', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_sub_realm_duchy = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_sub_realm_empire', description: 'Iterate through all empires in sub-realm, counting only titles that either hold land or have dejure vassals that hold land.', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_sub_realm_empire = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_sub_realm_kingdom', description: 'Iterate through all kingdoms in sub-realm, counting only titles that either hold land or have dejure vassals that hold land.', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_sub_realm_kingdom = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_sub_realm_title', description: 'Iterate through all titles in sub-realm, counting only titles that either hold land or have dejure vassals that hold land.', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_sub_realm_title = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_subject', description: 'Iterate through all vassals and tributaries', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_subject = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_succession_appointment_invested_candidate', description: 'Iterate through all candidates supported by the scoped investor character for any title', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "It may contain people outside of investor's top realm or no longer valid for appointment\nrandom_succession_appointment_invested_candidate = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_succession_appointment_invested_title', description: 'Iterate through all titles that has candidates supported by the scoped investor', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "It may contain titles outside of investor's top realm, and so invalid for appointment,\nand candidates may be already dead\nrandom_succession_appointment_invested_title = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_targeting_faction', description: 'Iterate through all factions targeting the scope character', supportedScopes: ['character'], supportedTargets: ['faction'], outputScope: 'faction', isIterator: true, syntax: "Optionally specify a faction type filter\nany_targeting_faction = { faction_type = independence_faction }\nrandom_targeting_faction = { limit = { <triggers> } (optional) weight = { mtth } <effects> }", parameters: ['any_targeting_faction'] },
  { name: 'random_targeting_scheme', description: 'Iterate through all schemes targeting the character', supportedScopes: ['character'], supportedTargets: ['scheme'], outputScope: 'scheme', isIterator: true, syntax: "random_targeting_scheme = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_targeting_secret', description: 'Iterate through all secrets that target the specified scope', supportedScopes: ['character'], supportedTargets: ['secret'], outputScope: 'secret', isIterator: true, syntax: "random_targeting_secret = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_tax_collector', description: 'Iterates through all Tax Collectors employed by the scoped character', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_tax_collector = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_tax_collector_vassal', description: 'Iterates through all Vassals the scoped Character is the Tax Collector for', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_tax_collector_vassal = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_tax_slot', description: 'Iterates through all Tax Slots the scoped character has', supportedScopes: ['character'], supportedTargets: ['tax_slot'], outputScope: 'tax_slot', isIterator: true, syntax: "random_tax_slot = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_top_realm_border_county', description: 'Iterate through all counties that are on the edge of your realm bordering a different neighboring top realm.', supportedScopes: ['character'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_top_realm_border_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_traveling_family_member', description: 'Iterate though all characters that should travel with the scoped one (when moving between courts for instance); includes the scoped character', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_traveling_family_member = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_tributary', description: 'Iterate through all tributaries', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_tributary = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_truce_holder', description: 'Iterate through all characters that have a truce on this character', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_truce_holder = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_truce_target', description: 'Iterate through all characters this character has a truce on', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_truce_target = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_unassigned_taxpayers', description: 'Iterates through all unassigned taxpayers for scoped Character', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_unassigned_taxpayers = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_unspent_known_secret', description: 'Iterate through all unspent secrets known by the character', supportedScopes: ['character'], supportedTargets: ['secret'], outputScope: 'secret', isIterator: true, syntax: "random_unspent_known_secret = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_vassal', description: 'Iterate through all DIRECT vassals', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "Optionally specify a vassal stance filter\nany_vassal = { vassal_stance = parochial }\nrandom_vassal = { limit = { <triggers> } (optional) weight = { mtth } <effects> }", parameters: ['any_vassal'] },
  { name: 'random_vassal_or_below', description: 'Iterate through ALL vassals, not just direct vassals', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "Optionally specify a vassal stance filter\nany_vassal_or_below = { vassal_stance = parochial }\nrandom_vassal_or_below = { limit = { <triggers> } (optional) weight = { mtth } <effects> }", parameters: ['any_vassal_or_below'] },
  { name: 'random_war_ally', description: 'Iterate through all direct war allies', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_war_ally = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_war_enemy', description: 'Iterate through all direct war enemies', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_war_enemy = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_warden_hostage', description: 'Iterate through all hostages having this warden', supportedScopes: ['character'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_warden_hostage = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'recalculate_participant_group', description: 'Force-recalculate participation group of a charater in a situation', supportedScopes: ['character'], supportedTargets: ['situation'], syntax: "scope:ruler = {\nrecalculate_participant_group = scope:situation\n}" },
  { name: 'refund_all_perks', description: 'Refunds all perks of the character. Example: refund_all_perks = yes', supportedScopes: ['character'] },
  { name: 'refund_perks', description: 'Refunds all perks of the RHS lifestyle. Example: refund_perks = intrigue_lifestyle', supportedScopes: ['character'] },
  { name: 'release_from_prison', description: 'releases the character from the prison, imprison = X, where X is a boolean value', supportedScopes: ['character'] },
  { name: 'remove_all_character_modifier_instances', description: 'Remove all instances of a modifier from a character', supportedScopes: ['character'], syntax: "remove_all_character_modifier_instances = name" },
  { name: 'remove_all_realm_laws', description: 'Removes all realm laws from the scoped character. This will leave all law groups empty so only do this if you plan to replace them', supportedScopes: ['character'] },
  { name: 'remove_barter_goods', description: 'removes barter goods from a character', supportedScopes: ['character'] },
  { name: 'remove_character_flag', description: 'removes a character flag', supportedScopes: ['character'] },
  { name: 'remove_character_modifier', description: 'Remove a modifier from a character', supportedScopes: ['character'], syntax: "remove_character_modifier = name" },
  { name: 'remove_character_secret_faith', description: 'Removes the characters secret_faith', supportedScopes: ['character'], syntax: "remove_character_secret_faith = yes" },
  { name: 'remove_claim', description: 'removes an explicit (not from a living parent/grand parent) claim', supportedScopes: ['character'], supportedTargets: ['landed_title'] },
  { name: 'remove_concubine', description: 'Removes the target character as a concubine of the scope character', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_courtier_or_guest', description: 'Removes the target character (guest or courtier) from the scope character\'s court', supportedScopes: ['character'], supportedTargets: ['character'], syntax: "scope:host = { remove_courtier_or_guest = scope:guest } # move to pool, staying in same province\nscope:host = {\nremove_courtier_or_guest = {\ncharacter = scope:guest\nnew_location = scope:some_province # optionally specify a new location\n}\n}", parameters: ['character', 'new_location'] },
  { name: 'remove_dead_character_variable', description: 'remove_dead_character_variable = <name>', supportedScopes: ['character'], syntax: "Remove a variable from a dead character." },
  { name: 'remove_decision_cooldown', description: 'Remove the cooldown on taking a decision for the scoped character', supportedScopes: ['character'], supportedTargets: ['decision'], syntax: "remove_decision_cooldown = decision_name" },
  { name: 'remove_from_activity', description: 'remove_from_activity = activity', supportedScopes: ['character'], supportedTargets: ['activity'], syntax: "The scoped character is removed from the target activity" },
  { name: 'remove_hook', description: 'Removes a hook on a character, remove_hook = { target = X, type = Y }, if type is specified, the hook will only be removed if it is of that type', supportedScopes: ['character'] },
  { name: 'remove_interaction_cooldown', description: 'Remove the cooldown on using an interaction for the scoped character', supportedScopes: ['character'], syntax: "remove_interaction_cooldown = interaction_name" },
  { name: 'remove_interaction_cooldown_against', description: 'Remove the cooldown on using an interaction against the target character for the scoped character', supportedScopes: ['character'], syntax: "remove_interaction_cooldown_against = { interaction = interaction_name target = character }" },
  { name: 'remove_localized_text', description: 'Removes a piece of localized text from being stored on the character with a given key, you should do this whenever you are done with the custom text so as to not bloat saves', supportedScopes: ['character'], syntax: "remove_localized_text = key" },
  { name: 'remove_long_term_gold', description: 'removes gold from a character (from AI\'s \'long term\' budget first, then rest)', supportedScopes: ['character'] },
  { name: 'remove_long_term_treasury', description: 'removes treasury from a character (from AI\'s \'long term\' budget first, then rest)', supportedScopes: ['character'] },
  { name: 'remove_nickname', description: 'Removes any nickname from the current character [yes|no]', supportedScopes: ['character'] },
  { name: 'remove_opinion', description: 'Removes a temporary opinion modifier, remove_opinion = { target = X modifier = Y single = Z (no by default) } where X is a character, Y is the opinion modifier, Z tells whether to remove all instances of the modifier or just one', supportedScopes: ['character'] },
  { name: 'remove_perk', description: 'Remove the perk for this character', supportedScopes: ['character'] },
  { name: 'remove_personal_artifact_claim', description: 'Removes a personal claim on the target artifact from the scoped character', supportedScopes: ['character'], supportedTargets: ['artifact'] },
  { name: 'remove_realm_law', description: 'Removes the given law from the scoped character. This will leave the law group empty, so only do this if you\'re getting rid of a law group', supportedScopes: ['character'] },
  { name: 'remove_relation_activity_recurrer', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_relation_antiquarian', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_relation_best_friend', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_relation_blood_brother', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_relation_bully', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_relation_court_physician', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_relation_crush', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_relation_disciple', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_relation_elder', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_relation_event_recurrer', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_relation_favorite_child', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_relation_fellow_disciple', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_relation_flag', description: 'Removed a flag from an existing relation flag = flag_name (declared in scripted_relation) target = other_character relation = scripted_relation', supportedScopes: ['character'] },
  { name: 'remove_relation_friend', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_relation_grudge', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_relation_guardian', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_relation_intrigue_mentor', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_relation_intrigue_student', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_relation_lover', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_relation_mentor', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_relation_nemesis', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_relation_nursed_child', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_relation_oaf', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_relation_old_flame', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_relation_potential_friend', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_relation_potential_hook', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_relation_potential_lover', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_relation_potential_rival', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_relation_rival', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_relation_soldier_friend', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_relation_soulmate', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_relation_student', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_relation_victim', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_relation_ward', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_relation_wedding_bad_fertility', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_relation_wedding_good_fertility', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_relation_wedding_very_bad_fertility', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_relation_wedding_very_good_fertility', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_relation_wet_nurse', description: 'Removes scripted relationship', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'remove_reserved_gold', description: 'removes gold from a character (from AI\'s \'reserved\' budget first, then rest)', supportedScopes: ['character'] },
  { name: 'remove_reserved_treasury', description: 'removes treasury from a character (from AI\'s \'reserved\' budget first, then rest)', supportedScopes: ['character'] },
  { name: 'remove_scheme_cooldown_against', description: 'Remove the cooldown on using a scheme against the target character for the scoped character', supportedScopes: ['character'], syntax: "remove_scheme_cooldown_against = { scheme = scheme_name target = character }" },
  { name: 'remove_short_term_gold', description: 'removes gold from a character (from AI\'s \'short term\' budget first, then rest)', supportedScopes: ['character'] },
  { name: 'remove_short_term_treasury', description: 'removes treasury from a character (from AI\'s \'short term\' budget first, then rest)', supportedScopes: ['character'] },
  { name: 'remove_trait', description: 'Removes a trait from a character. Tooltip will not be shown if the character doesn\'t have the trait.', supportedScopes: ['character'], supportedTargets: ['trait'] },
  { name: 'remove_trait_force_tooltip', description: 'Removes a trait from a character. Tooltip will be shown even if the character doesn\'t have the trait.', supportedScopes: ['character'], supportedTargets: ['trait'] },
  { name: 'remove_treasury', description: 'removes treasury from a character', supportedScopes: ['character'] },
  { name: 'remove_treasury_or_gold', description: 'removes treasury if exists, otherwise gold from character', supportedScopes: ['character'] },
  { name: 'remove_war_chest_gold', description: 'removes gold from a character (from AI\'s \'war chest\' budget first, then rest)', supportedScopes: ['character'] },
  { name: 'remove_war_chest_treasury', description: 'removes treasury from a character (from AI\'s \'war chest\' budget first, then rest)', supportedScopes: ['character'] },
  { name: 'replace_court_position', description: 'Replaces the target character holding target court position within scoped character\'s court with target character', supportedScopes: ['character'], syntax: "recipient = character scope - target character to receive the title\nholder = character scope - target character to revoke the target court position of in favour of recipient\ncourt_position = court position type - court position type to assign the receiver", parameters: ['recipient', 'holder', 'court_position'] },
  { name: 'reset_beneficiary', description: 'The target character stops having a beneficiary. reset_beneficiary = yes', supportedScopes: ['character'] },
  { name: 'return_home', description: 'Start a travel plan for the character to return home, using their current travel plan info if they have any or starting a new travel plan if they do not.', supportedScopes: ['character'], syntax: "Saving this as a scope will not work for player characters if they have to use the planner.\nreturn_home = yes\\no" },
  { name: 'return_hostage', description: 'Release scoped character from hostage and return to home court', supportedScopes: ['character'] },
  { name: 'return_to_court', description: 'Returns the scope character to the employers court.', supportedScopes: ['character'] },
  { name: 'reverse_add_opinion', description: 'Adds a temporary reverse opinion modifier, reverse_add_opinion = { modifier = X days/months/years = Y target = Z }', supportedScopes: ['character'], syntax: "X is a scripted modifier name. Y can be a value or a range \"{ A B }\" If no timeout are specified, the modifier's scripted default timeout will be used." },
  { name: 'revoke_court_position', description: 'Revokes target position from scoped character.', supportedScopes: ['character'], syntax: "court_position = court position type - court position type to revoke from scoped character's court\nrecipient = character - optional - target current holder of position to revoke\nholder = character - optional - same as recipient", parameters: ['court_position', 'recipient', 'holder'] },
  { name: 'scriptedtests_recalculate_character_modifier', description: 'Recalculates the modifier of the scoped character', supportedScopes: ['character'] },
  { name: 'scriptedtests_recalculate_succession', description: 'Recalculates the line of succession of the scoped character', supportedScopes: ['character'] },
  { name: 'send_interface_message', description: 'Sends a message to the player playing the character in the scope and then executes any effects inside.', supportedScopes: ['character'], syntax: "For the message text and tooltip, $EFFECT$ contains the text description of the effects in the past tense.\nAnd $DESC$ contains the text from the desc field.\nsend_interface_message = {\ntype = message_type # default: send_interface_message\ntitle = LOCALIZATION # optional, otherwise takes it from the message type\ndesc = LOCALIZATION # optional, otherwise takes it from the message type\ntooltip = LOCALIZATION # optional, otherwise takes it from the message type\nleft_icon = scope:recipient # optional, character, artifact, title, dynasty, or house\nright_icon = scope:the_title # optional, character, artifact, title, dynasty, or house\n# optional effects...\nadd_dread = 5\nscope:someone = { add_gold = 5 }\n}", parameters: ['type', 'title', 'desc', 'tooltip', 'left_icon', 'right_icon'] },
  { name: 'send_interface_popup', description: 'Sends a message to the player playing the character in the scope and then executes any effects inside.', supportedScopes: ['character'], syntax: "For the message text and tooltip, $EFFECT$ contains the text description of the effects in the past tense.\nAnd $DESC$ contains the text from the desc field.\nsend_interface_popup = {\ntype = message_type # default: send_interface_popup\ntitle = LOCALIZATION # optional, otherwise takes it from the message type\ndesc = LOCALIZATION # optional, otherwise takes it from the message type\ntooltip = LOCALIZATION # optional, otherwise takes it from the message type\nleft_icon = scope:recipient # optional, character, artifact, title, dynasty, or house\nright_icon = scope:the_title # optional, character, artifact, title, dynasty, or house\n# optional effects...\nadd_dread = 5\nscope:someone = { add_gold = 5 }\n}", parameters: ['type', 'title', 'desc', 'tooltip', 'left_icon', 'right_icon'] },
  { name: 'send_interface_toast', description: 'Sends a message to the player playing the character in the scope and then executes any effects inside.', supportedScopes: ['character'], syntax: "For the message text and tooltip, $EFFECT$ contains the text description of the effects in the past tense.\nAnd $DESC$ contains the text from the desc field.\nsend_interface_toast = {\ntype = message_type # default: send_interface_toast\ntitle = LOCALIZATION # optional, otherwise takes it from the message type\ndesc = LOCALIZATION # optional, otherwise takes it from the message type\ntooltip = LOCALIZATION # optional, otherwise takes it from the message type\nleft_icon = scope:recipient # optional, character, artifact, title, dynasty, or house\nright_icon = scope:the_title # optional, character, artifact, title, dynasty, or house\n# optional effects...\nadd_dread = 5\nscope:someone = { add_gold = 5 }\n}", parameters: ['type', 'title', 'desc', 'tooltip', 'left_icon', 'right_icon'] },
  { name: 'set_absolute_country_control', description: 'Sets if this character has absolute country control, unlock_character_movement = yes/no/boolean event target', supportedScopes: ['character'] },
  { name: 'set_activity_intent', description: 'Sets the character\'s intent for their current activity to the specified intent.', supportedScopes: ['character'], syntax: "Will fail with error if the intent is not supported by the activity or not eligible for the character.\ncharacter = {\nset_activity_intent = reduce_stress_intent\n}\nor\ncharacter = {\nset_activity_intent = {\nintent = reduce_stress_intent\ntarget = scope:character\n}\n}", parameters: ['character', 'intent', 'target'] },
  { name: 'set_age', description: 'Sets the character\'s age. Note that this will completely bypass birthday on-actions, age-related health, and so on, just like the console command', supportedScopes: ['character'], syntax: "Usage: set_age = script value" },
  { name: 'set_amenity_level', description: 'set_amenity_level = { type = food value = 2 }', supportedScopes: ['character'], syntax: "Sets the amenity type to the given value for the scoped character" },
  { name: 'set_appointment_timeout', description: 'Set timeout for character\'s participation in any appointment. Can specify loc-key with reason via \'desc\'.', supportedScopes: ['character'], syntax: "Will not override an existing longer timeout.\nscope:character = {\nset_appointment_timeout = {\nmonths = 2\n}\nset_appointment_timeout = {\ndays = 365\ndesc = reason_flag\n}\n}", parameters: ['months', 'days', 'desc'] },
  { name: 'set_beneficiary', description: 'The target character becomes the beneficiary of the scoped character. set_beneficiary = some character', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'set_character_faith', description: 'Changes what faith a character has executing the effects for it. For history setup use \'set_character_faith_history\' instead.', supportedScopes: ['character'], supportedTargets: ['faith'] },
  { name: 'set_character_faith_history', description: 'Changes what faith a character has NOT executing the effects for it. USE ONLY IN HISOTRY SETUP!', supportedScopes: ['character'], supportedTargets: ['faith'] },
  { name: 'set_character_faith_with_conversion', description: 'Changes what faith a character has, as if they used the faith-view interaction (minus the piety cost). So vassals who\'d accept will get converted, as will capitals', supportedScopes: ['character'], supportedTargets: ['faith'] },
  { name: 'set_character_secret_faith', description: 'Changes the characters secret_faith', supportedScopes: ['character'], supportedTargets: ['faith'], syntax: "set_character_secret_faith = faith:rabbinism" },
  { name: 'set_child_of_concubine_on_pregnancy', description: 'Sets the child to be (or not be) a child of a concubine during pregnancy', supportedScopes: ['character'] },
  { name: 'set_council_task', description: 'Sets the task of the scope councillor { task_type = council_position_type_key target = for_targeted_tasks  }', supportedScopes: ['character'] },
  { name: 'set_court_language', description: 'Set the character\'s court language to the given languageset_court_language = language_norwegian', supportedScopes: ['character'] },
  { name: 'set_court_type', description: 'Set the court type for this character\'s royal court', supportedScopes: ['character'] },
  { name: 'set_culture', description: 'Set the culture for this character', supportedScopes: ['character'], supportedTargets: ['culture'] },
  { name: 'set_culture_same_as', description: 'sets the culture of the character to be the same as the culture of the target', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'set_current_court_grandeur', description: 'Sets the current court grandeur of a character with a royal court, clamped between NRoyalCourt::COURT_GRANDEUR_MIN and NRoyalCourt::COURT_GRANDEUR_MAX.', supportedScopes: ['character'], syntax: "Does not apply a grace period, and removes any existing one." },
  { name: 'set_dead_character_variable', description: 'set_dead_character_variable = {', supportedScopes: ['character'], syntax: "name = <name> - name of the variable\nvalue = <value> - any event target, bool, value, script value or flag\nyears/weeks/days = { <min_number> <max_number> } - years/weeks/days this flag is supposed to last\n}\nAdds a variable to a dead character. A duration is required.", parameters: ['name'] },
  { name: 'set_death_reason', description: 'set_death_reason = { killer = X death_reason = Y artifact = Z }', supportedScopes: ['character'], syntax: "All parameters are optional. Sets the death reason, the killer, and artifact used in the death of a dead character" },
  { name: 'set_default_education', description: 'Set the default education focus for this character', supportedScopes: ['character'] },
  { name: 'set_designated_heir', description: 'Sets one the given direct child character as designated heir.', supportedScopes: ['character'], supportedTargets: ['character'], syntax: "set_designated_heir = my_character_scope" },
  { name: 'set_designated_heir_unsafe', description: 'Sets the given character as designated heir. This is unsafe if the designated heirs loop. Ensure that there is no loop of heirs when using this. This is purely for mod supports and designers should never use this.', supportedScopes: ['character'], supportedTargets: ['character'], syntax: "set_designated_heir_unsafe = my_character_scope" },
  { name: 'set_diarch', description: 'Set target character as new diarch. Requires an active diarchy', supportedScopes: ['character'], supportedTargets: ['character'], syntax: "set_diarch = scope:new_diarch" },
  { name: 'set_diarchy_mandate', description: 'Set mandate for the diarch. Takes mandate type as argument', supportedScopes: ['character'], syntax: "scope:diarch = { set_diarchy_mandate = live_long_and_prosper }" },
  { name: 'set_diarchy_swing', description: 'Set scales of power swing for the active diarchy', supportedScopes: ['character'], syntax: "set_diarchy_swing = 55" },
  { name: 'set_diarchy_type', description: 'Set diarthy type for the character. Takes diarchy type as argument', supportedScopes: ['character'], syntax: "set_diarchy_type = regency" },
  { name: 'set_employer', description: 'Add the scope character to the target character\'s court', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'set_ethnicity', description: 'Set the ethnicity for this character, if it is of a different portrait group and they have DNA it will be randomized', supportedScopes: ['character'] },
  { name: 'set_father', description: 'sets the father of a character', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'set_focus', description: 'Set the focus for this character', supportedScopes: ['character'] },
  { name: 'set_house', description: 'Sets the dynasty house of the character', supportedScopes: ['character'], supportedTargets: ['dynasty_house'] },
  { name: 'set_immortal_age', description: 'Changes what age the character became immortal at. Only works if already immortal', supportedScopes: ['character'], syntax: "set_immortal_age = 20" },
  { name: 'set_killer_public', description: 'Sets the scoped character\'s killer as being publicly known', supportedScopes: ['character'], syntax: "set_killer_public = bool" },
  { name: 'set_knight_status', description: 'Sets the knight status of the character to Forced/Default/Disallowed', supportedScopes: ['character'] },
  { name: 'set_known_bastard_on_pregnancy', description: 'Sets the child to a known or unknown bastard during pregnancy', supportedScopes: ['character'] },
  { name: 'set_location', description: 'Moves the character to a specific location.', supportedScopes: ['character'], syntax: "stick_to_location can be used to prevent the safety checks that sometimes return characters to their default location automatically.Usage:   set_location = province\nset_location = { location = province   stick_to_location = yes/no }" },
  { name: 'set_location_to_default', description: 'Moves the character to its "default" location.This is usually the realm capital for landed characters, or court location for courtiers.', supportedScopes: ['character'], syntax: "Usage: set_location_to_default = yes/no" },
  { name: 'set_mother', description: 'Sets the mother of a character', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'set_num_pregnancy_children', description: 'Set the number of children', supportedScopes: ['character'] },
  { name: 'set_override_designated_winner', description: 'The scoped character will put their beneficiary on the throne if they\'re the #1 participant if this is called with \'yes\'. Call with \'no\' to turn it off again. set_override_designate_winner = yes/no', supportedScopes: ['character'] },
  { name: 'set_owned_legend', description: 'Sets the owner of the target legend to the scoped character.', supportedScopes: ['character'], supportedTargets: ['legend'], syntax: "set_owned_legend = legend" },
  { name: 'set_player_character', description: 'The scope character\'s player will now play as the target character. Scope must be player-controlled. Target cannot be player-controlled. Example:set_player_character = scope:title_recipient', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'set_pregnancy_assumed_father', description: 'Set the assumed father of the pregnancy', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'set_primary_spouse', description: 'Set the primary spouse of a character', supportedScopes: ['character'], supportedTargets: ['character'], syntax: "set_primary_spouse = scope" },
  { name: 'set_primary_title_to', description: 'Sets the primary title for a character', supportedScopes: ['character'], supportedTargets: ['landed_title'], syntax: "set_primary_title_to = <title>" },
  { name: 'set_promoted_legend', description: 'Adds the scoped character as a promoter of the target legend.', supportedScopes: ['character'], supportedTargets: ['legend'], syntax: "set_promoted_legend = legend" },
  { name: 'set_real_father', description: 'Changes the real father of the scoped character', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'set_real_mother', description: 'Changes the real mother of the scoped character', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'set_realm_capital', description: 'Set a new realm capital', supportedScopes: ['character'], supportedTargets: ['landed_title'], syntax: "character = { set_realm_capital = new_title }", parameters: ['character'] },
  { name: 'set_relation_activity_recurrer', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_relation_antiquarian', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_relation_best_friend', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_relation_blood_brother', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_relation_bully', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_relation_court_physician', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_relation_crush', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_relation_disciple', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_relation_elder', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_relation_event_recurrer', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_relation_favorite_child', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_relation_fellow_disciple', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_relation_friend', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_relation_grudge', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_relation_guardian', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_relation_intrigue_mentor', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_relation_intrigue_student', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_relation_lover', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_relation_mentor', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_relation_nemesis', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_relation_nursed_child', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_relation_oaf', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_relation_old_flame', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_relation_potential_friend', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_relation_potential_hook', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_relation_potential_lover', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_relation_potential_rival', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_relation_rival', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_relation_soldier_friend', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_relation_soulmate', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_relation_student', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_relation_victim', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_relation_ward', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_relation_wedding_bad_fertility', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_relation_wedding_good_fertility', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_relation_wedding_very_bad_fertility', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_relation_wedding_very_good_fertility', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_relation_wet_nurse', description: 'Sets scripted relationship, set_relation_xxx = target, set_relation_xxx = { target = target reason = reason_key copy_reason = optional_other_relation province = optional_province involved_character = optional_character }', supportedScopes: ['character'] },
  { name: 'set_reserved_gold_maximum', description: 'Set the maximum (and also desired value) for the \'reserved\' gold AI budget. This budget is saved up, even before the war chest budget. It will not correct the current gold in that budget to conform to the new maximum.character, set_reserved_gold_maximum = X', supportedScopes: ['character'] },
  { name: 'set_sexuality', description: 'Sets the sexuality of the character', supportedScopes: ['character'] },
  { name: 'set_subject_contract_modification_blocked', description: 'Blocks the subject contract from being modified with regards to being checked by \'subject_contract_is_blocked_from_modification\'', supportedScopes: ['character'] },
  { name: 'set_to_lowborn', description: 'Set the character to lowborn', supportedScopes: ['character'] },
  { name: 'set_trait_rank', description: 'Sets the trait rank = { trait = trait_group rank = new rank }', supportedScopes: ['character'] },
  { name: 'set_treasury_budget_base_rate_military', description: 'Set budget base-rate for category', supportedScopes: ['character'], syntax: "set_treasury_budget_base_rate_military = X" },
  { name: 'set_treasury_budget_base_rate_ministries', description: 'Set budget base-rate for category', supportedScopes: ['character'], syntax: "set_treasury_budget_base_rate_ministries = X" },
  { name: 'set_treasury_budget_base_rate_salaries', description: 'Set budget base-rate for category', supportedScopes: ['character'], syntax: "set_treasury_budget_base_rate_salaries = X" },
  { name: 'set_vassal_contract_modification_blocked', description: 'Blocks the vassal contract from being modified with regards to being checked by \'vassal_contract_is_blocked_from_modification\'', supportedScopes: ['character'] },
  { name: 'spawn_army', description: 'Spawns an army for this character. If the character is not at war, the regiments will be created, but the army will not be spawned.', supportedScopes: ['character'], syntax: "Usage:\nspawn_army = {\nlevies = int/script value # optional, number of men\nmen_at_arms = { # optional, multiple can be specified. Need either levies or MAA\ntype = key\nmen/stacks = int/script value\n}\nlocation = province\norigin = province # optional, location used if not set. This is used for where to base bonuses and the like on\nwar = war # optional. If set, the stack will disband after the war ends\nwar_keep_on_attacker_victory = yes/no # Default: no. Tied to a war. Normally the stack will disband upon victory (if a war is specified), but this parameter prevents that from happening upon attacker victory\ninheritable = yes/no # Default: yes\nuses_supply = yes/no # Default: yes\narmy = army # optional. If set, the stack will merge into this army\nsave_scope_as/save_temporary_scope_as = new_army # optional way to get a reference to the new army. Note this might not be set if the army wasn't spawned (e.g. if the character is not at war)\nname = description # gives the troops a specific name that shows up in interfaces\n}", parameters: ['levies', 'men_at_arms', 'type', 'location', 'origin', 'war', 'war_keep_on_attacker_victory', 'inheritable', 'uses_supply', 'army', 'name'] },
  { name: 'sponsor_inspiration', description: 'sponsor_inspiration = inspiration', supportedScopes: ['character'], supportedTargets: ['inspiration'], syntax: "Sets the sponsor of the target inspiration to the scoped character" },
  { name: 'start_default_task', description: 'Force the Councillor to revert to the default task. Any relevant percentage progress will be lost (even if the councillor was performing the default task already).', supportedScopes: ['character'] },
  { name: 'start_scheme', description: 'Starts a new scheme of the given type.', supportedScopes: ['character'], syntax: "usage:\n<scheme starting character> =\nstart_scheme = {\ntype = X\ncontract = (Optional) CONTRACT\ntarget_character = (*) CHARACTER\ntarget_title = (*)TITLE\ntarget_culture = (*)CULTURE\ntarget_faith = (*)FAITH\ntargets_nothing = (*) yes/no (default no)\nsave_scope_as = (Optional) NAME\n}\n}\n(*) Only one target can be specified (or 0 if target_nothing = yes).", parameters: ['type', 'contract', 'target_character', 'target_title', 'target_culture', 'target_faith', 'targets_nothing'] },
  { name: 'start_travel_plan', description: 'Start a travel plan. Saving this as a scope will not work for player characters if they have to use the planner.', supportedScopes: ['character'], syntax: "start_travel_plan = {\ndestination = scope:province (repeatable)\ntravel_leader = scope:character (optional)\ncompanion = scope:character (optional & repeatable)\n# Domicile will move between provinces as travel progresses\ntravel_with_domicile = no\nplayers_use_planner = yes\n# adds a destination at the end of the travel plan to return to the starting location\nreturn_trip = yes\n# if NO a human player cannot close the planning window before starting their travel plan\ncan_cancel_planning = yes\n# Eventtriggered on non-home destinations determined by on_arrival_destinations\n# root - travel plan owner\non_arrival_event = event_id\n# Onaction triggered on non-home destinations determined by on_arrival_destinations.\n# root - travel plan owner\non_arrival_on_action = onaction_id\n# Event triggered when the travel starts\n# root - travel plan owner\non_start_event = event_id\n# Onaction triggered when the travel starts\n# root - travel plan owner\non_start_on_action = onaction_id\n# Event triggered if a player exits the travel planner instead of starting a travel\n# root - travel plan owner\non_travel_planner_cancel_event = event_id\n# Onaction triggered if a player exits the travel planner instead of starting a travel\n# root - travel plan owner\non_travel_planner_cancel_on_action = onaction_id\n# Which destinations the on_arrival should trigger on, defaults to all_but_last\non_arrival_destinations = all_but_last/all/first/last\n}", parameters: ['destination', 'travel_leader', 'companion', 'travel_with_domicile', 'players_use_planner', 'return_trip', 'can_cancel_planning', 'on_arrival_event', 'on_arrival_on_action', 'on_start_event', 'on_start_on_action', 'on_travel_planner_cancel_event', 'on_travel_planner_cancel_on_action', 'on_arrival_destinations'] },
  { name: 'start_tributary', description: 'starts a tributary = {', supportedScopes: ['character'], syntax: "contract_group = SUBJECT CONTRACT GROUPsuzerain = CHARACTER\n}", parameters: ['contract_group'] },
  { name: 'start_war', description: 'starts a war  = { casus_belli/cb = X target = Y claimant = Z target_title = W1 target_title = W2 ... } where X is a casus belli type, Y is the target character, Z i the (optional) claimant, W1, W2.... are targeted titles.', supportedScopes: ['character'], syntax: "If there are no title targets, the effect will pick one of possible title targets." },
  { name: 'stop_promoting_legend', description: 'Remove the scoped character as the owner/promoter of their current promoted legend if they have one.', supportedScopes: ['character'], syntax: "stop_promoting_legend = yes" },
  { name: 'store_localized_text_in_death', description: 'Makes a piece of localized text with the given key be stored on the character even after death, you should use this sparingly to avoid save bloat and use \'remove_localized_text\' if you no longer need itsaves', supportedScopes: ['character'], syntax: "store_localized_text_in_death = key" },
  { name: 'stress_impact', description: 'Stress impact according to specified traits (trait = value), use base = value for a base value that\'s always added', supportedScopes: ['character'] },
  { name: 'take_hostage', description: 'Take target character as a hostagescope:warden = { take_hostage = scope:hostage }', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'tributary_contract_set_obligation_level', description: 'change the obligation level of the scoped character\'s tributary contract', supportedScopes: ['character'], syntax: "vassal_contract_set_obligation_level = { type = name level = 1 } # index to obligation level\nvassal_contract_set_obligation_level = { type = name level = herd_obligation_low }\nvassal_contract_set_obligation_level = { type = name level = scope:obligation }", parameters: ['vassal_contract_set_obligation_level'] },
  { name: 'try_start_diarchy', description: 'Attempts to start a diarchy for the character. Takes diarchy type as argument', supportedScopes: ['character'], syntax: "NB: this effect will silently fail if a valid diarch cannot be found.\nUse `exists = my_ruler_scope.diarch` to test if it's valid afterwards if needed.\nstart_diarchy = regency", parameters: ['start_diarchy'] },
  { name: 'unlearn_court_language_of', description: 'The character unlearns the court language of the target character. Cannot unlearn the language of your cultureunlearn_court_language_of = scope:target_character', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'unlearn_language', description: 'The character unlearns the language. Cannot unlearn the language of your cultureunlearn_language = language_norwegian', supportedScopes: ['character'] },
  { name: 'unlearn_language_of_culture', description: 'The character unlearns the language of the target culture. Cannot unlearn the language of your cultureunlearn_language_of_culture = scope:target_culture', supportedScopes: ['character'], supportedTargets: ['culture'] },
  { name: 'use_hook', description: 'Uses a hook a character has (removes if weak, puts on cooldown if strong), use_hook = some_character', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'vassal_contract_decrease_obligation_level', description: 'decrease the obligation level of the scoped character\'s vassal contract', supportedScopes: ['character'] },
  { name: 'vassal_contract_increase_obligation_level', description: 'increase the obligation level of the scoped character\'s vassal contract', supportedScopes: ['character'] },
  { name: 'vassal_contract_set_obligation_level', description: 'change the obligation level of the scoped character\'s vassal contract', supportedScopes: ['character'], syntax: "vassal_contract_set_obligation_level = { type = name level = 1 } # index to obligation level\nvassal_contract_set_obligation_level = { type = name level = feudal_obligation_low }\nvassal_contract_set_obligation_level = { type = name level = scope:obligation }" },
  { name: 'visit_court_of', description: 'Add the scope character as the target character\'s guest', supportedScopes: ['character'], supportedTargets: ['character'] },
  { name: 'every_killed_character', description: 'Iterate through all kills of a character', supportedScopes: ['character', 'artifact'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_killed_character = { limit = { <triggers> } <effects> }" },
  { name: 'ordered_killed_character', description: 'Iterate through all kills of a character', supportedScopes: ['character', 'artifact'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_killed_character = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'random_killed_character', description: 'Iterate through all kills of a character', supportedScopes: ['character', 'artifact'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_killed_character = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
];

/**
 * Effects for landed_title scope (168 effects)
 */
export const landedtitleEffects: EffectDefinition[] = [
  { name: 'add_county_modifier', description: 'Add a modifier to a county', supportedScopes: ['landed_title'], syntax: "add_county_modifier = name\nadd_county_modifier = { modifier = name days/weeks/months/years = int }\nYou can also add an optional 'desc' field. This is a dynamic description that'll be used for your timed modifier" },
  { name: 'change_appointment_investment', description: 'Increase appointment score of an appropriate character for a title.', supportedScopes: ['landed_title'], syntax: "change_appointment_investment = {\ntarget = <character>\ninvestor = <character> # Optional, the character who made this investment\nvalue = <script_value>\n}", parameters: ['target', 'investor'] },
  { name: 'change_appointment_investment_for_anyone', description: 'Increase appointment score of any character for a title.', supportedScopes: ['landed_title'], syntax: "change_appointment_investment_for_anyone = {\ntarget = <character>\ninvestor = <character> # Optional, the character who made this investment\nvalue = <script_value>\n}", parameters: ['target', 'investor'] },
  { name: 'change_county_control', description: 'Changes the county control of a title. If the title has higher tier than county, the effect will propagate down to all counties below it.', supportedScopes: ['landed_title'] },
  { name: 'change_county_fertility', description: 'Changes the County Fertility of the scoped county title by the given amount', supportedScopes: ['landed_title'], syntax: "scope:county = { change_county_fertility = 5.5 }" },
  { name: 'change_de_jure_drift_progress', description: 'Change the progress of de jure drift of a title<drifting_title> = { change_de_jure_drift_progress = {    target = <drift_target_title>    values = <progress_change_value> } }', supportedScopes: ['landed_title'] },
  { name: 'change_development_level', description: 'Changes the development level of a title. If the title has higher tier than county, the effect will propagate down to all counties below it.', supportedScopes: ['landed_title'] },
  { name: 'change_development_progress', description: 'Changes the development progress of a title. If the title has higher tier than county, the effect will propagate down to all counties below it.', supportedScopes: ['landed_title'] },
  { name: 'change_development_progress_with_overflow', description: 'Changes the development progress of a title. If the title has higher tier than county, the effect will propagate down to all counties below it. Will overflow, so adding +100 to a county with 50 progress left will increase the level by 1 and result in 50 progress towards the next level', supportedScopes: ['landed_title'] },
  { name: 'clear_title_laws', description: 'remove all title laws from the scoped title. DOES NOT apply law removal costs and effects.', supportedScopes: ['landed_title'], syntax: "clear_title_laws = yes" },
  { name: 'clear_title_laws_effects', description: 'remove all title laws from the scoped title. DOES apply law removal costs and effects.', supportedScopes: ['landed_title'], syntax: "clear_title_laws_effects = yes" },
  { name: 'copy_title_history', description: 'Copy title history from another title', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], syntax: "copy_title_history = source_title" },
  { name: 'every_claimant', description: 'Iterate through all claimants to title. parameters: explicit = yes/no/all - default yes', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_claimant = { limit = { <triggers> } <effects> }" },
  { name: 'every_connected_county', description: 'Iterate through all counties connected to this one. Is based on top liege', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "any/every/whatever_connectec_county = {\nmax_naval_distance = 500\nallow_one_county_land_gap = yes\nevery_connected_county = { limit = { <triggers> } <effects> }", parameters: ['max_naval_distance', 'allow_one_county_land_gap'] },
  { name: 'every_controlled_faith', description: 'Iterate through all faiths headed by a title', supportedScopes: ['landed_title'], supportedTargets: ['faith'], outputScope: 'faith', isIterator: true, syntax: "every_controlled_faith = { limit = { <triggers> } <effects> }" },
  { name: 'every_controlled_title_maa_regiment', description: 'Iterate through controlled title regiments', supportedScopes: ['landed_title'], supportedTargets: ['regiment'], outputScope: 'regiment', isIterator: true, syntax: "every_controlled_title_maa_regiment = { limit = { <triggers> } <effects> }" },
  { name: 'every_county_province', description: 'Iterate through all provinces in a county', supportedScopes: ['landed_title'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, syntax: "every_county_province = { limit = { <triggers> } <effects> }" },
  { name: 'every_county_province_epidemic', description: 'Iterate through all epidemics affecting the provinces in a county', supportedScopes: ['landed_title'], supportedTargets: ['epidemic'], outputScope: 'epidemic', isIterator: true, syntax: "Optionally specify an outbreak intensity filter\nany_county_province_epidemic = { intensity = apocalyptic }\nevery_county_province_epidemic = { limit = { <triggers> } <effects> }", parameters: ['any_county_province_epidemic'] },
  { name: 'every_county_situation', description: 'Iterate through all situations that a county is involved in.', supportedScopes: ['landed_title'], supportedTargets: ['situation'], outputScope: 'situation', isIterator: true, syntax: "every_county_situation = { limit = { <triggers> } <effects> }" },
  { name: 'every_county_situation_sub_region', description: 'Iterate through all situation sub-regions that a county is involved in.', supportedScopes: ['landed_title'], supportedTargets: ['situation_sub_region'], outputScope: 'situation_sub_region', isIterator: true, syntax: "every_county_situation_sub_region = { limit = { <triggers> } <effects> }" },
  { name: 'every_county_struggle', description: 'Iterate through all struggles that a county is involved in.', supportedScopes: ['landed_title'], supportedTargets: ['struggle'], outputScope: 'struggle', isIterator: true, syntax: "every_county_struggle = { limit = { <triggers> } <effects> }" },
  { name: 'every_de_jure_county', description: 'Iterate through all counties within this dejure title', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_de_jure_county = { limit = { <triggers> } <effects> }" },
  { name: 'every_de_jure_county_holder', description: 'Iterate through all characters directly holding counties within this dejure title', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_de_jure_county_holder = { limit = { <triggers> } <effects> }" },
  { name: 'every_de_jure_top_liege', description: 'Iterate through all top lieges of the counts within this dejure title', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_de_jure_top_liege = { limit = { <triggers> } <effects> }" },
  { name: 'every_dejure_vassal_title_holder', description: 'Iterate through all the vassal holders of the title', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_dejure_vassal_title_holder = { limit = { <triggers> } <effects> }" },
  { name: 'every_direct_de_facto_vassal_title', description: 'Iterate through all de facto vassal titles', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_direct_de_facto_vassal_title = { limit = { <triggers> } <effects> }" },
  { name: 'every_direct_de_jure_vassal_title', description: 'Iterate through the all de jure vassals titles', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_direct_de_jure_vassal_title = { limit = { <triggers> } <effects> }" },
  { name: 'every_election_candidate', description: 'Iterate through all characters who are valid candidates in an election for a title', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_election_candidate = { limit = { <triggers> } <effects> }" },
  { name: 'every_elector', description: 'Iterate through all characters who are valid electors in an election for a title', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_elector = { limit = { <triggers> } <effects> }" },
  { name: 'every_important_location_for_title', description: 'Iterate through all counties that are important for the scoped title', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_important_location_for_title = { limit = { <triggers> } <effects> }" },
  { name: 'every_in_de_facto_hierarchy', description: 'Iterate through the title itself, all de facto vassals, and below. The continue trigger specifies whether to recursively iterate through the vassal\'s vassal', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "This is unrelated to the limit; if the limit is met it is added to the list, but its vassals will get checked even if the limit isn't met as long as the 'continue' trigger is\n..._de_jure_vassal_and_below = { continue = { conditions } }\nevery_in_de_facto_hierarchy = { limit = { <triggers> } <effects> }" },
  { name: 'every_in_de_jure_hierarchy', description: 'Iterate through the title itself, all de jure vassals, and below. The continue trigger specifies whether to recursively iterate through the vassal\'s vassal', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "This is unrelated to the limit; if the limit is met it is added to the list, but its vassals will get checked even if the limit isn't met as long as the 'continue' trigger is\n..._de_jure_vassal_and_below = { continue = { conditions } }\nevery_in_de_jure_hierarchy = { limit = { <triggers> } <effects> }" },
  { name: 'every_neighboring_county', description: 'Iterate through all neighboring counties. Can only be used in county scope', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_neighboring_county = { limit = { <triggers> } <effects> }" },
  { name: 'every_owned_title_maa_regiment', description: 'Iterate through owned title MaA regiments', supportedScopes: ['landed_title'], supportedTargets: ['regiment'], outputScope: 'regiment', isIterator: true, syntax: "every_owned_title_maa_regiment = { limit = { <triggers> } <effects> }" },
  { name: 'every_past_holder', description: 'Iterate through all past owners of a title from earliest to latest', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_past_holder = { limit = { <triggers> } <effects> }" },
  { name: 'every_past_holder_reversed', description: 'Iterate through all past owners of a title from latest to earliest', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_past_holder_reversed = { limit = { <triggers> } <effects> }" },
  { name: 'every_succession_appointment_investors', description: 'Iterate through all investors of target candidate within the scoped title. Optionally specify a value to filter by investment amount', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "scope:landed_title = {\nany/every/ordered/random_succession_appointment_investors = {\ncandidate = scope:character\nvalue > {\t\t\t# Optional compare value to\nvalue = 100\t\t# only have characters that\nadd = 10\t\t# have invested this much.\n}\n}\n}\nevery_succession_appointment_investors = { limit = { <triggers> } <effects> }", parameters: ['candidate', 'add'] },
  { name: 'every_this_title_or_de_jure_above', description: 'Iterate through this title and all its dejure liege titles', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_this_title_or_de_jure_above = { limit = { <triggers> } <effects> }" },
  { name: 'every_title_heir', description: 'Line of succession for the scoped title', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_title_heir = { limit = { <triggers> } <effects> }" },
  { name: 'every_title_interested_in_location', description: 'Iterate through titles that consider scoped county an important location', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_title_interested_in_location = { limit = { <triggers> } <effects> }" },
  { name: 'every_title_joined_faction', description: 'Iterate through all factions joined the scope landed title', supportedScopes: ['landed_title'], supportedTargets: ['faction'], outputScope: 'faction', isIterator: true, syntax: "every_title_joined_faction = { limit = { <triggers> } <effects> }" },
  { name: 'every_title_maa_regiment', description: 'Iterate through title all MaA regiments', supportedScopes: ['landed_title'], supportedTargets: ['regiment'], outputScope: 'regiment', isIterator: true, syntax: "every_title_maa_regiment = { limit = { <triggers> } <effects> }" },
  { name: 'every_title_to_title_neighboring_and_across_water_county', description: 'Scopes from a title to a neighboring county (incl. across water, looking trough the de Jure lieges)', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_title_to_title_neighboring_and_across_water_county = { limit = { <triggers> } <effects> }" },
  { name: 'every_title_to_title_neighboring_and_across_water_duchy', description: 'Scopes from a title to a neighboring duchy (incl. across water, looking trough the de Jure lieges)', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_title_to_title_neighboring_and_across_water_duchy = { limit = { <triggers> } <effects> }" },
  { name: 'every_title_to_title_neighboring_and_across_water_empire', description: 'Scopes from a title to a neighboring empire (incl. across water, looking trough the de Jure lieges)', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_title_to_title_neighboring_and_across_water_empire = { limit = { <triggers> } <effects> }" },
  { name: 'every_title_to_title_neighboring_and_across_water_kingdom', description: 'Scopes from a title to a neighboring kingdom (incl. across water, looking trough the de Jure lieges)', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_title_to_title_neighboring_and_across_water_kingdom = { limit = { <triggers> } <effects> }" },
  { name: 'every_title_to_title_neighboring_county', description: 'Scopes from a title to a neighboring county (looking trough the de Jure lieges)', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_title_to_title_neighboring_county = { limit = { <triggers> } <effects> }" },
  { name: 'every_title_to_title_neighboring_duchy', description: 'Scopes from a title to a neighboring duchy (looking trough the de Jure lieges)', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_title_to_title_neighboring_duchy = { limit = { <triggers> } <effects> }" },
  { name: 'every_title_to_title_neighboring_empire', description: 'Scopes from a title to a neighboring empire (looking trough the de Jure lieges)', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_title_to_title_neighboring_empire = { limit = { <triggers> } <effects> }" },
  { name: 'every_title_to_title_neighboring_kingdom', description: 'Scopes from a title to a neighboring kingdom (looking trough the de Jure lieges)', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_title_to_title_neighboring_kingdom = { limit = { <triggers> } <effects> }" },
  { name: 'lease_out_to', description: 'Lease out the scoped title', supportedScopes: ['landed_title'], supportedTargets: ['holy_order'], syntax: "lease_out_to = scope:a_holy_order" },
  { name: 'move_title_name_to', description: 'Move a custom localized title name from the scope title to the target title.', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], syntax: "move_title_name_to = scope:target_title" },
  { name: 'ordered_claimant', description: 'Iterate through all claimants to title. parameters: explicit = yes/no/all - default yes', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_claimant = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_connected_county', description: 'Iterate through all counties connected to this one. Is based on top liege', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "any/every/whatever_connectec_county = {\nmax_naval_distance = 500\nallow_one_county_land_gap = yes\nordered_connected_county = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['max_naval_distance', 'allow_one_county_land_gap', 'order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_controlled_faith', description: 'Iterate through all faiths headed by a title', supportedScopes: ['landed_title'], supportedTargets: ['faith'], outputScope: 'faith', isIterator: true, syntax: "ordered_controlled_faith = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_controlled_title_maa_regiment', description: 'Iterate through controlled title regiments', supportedScopes: ['landed_title'], supportedTargets: ['regiment'], outputScope: 'regiment', isIterator: true, syntax: "ordered_controlled_title_maa_regiment = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_county_province', description: 'Iterate through all provinces in a county', supportedScopes: ['landed_title'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, syntax: "ordered_county_province = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_county_province_epidemic', description: 'Iterate through all epidemics affecting the provinces in a county', supportedScopes: ['landed_title'], supportedTargets: ['epidemic'], outputScope: 'epidemic', isIterator: true, syntax: "Optionally specify an outbreak intensity filter\nany_county_province_epidemic = { intensity = apocalyptic }\nordered_county_province_epidemic = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['any_county_province_epidemic', 'order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_county_situation', description: 'Iterate through all situations that a county is involved in.', supportedScopes: ['landed_title'], supportedTargets: ['situation'], outputScope: 'situation', isIterator: true, syntax: "ordered_county_situation = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_county_situation_sub_region', description: 'Iterate through all situation sub-regions that a county is involved in.', supportedScopes: ['landed_title'], supportedTargets: ['situation_sub_region'], outputScope: 'situation_sub_region', isIterator: true, syntax: "ordered_county_situation_sub_region = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_county_struggle', description: 'Iterate through all struggles that a county is involved in.', supportedScopes: ['landed_title'], supportedTargets: ['struggle'], outputScope: 'struggle', isIterator: true, syntax: "ordered_county_struggle = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_de_jure_county', description: 'Iterate through all counties within this dejure title', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_de_jure_county = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_de_jure_county_holder', description: 'Iterate through all characters directly holding counties within this dejure title', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_de_jure_county_holder = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_de_jure_top_liege', description: 'Iterate through all top lieges of the counts within this dejure title', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_de_jure_top_liege = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_dejure_vassal_title_holder', description: 'Iterate through all the vassal holders of the title', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_dejure_vassal_title_holder = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_direct_de_facto_vassal_title', description: 'Iterate through all de facto vassal titles', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_direct_de_facto_vassal_title = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_direct_de_jure_vassal_title', description: 'Iterate through the all de jure vassals titles', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_direct_de_jure_vassal_title = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_election_candidate', description: 'Iterate through all characters who are valid candidates in an election for a title', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_election_candidate = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_elector', description: 'Iterate through all characters who are valid electors in an election for a title', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_elector = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_important_location_for_title', description: 'Iterate through all counties that are important for the scoped title', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_important_location_for_title = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_in_de_facto_hierarchy', description: 'Iterate through the title itself, all de facto vassals, and below. The continue trigger specifies whether to recursively iterate through the vassal\'s vassal', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "This is unrelated to the limit; if the limit is met it is added to the list, but its vassals will get checked even if the limit isn't met as long as the 'continue' trigger is\n..._de_jure_vassal_and_below = { continue = { conditions } }\nordered_in_de_facto_hierarchy = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_in_de_jure_hierarchy', description: 'Iterate through the title itself, all de jure vassals, and below. The continue trigger specifies whether to recursively iterate through the vassal\'s vassal', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "This is unrelated to the limit; if the limit is met it is added to the list, but its vassals will get checked even if the limit isn't met as long as the 'continue' trigger is\n..._de_jure_vassal_and_below = { continue = { conditions } }\nordered_in_de_jure_hierarchy = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_neighboring_county', description: 'Iterate through all neighboring counties. Can only be used in county scope', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_neighboring_county = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_owned_title_maa_regiment', description: 'Iterate through owned title MaA regiments', supportedScopes: ['landed_title'], supportedTargets: ['regiment'], outputScope: 'regiment', isIterator: true, syntax: "ordered_owned_title_maa_regiment = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_past_holder', description: 'Iterate through all past owners of a title from earliest to latest', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_past_holder = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_past_holder_reversed', description: 'Iterate through all past owners of a title from latest to earliest', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_past_holder_reversed = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_succession_appointment_investors', description: 'Iterate through all investors of target candidate within the scoped title. Optionally specify a value to filter by investment amount', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "scope:landed_title = {\nany/every/ordered/random_succession_appointment_investors = {\ncandidate = scope:character\nvalue > {\t\t\t# Optional compare value to\nvalue = 100\t\t# only have characters that\nadd = 10\t\t# have invested this much.\n}\n}\n}\nordered_succession_appointment_investors = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['candidate', 'add', 'order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_this_title_or_de_jure_above', description: 'Iterate through this title and all its dejure liege titles', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_this_title_or_de_jure_above = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_title_heir', description: 'Line of succession for the scoped title', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_title_heir = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_title_interested_in_location', description: 'Iterate through titles that consider scoped county an important location', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_title_interested_in_location = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_title_joined_faction', description: 'Iterate through all factions joined the scope landed title', supportedScopes: ['landed_title'], supportedTargets: ['faction'], outputScope: 'faction', isIterator: true, syntax: "ordered_title_joined_faction = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_title_maa_regiment', description: 'Iterate through title all MaA regiments', supportedScopes: ['landed_title'], supportedTargets: ['regiment'], outputScope: 'regiment', isIterator: true, syntax: "ordered_title_maa_regiment = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_title_to_title_neighboring_and_across_water_county', description: 'Scopes from a title to a neighboring county (incl. across water, looking trough the de Jure lieges)', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_title_to_title_neighboring_and_across_water_county = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_title_to_title_neighboring_and_across_water_duchy', description: 'Scopes from a title to a neighboring duchy (incl. across water, looking trough the de Jure lieges)', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_title_to_title_neighboring_and_across_water_duchy = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_title_to_title_neighboring_and_across_water_empire', description: 'Scopes from a title to a neighboring empire (incl. across water, looking trough the de Jure lieges)', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_title_to_title_neighboring_and_across_water_empire = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_title_to_title_neighboring_and_across_water_kingdom', description: 'Scopes from a title to a neighboring kingdom (incl. across water, looking trough the de Jure lieges)', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_title_to_title_neighboring_and_across_water_kingdom = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_title_to_title_neighboring_county', description: 'Scopes from a title to a neighboring county (looking trough the de Jure lieges)', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_title_to_title_neighboring_county = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_title_to_title_neighboring_duchy', description: 'Scopes from a title to a neighboring duchy (looking trough the de Jure lieges)', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_title_to_title_neighboring_duchy = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_title_to_title_neighboring_empire', description: 'Scopes from a title to a neighboring empire (looking trough the de Jure lieges)', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_title_to_title_neighboring_empire = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_title_to_title_neighboring_kingdom', description: 'Scopes from a title to a neighboring kingdom (looking trough the de Jure lieges)', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_title_to_title_neighboring_kingdom = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'random_claimant', description: 'Iterate through all claimants to title. parameters: explicit = yes/no/all - default yes', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_claimant = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_connected_county', description: 'Iterate through all counties connected to this one. Is based on top liege', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "any/every/whatever_connectec_county = {\nmax_naval_distance = 500\nallow_one_county_land_gap = yes\nrandom_connected_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }", parameters: ['max_naval_distance', 'allow_one_county_land_gap'] },
  { name: 'random_controlled_faith', description: 'Iterate through all faiths headed by a title', supportedScopes: ['landed_title'], supportedTargets: ['faith'], outputScope: 'faith', isIterator: true, syntax: "random_controlled_faith = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_controlled_title_maa_regiment', description: 'Iterate through controlled title regiments', supportedScopes: ['landed_title'], supportedTargets: ['regiment'], outputScope: 'regiment', isIterator: true, syntax: "random_controlled_title_maa_regiment = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_county_province', description: 'Iterate through all provinces in a county', supportedScopes: ['landed_title'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, syntax: "random_county_province = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_county_province_epidemic', description: 'Iterate through all epidemics affecting the provinces in a county', supportedScopes: ['landed_title'], supportedTargets: ['epidemic'], outputScope: 'epidemic', isIterator: true, syntax: "Optionally specify an outbreak intensity filter\nany_county_province_epidemic = { intensity = apocalyptic }\nrandom_county_province_epidemic = { limit = { <triggers> } (optional) weight = { mtth } <effects> }", parameters: ['any_county_province_epidemic'] },
  { name: 'random_county_situation', description: 'Iterate through all situations that a county is involved in.', supportedScopes: ['landed_title'], supportedTargets: ['situation'], outputScope: 'situation', isIterator: true, syntax: "random_county_situation = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_county_situation_sub_region', description: 'Iterate through all situation sub-regions that a county is involved in.', supportedScopes: ['landed_title'], supportedTargets: ['situation_sub_region'], outputScope: 'situation_sub_region', isIterator: true, syntax: "random_county_situation_sub_region = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_county_struggle', description: 'Iterate through all struggles that a county is involved in.', supportedScopes: ['landed_title'], supportedTargets: ['struggle'], outputScope: 'struggle', isIterator: true, syntax: "random_county_struggle = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_de_jure_county', description: 'Iterate through all counties within this dejure title', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_de_jure_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_de_jure_county_holder', description: 'Iterate through all characters directly holding counties within this dejure title', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_de_jure_county_holder = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_de_jure_top_liege', description: 'Iterate through all top lieges of the counts within this dejure title', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_de_jure_top_liege = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_dejure_vassal_title_holder', description: 'Iterate through all the vassal holders of the title', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_dejure_vassal_title_holder = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_direct_de_facto_vassal_title', description: 'Iterate through all de facto vassal titles', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_direct_de_facto_vassal_title = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_direct_de_jure_vassal_title', description: 'Iterate through the all de jure vassals titles', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_direct_de_jure_vassal_title = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_election_candidate', description: 'Iterate through all characters who are valid candidates in an election for a title', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_election_candidate = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_elector', description: 'Iterate through all characters who are valid electors in an election for a title', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_elector = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_important_location_for_title', description: 'Iterate through all counties that are important for the scoped title', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_important_location_for_title = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_in_de_facto_hierarchy', description: 'Iterate through the title itself, all de facto vassals, and below. The continue trigger specifies whether to recursively iterate through the vassal\'s vassal', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "This is unrelated to the limit; if the limit is met it is added to the list, but its vassals will get checked even if the limit isn't met as long as the 'continue' trigger is\n..._de_jure_vassal_and_below = { continue = { conditions } }\nrandom_in_de_facto_hierarchy = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_in_de_jure_hierarchy', description: 'Iterate through the title itself, all de jure vassals, and below. The continue trigger specifies whether to recursively iterate through the vassal\'s vassal', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "This is unrelated to the limit; if the limit is met it is added to the list, but its vassals will get checked even if the limit isn't met as long as the 'continue' trigger is\n..._de_jure_vassal_and_below = { continue = { conditions } }\nrandom_in_de_jure_hierarchy = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_neighboring_county', description: 'Iterate through all neighboring counties. Can only be used in county scope', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_neighboring_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_owned_title_maa_regiment', description: 'Iterate through owned title MaA regiments', supportedScopes: ['landed_title'], supportedTargets: ['regiment'], outputScope: 'regiment', isIterator: true, syntax: "random_owned_title_maa_regiment = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_past_holder', description: 'Iterate through all past owners of a title from earliest to latest', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_past_holder = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_past_holder_reversed', description: 'Iterate through all past owners of a title from latest to earliest', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_past_holder_reversed = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_succession_appointment_investors', description: 'Iterate through all investors of target candidate within the scoped title. Optionally specify a value to filter by investment amount', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "scope:landed_title = {\nany/every/ordered/random_succession_appointment_investors = {\ncandidate = scope:character\nvalue > {\t\t\t# Optional compare value to\nvalue = 100\t\t# only have characters that\nadd = 10\t\t# have invested this much.\n}\n}\n}\nrandom_succession_appointment_investors = { limit = { <triggers> } (optional) weight = { mtth } <effects> }", parameters: ['candidate', 'add'] },
  { name: 'random_this_title_or_de_jure_above', description: 'Iterate through this title and all its dejure liege titles', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_this_title_or_de_jure_above = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_title_heir', description: 'Line of succession for the scoped title', supportedScopes: ['landed_title'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_title_heir = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_title_interested_in_location', description: 'Iterate through titles that consider scoped county an important location', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_title_interested_in_location = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_title_joined_faction', description: 'Iterate through all factions joined the scope landed title', supportedScopes: ['landed_title'], supportedTargets: ['faction'], outputScope: 'faction', isIterator: true, syntax: "random_title_joined_faction = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_title_maa_regiment', description: 'Iterate through title all MaA regiments', supportedScopes: ['landed_title'], supportedTargets: ['regiment'], outputScope: 'regiment', isIterator: true, syntax: "random_title_maa_regiment = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_title_to_title_neighboring_and_across_water_county', description: 'Scopes from a title to a neighboring county (incl. across water, looking trough the de Jure lieges)', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_title_to_title_neighboring_and_across_water_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_title_to_title_neighboring_and_across_water_duchy', description: 'Scopes from a title to a neighboring duchy (incl. across water, looking trough the de Jure lieges)', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_title_to_title_neighboring_and_across_water_duchy = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_title_to_title_neighboring_and_across_water_empire', description: 'Scopes from a title to a neighboring empire (incl. across water, looking trough the de Jure lieges)', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_title_to_title_neighboring_and_across_water_empire = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_title_to_title_neighboring_and_across_water_kingdom', description: 'Scopes from a title to a neighboring kingdom (incl. across water, looking trough the de Jure lieges)', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_title_to_title_neighboring_and_across_water_kingdom = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_title_to_title_neighboring_county', description: 'Scopes from a title to a neighboring county (looking trough the de Jure lieges)', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_title_to_title_neighboring_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_title_to_title_neighboring_duchy', description: 'Scopes from a title to a neighboring duchy (looking trough the de Jure lieges)', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_title_to_title_neighboring_duchy = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_title_to_title_neighboring_empire', description: 'Scopes from a title to a neighboring empire (looking trough the de Jure lieges)', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_title_to_title_neighboring_empire = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_title_to_title_neighboring_kingdom', description: 'Scopes from a title to a neighboring kingdom (looking trough the de Jure lieges)', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_title_to_title_neighboring_kingdom = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'remove_all_county_modifier_instances', description: 'Remove all instances of a modifier from a county', supportedScopes: ['landed_title'], syntax: "remove_all_county_modifier_instances = name" },
  { name: 'remove_county_modifier', description: 'Remove a modifier from a county', supportedScopes: ['landed_title'], syntax: "remove_county_modifier = name" },
  { name: 'remove_important_location', description: 'Scoped county is no longer important for anyone', supportedScopes: ['landed_title'], syntax: "scope:county = {\nremove_important_location = yes\n}" },
  { name: 'remove_title_from_important_location', description: 'Scoped county is no longer important for the target title', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], syntax: "scope:county = {\nremove_title_from_important_location = scope:title\n}" },
  { name: 'reset_title_name', description: 'Sets the name and adjective of the scoped title back to being based on its key. Won\'t cause the prefix to change', supportedScopes: ['landed_title'], syntax: "reset_title_name = yes" },
  { name: 'reset_title_prefix', description: 'Sets the prefix of the scoped title back to being based on its key. Won\'t cause its adjective or name to change', supportedScopes: ['landed_title'], syntax: "reset_title_prefix = yes" },
  { name: 'revoke_lease', description: 'Revoke the lease of the scoped title', supportedScopes: ['landed_title'], syntax: "revoke_lease = yes" },
  { name: 'set_always_follows_primary_heir', description: 'Sets if the title should always go to the primary heir in partition succession', supportedScopes: ['landed_title'], syntax: "set_always_follows_primary_heir = yes" },
  { name: 'set_can_be_named_after_dynasty', description: 'Sets if the title can be named after it\'s holder\'s dynasty. set_can_be_named_after_dynasty_effect = no', supportedScopes: ['landed_title'] },
  { name: 'set_can_use_nomadic_naming', description: 'Sets if the title can use the dynamic naming for nomads. set_can_use_nomadic_naming = no', supportedScopes: ['landed_title'] },
  { name: 'set_capital_barony', description: 'Sets scoped barony to be the county capital', supportedScopes: ['landed_title'], syntax: "set_capital_barony = yes" },
  { name: 'set_capital_county', description: 'Sets the capital county of the title to the target county', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], syntax: "set_capital_county = <some county title>" },
  { name: 'set_color_from_title', description: 'Sets the color of the title to the same as the target title (shifted very slightly to not be identical)', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], syntax: "set_color_from_title = <some title>" },
  { name: 'set_county_culture', description: 'sets the culture of a county', supportedScopes: ['landed_title'], supportedTargets: ['culture'], syntax: "usage:\nset_county_culture = culture:english/root.character_culture" },
  { name: 'set_county_faith', description: 'Changes what faith a county has', supportedScopes: ['landed_title'], supportedTargets: ['faith'] },
  { name: 'set_de_jure_liege_title', description: 'Set a new DeJure liege title', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], syntax: "set_de_jure_liege_title = new_de_jure_liege" },
  { name: 'set_definitive_form', description: 'Sets if the title should use a definitive form name (no \'Kingdom of\')', supportedScopes: ['landed_title'], syntax: "set_definitive_form = yes" },
  { name: 'set_delete_on_destroy', description: 'Sets if the title should be deleted from the gamestate completely when it is destroyed. set_delete_on_destroy = yes', supportedScopes: ['landed_title'] },
  { name: 'set_destroy_if_invalid_heir', description: 'Sets if the title should be destroyed on succession if there\'s no heir matching its restrictions. set_destroy_if_invalid_heir = yes', supportedScopes: ['landed_title'] },
  { name: 'set_destroy_on_gain_same_tier', description: 'Sets if the title should be deleted from the gamestate completely when character gains or create a new title with the same tier.set_destroy_on_gain_same_tier = yes', supportedScopes: ['landed_title'] },
  { name: 'set_destroy_on_succession', description: 'Sets if the title should be destroyed on succession. set_destroy_on_succession = yes', supportedScopes: ['landed_title'] },
  { name: 'set_figurehead_title', description: 'Change if the scoped title is a special figurehead or not', supportedScopes: ['landed_title'] },
  { name: 'set_important_location', description: 'Scoped county is set as important for the target title', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'], syntax: "scope:county = {\nset_important_location = {\ntitle = scope:higher_tier_title\nenter_realm_event = event_name\nenter_realm_on_action = onaction_name\nleave_realm_event = event_name\nleave_realm_on_action = onaction_name\n}\n}\nEvents and onactions are fired with this scope:\nroot - title top liege\nscope:county - important location\nscope:title - higher tier title that is interested in the county\nIn enter realm:\nscope:changed_top_liege - former top liege of the important location\nIn leave realm:\nscope:changed_top_liege - new top liege of the important location", parameters: ['title', 'enter_realm_event', 'enter_realm_on_action', 'leave_realm_event', 'leave_realm_on_action'] },
  { name: 'set_landless_title', description: 'Sets if the title is landless (can be held by rulers with no land)', supportedScopes: ['landed_title'], syntax: "set_landless_title = yes" },
  { name: 'set_no_automatic_claims', description: 'Sets if the title should disallow automatic claims (meaning claims will only be added by script, and by pressed claims being inherited).', supportedScopes: ['landed_title'], syntax: "set_no_automatic_claims = yes" },
  { name: 'set_noble_family_title', description: 'Change if the scoped title is for a noble family, allowing landless playable. Title must be at least a duchy', supportedScopes: ['landed_title'] },
  { name: 'set_state_faith', description: 'Set the State Faith of a Title whose holder has the state_faith government rule', supportedScopes: ['landed_title'], supportedTargets: ['faith'], syntax: "<landed_title> = { set_state_faith = <faith> }" },
  { name: 'set_title_color', description: 'Changes the title\'s map color to the specified value. Both named and RGB values are supported.', supportedScopes: ['landed_title'], syntax: "usage:\nscope:landed_title = {\nset_title_color = { 255 0 0 }\n}" },
  { name: 'set_title_name', description: 'sets the name (localization key) of the scoped title. The adjective will be constructed by adding \'_adj\' to the localisation key. Won\'t cause the prefix to change', supportedScopes: ['landed_title'], syntax: "set_title_name = TEST_NAME_PLEASE_IGNORE" },
  { name: 'set_title_name_dynamic', description: 'Sets the name (localization key or custom text) of the scoped title, by parsing the passed localization key once with the current top scope. This can result in another localization key, or custom text.', supportedScopes: ['landed_title'], syntax: "The adjective will be constructed by adding '_adj' to the localisation key, if the key exists. Won't cause the prefix to change.\nset_title_name_dynamic = my_scripted_localization_key" },
  { name: 'set_title_prefix', description: 'sets the prefix of the scoped title. Won\'t cause its name or adjective to change', supportedScopes: ['landed_title'], syntax: "set_title_prefix = PREFIX_THE" },
  { name: 'title_create_faction', description: 'the scoped landed title creates a faction of the specified type against the specified target, title_create_faction = { type = X target = Y }', supportedScopes: ['landed_title'] },
  { name: 'title_join_faction', description: 'the landed title in the scope joins the assigned faction', supportedScopes: ['landed_title'], supportedTargets: ['faction'] },
  { name: 'title_leave_faction', description: 'the title in the scope leaves the assigned faction', supportedScopes: ['landed_title'], supportedTargets: ['faction'] },
  { name: 'transfer_owned_maa_control', description: 'Transfers control of the scoped title\'s owned MaA to the target title', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'] },
  { name: 'transfer_title_maa_ownership', description: 'Transfers ownership of the scoped title\'s owned MaA to the target title', supportedScopes: ['landed_title'], supportedTargets: ['landed_title'] },
  { name: 'update_dynamic_coa', description: 'update_dynamic_coa = yes', supportedScopes: ['landed_title'], syntax: "Updates the dynamic coat of arms definition of a given title picking a new one and overwriting the existing set coat of arms with it if picked" },
  { name: 'generate_coa', description: 'Generates a coat of arms for the scoped landed title, dynasty or house', supportedScopes: ['landed_title', 'dynasty', 'dynasty_house', 'confederation'], syntax: "generate_coa = yes" },
  { name: 'reset_coa', description: 'Rest the coat of arms for the scoped landed title, dynasty or house to its template', supportedScopes: ['landed_title', 'dynasty', 'dynasty_house', 'confederation'], syntax: "reset_coa = yes" },
  { name: 'set_coa', description: 'Sets the coat of arms of a landed title, dynasty, or house to the right hand side coat of arms or that of an object of the same type', supportedScopes: ['landed_title', 'dynasty', 'dynasty_house', 'confederation'], syntax: "set_coa = k_england\nset_coa = scope:new_coa" },
];

/**
 * Effects for province scope (49 effects)
 */
export const provinceEffects: EffectDefinition[] = [
  { name: 'add_building', description: 'Add building to the province<province> = { add_building = <building_name> }', supportedScopes: ['province'] },
  { name: 'add_great_building', description: 'Add the specified great building to the province in scope. A slot of the specified type will be also added if needed.', supportedScopes: ['province'], syntax: "This effect will error and do nothing if there already is a great building in the province. Check the existance of great building with has_any_great_building.\nThe building is immediately constructed at no cost for the owner\nusage:\nscope:province = {\nadd_great_building = mandala_capital_01\n}" },
  { name: 'add_great_building_slot', description: 'Add a great building slot of the specified type to the province.', supportedScopes: ['province'], syntax: "Will fail with an error if there is a great building slot already available in the province, regardless of whether it is filled or not.\nNotice that buildings must satisfy the can_construct_potential flag to be selectable by the player.\nIf you want to just add the great building to the province without having the player explicitly start construction, use add_great_building instead.\nusage:\nscope:province = {\nadd_great_building_slot = <building_name>\n}" },
  { name: 'add_legend_spread', description: 'Adds the target legend as spread to the scoped province.', supportedScopes: ['province'], supportedTargets: ['legend'], syntax: "add_legend_spread = legend" },
  { name: 'add_province_modifier', description: 'Add a modifier to a province', supportedScopes: ['province'], syntax: "add_province_modifier = name\nadd_province_modifier = { modifier = name days/weeks/months/years = int }\nYou can also add an optional 'desc' field. This is a dynamic description that'll be used for your timed modifier" },
  { name: 'add_special_building', description: 'Add a special building to the province (will also add/change a special slot if needed)', supportedScopes: ['province'] },
  { name: 'add_special_building_slot', description: 'Add a special building slot to the province<province> = { add_special_building_slot = <building_name> }', supportedScopes: ['province'] },
  { name: 'add_travel_point_of_interest', description: 'Add a travel point of interest type to this province.', supportedScopes: ['province'], syntax: "add_travel_point_of_interest = point_of_interest_type" },
  { name: 'begin_create_holding', description: 'Start construction of the specified holding type. By default player won\'t get anything if manually cancels the construction', supportedScopes: ['province'], syntax: "scope:my_province = {\nbegin_create_holding = castle_holding\n}\nOptionally refund cost can be set to some value.\nscope:my_province = {\nbegin_create_holding = {\ntype = castle_holding\nrefund_cost = {\ngold = 100\n}\n}\n}", parameters: ['type', 'refund_cost'] },
  { name: 'create_epidemic_outbreak', description: 'Creates a new epidemic in the scoped province.', supportedScopes: ['province'], syntax: "create_epidemic_outbreak = {\ntype = smallpox\nintensity = major\nsave_scope_as = new_epidemic # optional\n}", parameters: ['type', 'intensity'] },
  { name: 'downgrade_building_effect', description: 'Replaces an existing building in the holding with the previous building in line, if any.', supportedScopes: ['province'], syntax: "Provide any building in the line as effect target to downgrade it to the previous level.\nThere must be another building of the same type already in place or the effect will fail with an error.\nDuchy Capital buildings will also fail to be created if the province doesn't support them.\nUsage:\nscope:my_province = {\ndowngrade_building_effect = existing_building_key\n}" },
  { name: 'every_army_in_location', description: 'Iterate through all armies currently located in the scoped province', supportedScopes: ['province'], supportedTargets: ['army'], outputScope: 'army', isIterator: true, syntax: "every_army_in_location = { limit = { <triggers> } <effects> }" },
  { name: 'every_character_in_location', description: 'Iterate through all characters currently located in the scoped province', supportedScopes: ['province'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_character_in_location = { limit = { <triggers> } <effects> }" },
  { name: 'every_great_project_in_province', description: 'Iterate through all active Great Projects in a Province.', supportedScopes: ['province'], supportedTargets: ['great_project'], outputScope: 'great_project', isIterator: true, syntax: "every_great_project_in_province = { limit = { <triggers> } <effects> }" },
  { name: 'every_neighboring_province', description: 'Iterate through all neighboring provinces of a province', supportedScopes: ['province'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, syntax: "every_neighboring_province = { limit = { <triggers> } <effects> }" },
  { name: 'every_province_domicile', description: 'Iterate through all domiciles of scoped province', supportedScopes: ['province'], supportedTargets: ['domicile'], outputScope: 'domicile', isIterator: true, syntax: "every_province_domicile = { limit = { <triggers> } <effects> }" },
  { name: 'every_province_epidemic', description: 'Gets epidemics affecting the scoped province', supportedScopes: ['province'], supportedTargets: ['epidemic'], outputScope: 'epidemic', isIterator: true, syntax: "Optionally specify an outbreak intensity filter\nany_province_epidemic = { intensity = apocalyptic }\nevery_province_epidemic = { limit = { <triggers> } <effects> }", parameters: ['any_province_epidemic'] },
  { name: 'every_province_legend', description: 'Gets legends affecting the scoped province', supportedScopes: ['province'], supportedTargets: ['legend'], outputScope: 'legend', isIterator: true, syntax: "every_province_legend = { limit = { <triggers> } <effects> }" },
  { name: 'generate_building', description: 'Adds a random building to the province, using the AI\'s construction logic<province> = { generate_building = yes }', supportedScopes: ['province'] },
  { name: 'ordered_army_in_location', description: 'Iterate through all armies currently located in the scoped province', supportedScopes: ['province'], supportedTargets: ['army'], outputScope: 'army', isIterator: true, syntax: "ordered_army_in_location = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_character_in_location', description: 'Iterate through all characters currently located in the scoped province', supportedScopes: ['province'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_character_in_location = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_great_project_in_province', description: 'Iterate through all active Great Projects in a Province.', supportedScopes: ['province'], supportedTargets: ['great_project'], outputScope: 'great_project', isIterator: true, syntax: "ordered_great_project_in_province = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_neighboring_province', description: 'Iterate through all neighboring provinces of a province', supportedScopes: ['province'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, syntax: "ordered_neighboring_province = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_province_domicile', description: 'Iterate through all domiciles of scoped province', supportedScopes: ['province'], supportedTargets: ['domicile'], outputScope: 'domicile', isIterator: true, syntax: "ordered_province_domicile = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_province_epidemic', description: 'Gets epidemics affecting the scoped province', supportedScopes: ['province'], supportedTargets: ['epidemic'], outputScope: 'epidemic', isIterator: true, syntax: "Optionally specify an outbreak intensity filter\nany_province_epidemic = { intensity = apocalyptic }\nordered_province_epidemic = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['any_province_epidemic', 'order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_province_legend', description: 'Gets legends affecting the scoped province', supportedScopes: ['province'], supportedTargets: ['legend'], outputScope: 'legend', isIterator: true, syntax: "ordered_province_legend = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'plan_great_project', description: 'Starts funding a Great Project of the specified type in the given province.', supportedScopes: ['province'], syntax: "The character specified as founder will cover the initial cost and will be able to fund Contributions before other rulers.\nusage:\n<scope:province> = {\nplan_great_project = {\nfounder = var:character\ngreat_project_type = great_wall\n}\n}", parameters: ['founder', 'great_project_type'] },
  { name: 'random_army_in_location', description: 'Iterate through all armies currently located in the scoped province', supportedScopes: ['province'], supportedTargets: ['army'], outputScope: 'army', isIterator: true, syntax: "random_army_in_location = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_character_in_location', description: 'Iterate through all characters currently located in the scoped province', supportedScopes: ['province'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_character_in_location = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_great_project_in_province', description: 'Iterate through all active Great Projects in a Province.', supportedScopes: ['province'], supportedTargets: ['great_project'], outputScope: 'great_project', isIterator: true, syntax: "random_great_project_in_province = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_neighboring_province', description: 'Iterate through all neighboring provinces of a province', supportedScopes: ['province'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, syntax: "random_neighboring_province = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_province_domicile', description: 'Iterate through all domiciles of scoped province', supportedScopes: ['province'], supportedTargets: ['domicile'], outputScope: 'domicile', isIterator: true, syntax: "random_province_domicile = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_province_epidemic', description: 'Gets epidemics affecting the scoped province', supportedScopes: ['province'], supportedTargets: ['epidemic'], outputScope: 'epidemic', isIterator: true, syntax: "Optionally specify an outbreak intensity filter\nany_province_epidemic = { intensity = apocalyptic }\nrandom_province_epidemic = { limit = { <triggers> } (optional) weight = { mtth } <effects> }", parameters: ['any_province_epidemic'] },
  { name: 'random_province_legend', description: 'Gets legends affecting the scoped province', supportedScopes: ['province'], supportedTargets: ['legend'], outputScope: 'legend', isIterator: true, syntax: "random_province_legend = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'rebuild_great_building', description: 'The Great Building in the scoped province is rebuilt and loses its ruined status.', supportedScopes: ['province'], syntax: "rebuild_great_building = yes" },
  { name: 'refill_garrison', description: 'The scoped province gets its garrison refilled. refill_levy = yes/no', supportedScopes: ['province'] },
  { name: 'refill_levy', description: 'The scoped province gets its levy refilled. refill_levy = yes/no', supportedScopes: ['province'] },
  { name: 'remove_all_province_modifier_instances', description: 'Remove all instances of a modifier from a province', supportedScopes: ['province'], syntax: "remove_all_province_modifier_instances = name" },
  { name: 'remove_building', description: 'Remove building from the province<province> = { remove_building = <building_name> }', supportedScopes: ['province'] },
  { name: 'remove_holding', description: 'Removes the holding in scoped province, cannot remove capital holdings', supportedScopes: ['province'] },
  { name: 'remove_legend_spread', description: 'Removes the target legend as spread to the scoped province.', supportedScopes: ['province'], supportedTargets: ['legend'], syntax: "remove_legend_spread = legend" },
  { name: 'remove_province_modifier', description: 'Remove a modifier from a province', supportedScopes: ['province'], syntax: "remove_province_modifier = name" },
  { name: 'remove_travel_point_of_interest', description: 'Remove a travel point of interest type in this province.', supportedScopes: ['province'], syntax: "remove_travel_point_of_interest = point_of_interest_type" },
  { name: 'replace_building_effect', description: 'Replaces an existing building in the holding with a new one.', supportedScopes: ['province'], syntax: "For 'special' buildings (Duchy Capital, Special Building, Great Building) this effect will try and create slot and building even if there is no other building of the same slot type.\nFor 'regular' buildings, there must be another building of the same type already in place or the effect will fail with an error.\nDuchy Capital buildings will also fail to be created if the province doesn't support them.\nUsage:\nscope:my_province = {\nreplace_building_effect = new_building_key\n}" },
  { name: 'ruin_great_building', description: 'The Great Building in the scoped province becomes ruined.', supportedScopes: ['province'], syntax: "ruin_great_building = yes" },
  { name: 'set_great_building', description: 'Add the specified great building to the province in scope, potentially destroying any existing great building.', supportedScopes: ['province'], syntax: "Check the existance of great building with has_any_great_building.\nThe building is immediately constructed at no cost for the owner.\nusage:\nscope:province = {\nset_great_building = mandala_capital_01\n}" },
  { name: 'set_great_building_slot', description: 'Add a great building slot of the specified type to the province.', supportedScopes: ['province'], syntax: "Will error if there is a great building slot already available in the province, and set the slot to the specified type potentially destroying existing buildings.\nNotice that buildings must satisfy the can_construct_potential flag to be selectable by the player.\nIf you want to just add the great building to the province without having the player explicitly start construction, use add_great_building instead.\nusage:\nscope:province = {\nset_great_building_slot = <building_name>\n}" },
  { name: 'set_holding_type', description: 'Changes the scoped province\'s holding to another type, removing all buildings that are invalid for the new holding.', supportedScopes: ['province'], syntax: "This might also allow to construct a new holding in an empty province, but it is untested." },
  { name: 'upgrade_building_effect', description: 'Replaces an existing building in the holding with the next building in line, if any.', supportedScopes: ['province'], syntax: "Provide any building in the line as effect target to upgrade it to the next level.\nThere must be another building of the same type already in place or the effect will fail with an error.\nDuchy Capital buildings will also fail to be created if the province doesn't support them.\nUsage:\nscope:my_province = {\nupgrade_building_effect = existing_building_key\n}" },
];

/**
 * Effects for dynasty scope (14 effects)
 */
export const dynastyEffects: EffectDefinition[] = [
  { name: 'add_dynasty_modifier', description: 'Add a modifier to a dynasty', supportedScopes: ['dynasty'], syntax: "add_dynasty_modifier = name\nadd_dynasty_modifier = { modifier = name days/weeks/months/years = int }\nYou can also add an optional 'desc' field. This is a dynamic description that'll be used for your timed modifier" },
  { name: 'add_dynasty_perk', description: 'Adds dynasty perk. add_dynasty_perk = key', supportedScopes: ['dynasty'] },
  { name: 'add_dynasty_prestige', description: 'adds dynasty prestige', supportedScopes: ['dynasty'] },
  { name: 'add_dynasty_prestige_level', description: 'adds dynasty prestige levels', supportedScopes: ['dynasty'] },
  { name: 'every_dynasty_house', description: 'Iterate through all houses in dynasty', supportedScopes: ['dynasty'], supportedTargets: ['dynasty_house'], outputScope: 'dynasty_house', isIterator: true, syntax: "every_dynasty_house = { limit = { <triggers> } <effects> }" },
  { name: 'every_dynasty_member', description: 'Iterate through all dynasty members', supportedScopes: ['dynasty'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_dynasty_member = { limit = { <triggers> } <effects> }" },
  { name: 'ordered_dynasty_house', description: 'Iterate through all houses in dynasty', supportedScopes: ['dynasty'], supportedTargets: ['dynasty_house'], outputScope: 'dynasty_house', isIterator: true, syntax: "ordered_dynasty_house = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_dynasty_member', description: 'Iterate through all dynasty members', supportedScopes: ['dynasty'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_dynasty_member = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'random_dynasty_house', description: 'Iterate through all houses in dynasty', supportedScopes: ['dynasty'], supportedTargets: ['dynasty_house'], outputScope: 'dynasty_house', isIterator: true, syntax: "random_dynasty_house = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_dynasty_member', description: 'Iterate through all dynasty members', supportedScopes: ['dynasty'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_dynasty_member = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'remove_all_dynasty_modifier_instances', description: 'Remove all instances of a modifier from a dynasty', supportedScopes: ['dynasty'], syntax: "remove_all_dynasty_modifier_instances = name" },
  { name: 'remove_dynasty_modifier', description: 'Remove a modifier from a dynasty', supportedScopes: ['dynasty'], syntax: "remove_dynasty_modifier = name" },
  { name: 'remove_dynasty_perk', description: 'Removes dynasty perk. remove_dynasty_perk = key', supportedScopes: ['dynasty'] },
  { name: 'set_dynasty_name', description: 'Sets dynasty name', supportedScopes: ['dynasty'], syntax: "set_dynasty_name=<dynamic_description>" },
];

/**
 * Effects for dynasty_house scope (27 effects)
 */
export const dynastyhouseEffects: EffectDefinition[] = [
  { name: 'add_house_artifact_claim', description: 'Adds a claim on the target artifact to the scoped house', supportedScopes: ['dynasty_house'], supportedTargets: ['artifact'] },
  { name: 'add_house_modifier', description: 'Add a modifier to a house', supportedScopes: ['dynasty_house'], syntax: "add_house_modifier = name\nadd_house_modifier = { modifier = name days/weeks/months/years = int }\nYou can also add an optional 'desc' field. This is a dynamic description that'll be used for your timed modifier" },
  { name: 'add_house_unity_modifier', description: 'Add a modifier to a house', supportedScopes: ['dynasty_house'], syntax: "add_house_unity_modifier = name\nadd_house_unity_modifier = { modifier = name days/weeks/months/years = int }\nYou can also add an optional 'desc' field. This is a dynamic description that'll be used for your timed modifier" },
  { name: 'add_unity_value', description: 'Adds value to the house unity.', supportedScopes: ['dynasty_house'], syntax: "Usage:\nadd_unity_value = {\nvalue = VALUE\ncharacter = CHARACTER\ndesc = localization_key\n}", parameters: ['character', 'desc'] },
  { name: 'every_house_claimed_artifact', description: 'Iterate through all claimed artifacts of the scoped house', supportedScopes: ['dynasty_house'], supportedTargets: ['artifact'], outputScope: 'artifact', isIterator: true, syntax: "every_house_claimed_artifact = { limit = { <triggers> } <effects> }" },
  { name: 'every_house_member', description: 'Iterate through all house members', supportedScopes: ['dynasty_house'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_house_member = { limit = { <triggers> } <effects> }" },
  { name: 'every_house_relation', description: 'Iterate over all house relations of the given house', supportedScopes: ['dynasty_house'], supportedTargets: ['house_relation'], outputScope: 'house_relation', isIterator: true, syntax: "every_house_relation = { limit = { <triggers> } <effects> }" },
  { name: 'every_house_unity_member', description: 'Iterate through all valid house unity members', supportedScopes: ['dynasty_house'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_house_unity_member = { limit = { <triggers> } <effects> }" },
  { name: 'ordered_house_claimed_artifact', description: 'Iterate through all claimed artifacts of the scoped house', supportedScopes: ['dynasty_house'], supportedTargets: ['artifact'], outputScope: 'artifact', isIterator: true, syntax: "ordered_house_claimed_artifact = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_house_member', description: 'Iterate through all house members', supportedScopes: ['dynasty_house'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_house_member = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_house_relation', description: 'Iterate over all house relations of the given house', supportedScopes: ['dynasty_house'], supportedTargets: ['house_relation'], outputScope: 'house_relation', isIterator: true, syntax: "ordered_house_relation = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_house_unity_member', description: 'Iterate through all valid house unity members', supportedScopes: ['dynasty_house'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_house_unity_member = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'random_house_claimed_artifact', description: 'Iterate through all claimed artifacts of the scoped house', supportedScopes: ['dynasty_house'], supportedTargets: ['artifact'], outputScope: 'artifact', isIterator: true, syntax: "random_house_claimed_artifact = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_house_member', description: 'Iterate through all house members', supportedScopes: ['dynasty_house'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_house_member = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_house_relation', description: 'Iterate over all house relations of the given house', supportedScopes: ['dynasty_house'], supportedTargets: ['house_relation'], outputScope: 'house_relation', isIterator: true, syntax: "random_house_relation = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_house_unity_member', description: 'Iterate through all valid house unity members', supportedScopes: ['dynasty_house'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_house_unity_member = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'remove_all_house_modifier_instances', description: 'Remove all instances of a modifier from a house', supportedScopes: ['dynasty_house'], syntax: "remove_all_house_modifier_instances = name" },
  { name: 'remove_all_house_unity_modifier_instances', description: 'Remove all instances of a modifier from a house unity', supportedScopes: ['dynasty_house'], syntax: "remove_all_house_unity_modifier_instances = name" },
  { name: 'remove_house_artifact_claim', description: 'Removes a claim on the target artifact from the scoped house', supportedScopes: ['dynasty_house'], supportedTargets: ['artifact'] },
  { name: 'remove_house_modifier', description: 'Remove a modifier from a house', supportedScopes: ['dynasty_house'], syntax: "remove_house_modifier = name" },
  { name: 'remove_house_unity_modifier', description: 'Remove a modifier from a house unity', supportedScopes: ['dynasty_house'], syntax: "remove_house_unity_modifier = name" },
  { name: 'set_house_aspiration', description: 'Set house aspiration/aspect/attribute for the given house.', supportedScopes: ['dynasty_house'], syntax: "usage:\n<house> = {\nset_house_aspiration = {\ntype = <type>\nlevel = <level> # optional\n}\n}", parameters: ['type', 'level'] },
  { name: 'set_house_head', description: 'Set house head for the house. Also transfers noble family title. Usage:', supportedScopes: ['dynasty_house'], supportedTargets: ['character'], syntax: "set_house_head = <character>" },
  { name: 'set_house_name', description: 'Sets dynasty house name', supportedScopes: ['dynasty_house'], syntax: "set_house_name=<dynamic_description>" },
  { name: 'set_house_name_from_dynasty', description: 'Sets dynasty house name from another dynasty\'s name', supportedScopes: ['dynasty_house'], supportedTargets: ['dynasty'], syntax: "set_house_name_from_dynasty = dynasty" },
  { name: 'set_house_name_from_house', description: 'Sets dynasty house name from another dynasty house\'s name', supportedScopes: ['dynasty_house'], supportedTargets: ['dynasty_house'], syntax: "set_house_name_from_house = house" },
  { name: 'set_house_relation', description: 'Set the relation between two houses.', supportedScopes: ['dynasty_house'], syntax: "usage:\nsome_house = {\nset_house_relation = {\ntarget = <other house>\ntype = <type of relation> #optional\nlevel = <relationship level> #optional\ndescription = <dynamic description> # Why the latest change happened\nsave_scope_as = <name> # optional\n}\n}", parameters: ['some_house', 'target', 'type', 'level', 'description'] },
];

/**
 * Effects for culture scope (57 effects)
 */
export const cultureEffects: EffectDefinition[] = [
  { name: 'add_culture_tradition', description: 'Adds the cultural tradition scope specified in the RHS to the scope culture.add_culture_tradition = tradition_court_eunuchs', supportedScopes: ['culture'], supportedTargets: ['culture_tradition'] },
  { name: 'add_fascination_progress', description: '"Add X percentage of progress to current fascination. Supports scripted values.', supportedScopes: ['culture'], syntax: "usage:\n<culture> = add_fascination_progress = 35" },
  { name: 'add_fascination_progress_time', description: 'Add X months of progress to current fascination. Supports scripted values.', supportedScopes: ['culture'], syntax: "usage:\n<culture> = add_fascination_progress_time = 3" },
  { name: 'add_innovation', description: 'Add innovation to a culture. add_innovation = innovation_key', supportedScopes: ['culture'], supportedTargets: ['culture_innovation'] },
  { name: 'add_innovation_progress', description: 'Add X percentage of progress to the selected innovation.', supportedScopes: ['culture'], syntax: "You can use either a hardcoded innovation key (culture_innovation:innovation_burhs) or a saved innovation scope (scope:my_innovation).\nadd_innovation_progress = {\nvalue = 15\ntarget = innovation\n}", parameters: ['target'] },
  { name: 'add_innovation_progress_time', description: 'Add X months of progress to the selected innovation.', supportedScopes: ['culture'], syntax: "You can use either a hardcoded innovation key (culture_innovation:innovation_burhs) or a saved innovation scope (scope:my_innovation).\nThe value parameter supports scripted values.\nadd_innovation_progress_time = {\nvalue = 3\ntarget = innovation\n}", parameters: ['target'] },
  { name: 'add_name_list', description: 'Adds the name list to the culture', supportedScopes: ['culture'], syntax: "<culture> = { add_name_list = name }" },
  { name: 'add_random_innovation', description: 'Add random available innovation<culture> = { add_random_innovation = culture_group_military/culture_group_civic/culture_group_regional/yes }', supportedScopes: ['culture'] },
  { name: 'add_random_valid_tradition', description: 'Adds one random valid tradition to a culture. Target character provides context for can_pick and is_shown. If this would put the culture over the tradition limit, an error is loggedadd_random_valid_tradition = scope:character', supportedScopes: ['culture'], supportedTargets: ['character'] },
  { name: 'add_random_valid_tradition_replace_if_necessary', description: 'Adds one random valid tradition to a culture. Target character provides context for can_pick and is_shown. If this would put the culture over the tradition limit, a random existing tradition is removedadd_random_valid_tradition_replace_if_necessary = scope:character', supportedScopes: ['culture'], supportedTargets: ['character'] },
  { name: 'add_spread_progress', description: 'Add X percentage of progress to current spread innovation. Supports scripted values.', supportedScopes: ['culture'], syntax: "usage:\n<culture> = add_spread_progress = 35" },
  { name: 'add_spread_progress_time', description: 'Add X months of progress to current spread innovation. Supports scripted values.', supportedScopes: ['culture'], syntax: "usage:\n<culture> = add_spread_progress_time = 3" },
  { name: 'change_cultural_acceptance', description: 'Changes cultural acceptance with the target culture', supportedScopes: ['culture'], syntax: "change_cultural_acceptance = {\ntarget = <culture>\nvalue = script value\ndesc = dynamic desc. Description that'll show when hovering over the acceptance tooltip in the culture window\n}", parameters: ['target', 'desc'] },
  { name: 'clear_culture_traditions', description: 'Removes all cultural traditions from the scope culture.clear_culture_traditions = yes', supportedScopes: ['culture'] },
  { name: 'copy_all_traditions_from', description: 'Replaces all traditions of scoped culture with traditions from the given culturecopy_all_traditions_from = scope:target_culture', supportedScopes: ['culture'], supportedTargets: ['culture'] },
  { name: 'every_culture_county', description: 'Iterate through all counties of the culture', supportedScopes: ['culture'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_culture_county = { limit = { <triggers> } <effects> }" },
  { name: 'every_culture_duchy', description: 'Iterate through all duchies of the culture (duchies with at least one county of the culture', supportedScopes: ['culture'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_culture_duchy = { limit = { <triggers> } <effects> }" },
  { name: 'every_culture_empire', description: 'Iterate through all empires of the culture (empires with at least one county of the culture', supportedScopes: ['culture'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_culture_empire = { limit = { <triggers> } <effects> }" },
  { name: 'every_culture_kingdom', description: 'Iterate through all kingdoms of the culture (kingdoms with at least one county of the culture', supportedScopes: ['culture'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_culture_kingdom = { limit = { <triggers> } <effects> }" },
  { name: 'every_known_innovation', description: 'Iterate through all innovations known to the given culture', supportedScopes: ['culture'], supportedTargets: ['culture_innovation'], outputScope: 'culture_innovation', isIterator: true, syntax: "every_known_innovation = { limit = { <triggers> } <effects> }" },
  { name: 'every_parent_culture', description: 'Iterate through all parent cultures', supportedScopes: ['culture'], supportedTargets: ['culture'], outputScope: 'culture', isIterator: true, syntax: "every_parent_culture = { limit = { <triggers> } <effects> }" },
  { name: 'every_parent_culture_or_above', description: 'Iterate through all parent cultures or above', supportedScopes: ['culture'], supportedTargets: ['culture'], outputScope: 'culture', isIterator: true, syntax: "every_parent_culture_or_above = { limit = { <triggers> } <effects> }" },
  { name: 'every_tradition', description: 'Iterate through all traditions of the given culture', supportedScopes: ['culture'], supportedTargets: ['culture_tradition'], outputScope: 'culture_tradition', isIterator: true, syntax: "every_tradition = { limit = { <triggers> } <effects> }" },
  { name: 'get_all_innovations_from', description: 'Discover all innovations from the target culture', supportedScopes: ['culture'], supportedTargets: ['culture'], syntax: "get_all_innovations_from = <culture>" },
  { name: 'get_random_innovation_from', description: 'Get random available innovation from another culture', supportedScopes: ['culture'] },
  { name: 'join_era', description: 'Joins all culture eras up to and including the given one', supportedScopes: ['culture'], syntax: "join_era = culture_era_type" },
  { name: 'leave_era', description: 'Leaves all culture eras down to and including the given one', supportedScopes: ['culture'], syntax: "leave_era = culture_era_type" },
  { name: 'ordered_culture_county', description: 'Iterate through all counties of the culture', supportedScopes: ['culture'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_culture_county = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_culture_duchy', description: 'Iterate through all duchies of the culture (duchies with at least one county of the culture', supportedScopes: ['culture'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_culture_duchy = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_culture_empire', description: 'Iterate through all empires of the culture (empires with at least one county of the culture', supportedScopes: ['culture'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_culture_empire = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_culture_kingdom', description: 'Iterate through all kingdoms of the culture (kingdoms with at least one county of the culture', supportedScopes: ['culture'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_culture_kingdom = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_known_innovation', description: 'Iterate through all innovations known to the given culture', supportedScopes: ['culture'], supportedTargets: ['culture_innovation'], outputScope: 'culture_innovation', isIterator: true, syntax: "ordered_known_innovation = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_parent_culture', description: 'Iterate through all parent cultures', supportedScopes: ['culture'], supportedTargets: ['culture'], outputScope: 'culture', isIterator: true, syntax: "ordered_parent_culture = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_parent_culture_or_above', description: 'Iterate through all parent cultures or above', supportedScopes: ['culture'], supportedTargets: ['culture'], outputScope: 'culture', isIterator: true, syntax: "ordered_parent_culture_or_above = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_tradition', description: 'Iterate through all traditions of the given culture', supportedScopes: ['culture'], supportedTargets: ['culture_tradition'], outputScope: 'culture_tradition', isIterator: true, syntax: "ordered_tradition = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'random_culture_county', description: 'Iterate through all counties of the culture', supportedScopes: ['culture'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_culture_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_culture_duchy', description: 'Iterate through all duchies of the culture (duchies with at least one county of the culture', supportedScopes: ['culture'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_culture_duchy = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_culture_empire', description: 'Iterate through all empires of the culture (empires with at least one county of the culture', supportedScopes: ['culture'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_culture_empire = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_culture_kingdom', description: 'Iterate through all kingdoms of the culture (kingdoms with at least one county of the culture', supportedScopes: ['culture'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_culture_kingdom = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_known_innovation', description: 'Iterate through all innovations known to the given culture', supportedScopes: ['culture'], supportedTargets: ['culture_innovation'], outputScope: 'culture_innovation', isIterator: true, syntax: "random_known_innovation = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_parent_culture', description: 'Iterate through all parent cultures', supportedScopes: ['culture'], supportedTargets: ['culture'], outputScope: 'culture', isIterator: true, syntax: "random_parent_culture = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_parent_culture_or_above', description: 'Iterate through all parent cultures or above', supportedScopes: ['culture'], supportedTargets: ['culture'], outputScope: 'culture', isIterator: true, syntax: "random_parent_culture_or_above = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_tradition', description: 'Iterate through all traditions of the given culture', supportedScopes: ['culture'], supportedTargets: ['culture_tradition'], outputScope: 'culture_tradition', isIterator: true, syntax: "random_tradition = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'remove_bonus_fascination_innovation', description: 'Removes the current bonus fascination for the selected culture.', supportedScopes: ['culture'], syntax: "You don't need to remove the bonus before assigning it to a different innovation: the new selection will override the previous one.\nusage:\nculture = {\nremove_bonus_fascination_innovation = yes\n}", parameters: ['culture'] },
  { name: 'remove_culture_tradition', description: 'Removes the cultural tradition scope specified in the RHS from the scope culture.remove_culture_tradition = tradition_court_eunuchs', supportedScopes: ['culture'], supportedTargets: ['culture_tradition'] },
  { name: 'remove_innovation', description: 'Remove innovation from a culture. remove_innovation = innovation_key', supportedScopes: ['culture'], supportedTargets: ['culture_innovation'] },
  { name: 'remove_random_culture_tradition', description: 'Removes a random cultural tradition from the scope culture.remove_random_culture_tradition = yes', supportedScopes: ['culture'] },
  { name: 'reset_culture_creation_date', description: 'Sets the culture creation date to be todays datereset_culture_creation_date = yes', supportedScopes: ['culture'] },
  { name: 'set_bonus_fascination_innovation', description: 'Sets the current bonus fascination to the specified innovation.', supportedScopes: ['culture'], supportedTargets: ['culture_innovation'], syntax: "The innovation can be specified both with its DB key (innovation_burhs) or via saved scope (scope:my_saved_innovation).\nThe culture will get bonus progress rate when fascinated with this innovation.\nDefine the desired bonus in 00_defines.txt (INNOVATION_PROGRESS_GAIN_FROM_BONUS_FASCINATION).\nThe bonus is dropped when the innovation is discovered, a new set_bonus_fascination_innovation is called on the culture, or when manually reset via script.\nReset this marker with reset_bonus_fascination_innovation.\nusage:\nculture = {\nset_bonus_fascination_innovation = innovation\n}", parameters: ['culture'] },
  { name: 'set_cultural_acceptance', description: 'Sets cultural acceptance with the target culture', supportedScopes: ['culture'], syntax: "set_cultural_accpetance = { target = <culture> value = script value }", parameters: ['set_cultural_accpetance'] },
  { name: 'set_culture_name', description: 'Permanently sets the name of the scope culture to the parsed text from the provided localization string.', supportedScopes: ['culture'], syntax: "Like 'set_title_name', the new name is static and unchanging (i.e., if the localization key provided is 'Neo-[old_culture.GetName]' and the old culture is French, the new name is just be saved as a simple string, 'Neo-French', so that if/when the old_culture scope is cleaned up the localization does not break.set_culture_name = {\nnoun = dynamic description\ncollective_noun = dynamic description\nprefix = dynamic description\n}", parameters: ['noun', 'collective_noun', 'prefix'] },
  { name: 'set_culture_pillar', description: 'Adds the current pillar specified in the RHS to the scope culture, replacing the pillar in the matching slot.set_culture_pillar = ethos_warmonger', supportedScopes: ['culture'] },
  { name: 'set_ethos_from', description: 'Set the ethos from the RHS on the scope culture.set_ethos_from = culture:norwegian', supportedScopes: ['culture'], supportedTargets: ['culture'] },
  { name: 'set_heritage_from', description: 'Set the heritage from the RHS on the scope culture.set_heritage_from = culture:norwegian', supportedScopes: ['culture'], supportedTargets: ['culture'] },
  { name: 'set_language_from', description: 'Set the language from the RHS on the scope culture.set_language_from = culture:norwegian', supportedScopes: ['culture'], supportedTargets: ['culture'] },
  { name: 'set_martial_custom_from', description: 'Set the martial custom from the RHS on the scope culture.set_martial_custom_from = culture:norwegian', supportedScopes: ['culture'], supportedTargets: ['culture'] },
  { name: 'set_name_list', description: 'Remove all existing name lists then adds the specified name list to the culture', supportedScopes: ['culture'], syntax: "<culture> = { set_name_list = name }" },
];

/**
 * Effects for faith scope (26 effects)
 */
export const faithEffects: EffectDefinition[] = [
  { name: 'activate_holy_site', description: 'Activate an inactive holy site<faith_scope> = { activate_holy_site = <holy_site_name> }', supportedScopes: ['faith'] },
  { name: 'add_doctrine', description: 'Add doctrine to faith<faith_scope> = { add_doctrine = <doctrine_name> }', supportedScopes: ['faith'], supportedTargets: ['doctrine'] },
  { name: 'change_fervor', description: 'Changes the fervor of the faith by the given value. change_fervor = script value', supportedScopes: ['faith'] },
  { name: 'deactivate_holy_site', description: 'Deactivate an active holy site<faith_scope> = { deactivate_holy_site = <holy_site_name> }', supportedScopes: ['faith'] },
  { name: 'every_defensive_great_holy_wars', description: 'Iterate through all great holy wars this faith is defending against', supportedScopes: ['faith'], supportedTargets: ['ghw'], outputScope: 'ghw', isIterator: true, syntax: "every_defensive_great_holy_wars = { limit = { <triggers> } <effects> }" },
  { name: 'every_faith_character', description: 'Iterate through characters of the scoped faith', supportedScopes: ['faith'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_faith_character = { limit = { <triggers> } <effects> }" },
  { name: 'every_faith_holy_order', description: 'Iterate through all holy orders of the faith', supportedScopes: ['faith'], supportedTargets: ['holy_order'], outputScope: 'holy_order', isIterator: true, syntax: "every_faith_holy_order = { limit = { <triggers> } <effects> }" },
  { name: 'every_faith_playable_ruler', description: 'Iterate through playable rulers of the scoped faith', supportedScopes: ['faith'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_faith_playable_ruler = { limit = { <triggers> } <effects> }" },
  { name: 'every_faith_ruler', description: 'Iterate through rulers of the scoped faith', supportedScopes: ['faith'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_faith_ruler = { limit = { <triggers> } <effects> }" },
  { name: 'every_holy_site', description: 'Iterate through all holy site baronies of a faith', supportedScopes: ['faith'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_holy_site = { limit = { <triggers> } <effects> }" },
  { name: 'ordered_defensive_great_holy_wars', description: 'Iterate through all great holy wars this faith is defending against', supportedScopes: ['faith'], supportedTargets: ['ghw'], outputScope: 'ghw', isIterator: true, syntax: "ordered_defensive_great_holy_wars = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_faith_character', description: 'Iterate through characters of the scoped faith', supportedScopes: ['faith'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_faith_character = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_faith_holy_order', description: 'Iterate through all holy orders of the faith', supportedScopes: ['faith'], supportedTargets: ['holy_order'], outputScope: 'holy_order', isIterator: true, syntax: "ordered_faith_holy_order = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_faith_playable_ruler', description: 'Iterate through playable rulers of the scoped faith', supportedScopes: ['faith'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_faith_playable_ruler = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_faith_ruler', description: 'Iterate through rulers of the scoped faith', supportedScopes: ['faith'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_faith_ruler = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_holy_site', description: 'Iterate through all holy site baronies of a faith', supportedScopes: ['faith'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_holy_site = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'random_defensive_great_holy_wars', description: 'Iterate through all great holy wars this faith is defending against', supportedScopes: ['faith'], supportedTargets: ['ghw'], outputScope: 'ghw', isIterator: true, syntax: "random_defensive_great_holy_wars = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_faith_character', description: 'Iterate through characters of the scoped faith', supportedScopes: ['faith'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_faith_character = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_faith_holy_order', description: 'Iterate through all holy orders of the faith', supportedScopes: ['faith'], supportedTargets: ['holy_order'], outputScope: 'holy_order', isIterator: true, syntax: "random_faith_holy_order = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_faith_playable_ruler', description: 'Iterate through playable rulers of the scoped faith', supportedScopes: ['faith'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_faith_playable_ruler = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_faith_ruler', description: 'Iterate through rulers of the scoped faith', supportedScopes: ['faith'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_faith_ruler = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_holy_site', description: 'Iterate through all holy site baronies of a faith', supportedScopes: ['faith'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_holy_site = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'remove_doctrine', description: 'Remove doctrine from faith<faith_scope> = { remove_doctrine = <doctrine_name> }', supportedScopes: ['faith'], supportedTargets: ['doctrine'] },
  { name: 'remove_religious_head_title', description: 'Removes the religious head title of the faith', supportedScopes: ['faith'], syntax: "remove_religious_head_title = yes" },
  { name: 'set_religious_head_title', description: 'Sets the religious head title of the faith to the given title. set_religious_head_title = scope', supportedScopes: ['faith'], supportedTargets: ['landed_title'] },
  { name: 'start_great_holy_war', description: 'Starts a great holy war.', supportedScopes: ['faith'], syntax: "start_great_holy_war = {target_character = someonetarget_title = some titledelay = script value # Number of days until the war should startwar = some war # Optional. Will make this a directed GHW instead of undirected, and tie it to this specific war}" },
];

/**
 * Effects for religion scope (3 effects)
 */
export const religionEffects: EffectDefinition[] = [
  { name: 'every_faith', description: 'Iterate through all faiths within a religion', supportedScopes: ['religion'], supportedTargets: ['faith'], outputScope: 'faith', isIterator: true, syntax: "every_faith = { limit = { <triggers> } <effects> }" },
  { name: 'ordered_faith', description: 'Iterate through all faiths within a religion', supportedScopes: ['religion'], supportedTargets: ['faith'], outputScope: 'faith', isIterator: true, syntax: "ordered_faith = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'random_faith', description: 'Iterate through all faiths within a religion', supportedScopes: ['religion'], supportedTargets: ['faith'], outputScope: 'faith', isIterator: true, syntax: "random_faith = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
];

/**
 * Effects for army scope (12 effects)
 */
export const armyEffects: EffectDefinition[] = [
  { name: 'add_loot', description: 'Adds loot to the currently scoped raiding/bartering army.', supportedScopes: ['army'], syntax: "Usage:\nadd_loot = VALUE" },
  { name: 'add_supply', description: 'Adds the designated supply to the army\'s supply. Cannot exceed the', supportedScopes: ['army'], syntax: "army's max supply capacity.\nscope:army = { add_supply = 20 }" },
  { name: 'assign_commander', description: 'Assign a commander for the scoped army', supportedScopes: ['army'], supportedTargets: ['character'], syntax: "set_commander = scope:a_character", parameters: ['set_commander'] },
  { name: 'clear_supply', description: 'Clears the designated army\'s supply.', supportedScopes: ['army'], syntax: "scope:army = { clear_supply = yes }" },
  { name: 'deplete_army_by_percentage', description: 'Reduce current army size by the giver percentage', supportedScopes: ['army'], syntax: "Value on the right side determines what portions of soldiers shall perish\nscope:army = { deplete_army_by_percentage = 0.2 }" },
  { name: 'every_army_maa_regiment', description: 'Iterate through all MaA regiments in the army', supportedScopes: ['army'], supportedTargets: ['regiment'], outputScope: 'regiment', isIterator: true, syntax: "scope:army = {\nany_army_maa_regiment = {\ninclude_hired = yes # should it include merc and holy order regiments (yes by default)\n}\n}\nevery_army_maa_regiment = { limit = { <triggers> } <effects> }", parameters: ['any_army_maa_regiment', 'include_hired'] },
  { name: 'ordered_army_maa_regiment', description: 'Iterate through all MaA regiments in the army', supportedScopes: ['army'], supportedTargets: ['regiment'], outputScope: 'regiment', isIterator: true, syntax: "scope:army = {\nany_army_maa_regiment = {\ninclude_hired = yes # should it include merc and holy order regiments (yes by default)\n}\n}\nordered_army_maa_regiment = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['any_army_maa_regiment', 'include_hired', 'order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'random_army_maa_regiment', description: 'Iterate through all MaA regiments in the army', supportedScopes: ['army'], supportedTargets: ['regiment'], outputScope: 'regiment', isIterator: true, syntax: "scope:army = {\nany_army_maa_regiment = {\ninclude_hired = yes # should it include merc and holy order regiments (yes by default)\n}\n}\nrandom_army_maa_regiment = { limit = { <triggers> } (optional) weight = { mtth } <effects> }", parameters: ['any_army_maa_regiment', 'include_hired'] },
  { name: 'refill_supply', description: 'Refills the designated army\'s supply to its max capacity.', supportedScopes: ['army'], syntax: "scope:army = { refull_supply = yes }" },
  { name: 'remove_commander', description: 'Removes the currently assigned commander from the scoped army', supportedScopes: ['army'], syntax: "remove_commander = yes" },
  { name: 'set_army_location', description: 'Teleports the army to the given location. Cannot be done while in combat. Will cause combat to happen with this army as the attacker if there\'s hostiles in the target', supportedScopes: ['army'], supportedTargets: ['province'], syntax: "set_army_location = scope:province" },
  { name: 'subtract_supply', description: 'Subtracts the designated supply to the army\'s supply. Cannot exceed the', supportedScopes: ['army'], syntax: "army's max supply capacity.\nscope:army = { subtract_supply = 20 }" },
];

/**
 * Effects for scheme scope (21 effects)
 */
export const schemeEffects: EffectDefinition[] = [
  { name: 'add_agent_slot', description: 'Add an agent slot of the specific type to the scoped scheme', supportedScopes: ['scheme'] },
  { name: 'add_scheme_breach', description: 'Adds the specified amount of breaches the scoped scheme.', supportedScopes: ['scheme'] },
  { name: 'add_scheme_modifier', description: 'adds the specified scheme modifier, add_scheme_modifier = { type = X days = Y } (days are optional, the modifier will expire in Y days if specified)', supportedScopes: ['scheme'] },
  { name: 'add_scheme_progress', description: 'Add progress to the scope scheme. (progress is in 0.0 - 100.0 range)', supportedScopes: ['scheme'] },
  { name: 'auto_assign_scheme_agents', description: 'Assign competent and willing agents to scheme.', supportedScopes: ['scheme'], syntax: "usage:\n<scheme> = {\nauto_assign_scheme_agents = yes\n}" },
  { name: 'change_opportunities', description: 'Change schemes available opportunities with the given amount.', supportedScopes: ['scheme'] },
  { name: 'end_scheme', description: 'Ends a specific scheme and removes it without any other effect', supportedScopes: ['scheme'] },
  { name: 'every_scheme_agent_character', description: 'Iterate through all characters in agent slots in the scheme', supportedScopes: ['scheme'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_scheme_agent_character = { limit = { <triggers> } <effects> }" },
  { name: 'every_scheme_agent_slot', description: 'Iterate through all agent slots in the scheme', supportedScopes: ['scheme'], supportedTargets: ['agent_slot'], outputScope: 'agent_slot', isIterator: true, syntax: "every_scheme_agent_slot = { limit = { <triggers> } <effects> }" },
  { name: 'expose_scheme', description: 'Exposes the scheme to the defender', supportedScopes: ['scheme'] },
  { name: 'expose_scheme_agent', description: 'Exposes the target character as an agent of the current scheme', supportedScopes: ['scheme'], supportedTargets: ['character'] },
  { name: 'invalidate_scheme', description: 'Ends a specific scheme and removes it. Also runs on_invalidate effects for the scheme and possible contract.', supportedScopes: ['scheme'] },
  { name: 'ordered_scheme_agent_character', description: 'Iterate through all characters in agent slots in the scheme', supportedScopes: ['scheme'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_scheme_agent_character = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_scheme_agent_slot', description: 'Iterate through all agent slots in the scheme', supportedScopes: ['scheme'], supportedTargets: ['agent_slot'], outputScope: 'agent_slot', isIterator: true, syntax: "ordered_scheme_agent_slot = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'random_scheme_agent_character', description: 'Iterate through all characters in agent slots in the scheme', supportedScopes: ['scheme'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_scheme_agent_character = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_scheme_agent_slot', description: 'Iterate through all agent slots in the scheme', supportedScopes: ['scheme'], supportedTargets: ['agent_slot'], outputScope: 'agent_slot', isIterator: true, syntax: "random_scheme_agent_slot = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'remove_agent_slot', description: 'Remove the target agent slot from the scoped scheme', supportedScopes: ['scheme'] },
  { name: 'remove_scheme_modifier', description: 'removes the specified scheme modifier', supportedScopes: ['scheme'] },
  { name: 'reset_scheme_progress', description: 'Resets the scheme\'s accumulated success chance growth, opportunities, and current phase progress.', supportedScopes: ['scheme'], syntax: "reset_scheme_progress = yes" },
  { name: 'scheme_freeze', description: 'scheme_freeze = { reason = LOC_KEY days/months/years = X } freezes the scheme for duration X. 0 duration for indefinite freeze, until scheme_unfreeze is called.', supportedScopes: ['scheme'] },
  { name: 'scheme_unfreeze', description: 'scheme_unfreeze = yes Unfreezes the scheme if it\'s frozen.', supportedScopes: ['scheme'] },
];

/**
 * Effects for war scope (16 effects)
 */
export const warEffects: EffectDefinition[] = [
  { name: 'add_attacker', description: 'adds the target character to the scope war as an attacker', supportedScopes: ['war'], supportedTargets: ['character'] },
  { name: 'add_defender', description: 'adds the target character to the scope war as a defender', supportedScopes: ['war'], supportedTargets: ['character'] },
  { name: 'clear_claimant', description: 'Removes the claimant from a war', supportedScopes: ['war'] },
  { name: 'end_war', description: 'ends the war with the specified winner, end_war = attacker/defender/white_peace', supportedScopes: ['war'] },
  { name: 'every_war_attacker', description: 'Iterate through all attackers in the war', supportedScopes: ['war'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_war_attacker = { limit = { <triggers> } <effects> }" },
  { name: 'every_war_defender', description: 'Iterate through all defenders in the war', supportedScopes: ['war'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_war_defender = { limit = { <triggers> } <effects> }" },
  { name: 'every_war_participant', description: 'Iterate through all participants in the war', supportedScopes: ['war'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_war_participant = { limit = { <triggers> } <effects> }" },
  { name: 'ordered_war_attacker', description: 'Iterate through all attackers in the war', supportedScopes: ['war'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_war_attacker = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_war_defender', description: 'Iterate through all defenders in the war', supportedScopes: ['war'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_war_defender = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_war_participant', description: 'Iterate through all participants in the war', supportedScopes: ['war'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_war_participant = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'random_war_attacker', description: 'Iterate through all attackers in the war', supportedScopes: ['war'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_war_attacker = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_war_defender', description: 'Iterate through all defenders in the war', supportedScopes: ['war'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_war_defender = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_war_participant', description: 'Iterate through all participants in the war', supportedScopes: ['war'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_war_participant = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'remove_participant', description: 'removes the target character from the scope war', supportedScopes: ['war'], supportedTargets: ['character'] },
  { name: 'set_called_to', description: 'sets the target character as already called to the scope war', supportedScopes: ['war'], supportedTargets: ['character'] },
  { name: 'set_casus_belli', description: 'sets the casus belli of the scope war', supportedScopes: ['war'] },
];

/**
 * Effects for activity scope (33 effects)
 */
export const activityEffects: EffectDefinition[] = [
  { name: 'add_activity_log_entry', description: 'add_activity_log_entry = {', supportedScopes: ['activity'], syntax: "key = <loc_key>\nscore = <script_value>\ntags = { <a> <b> <c> } # Optional\nshow_in_conclusion = yes/no # Optional, defaults to no\ncharacter = <character>\ntarget = <character> # Optional\nlocation = <province> # Optional, defaults to current activity loction\nartifact = <artifact> # Optional\n}\nAdd a new log entry to the scoped activity", parameters: ['score', 'tags', 'show_in_conclusion', 'character', 'target', 'location', 'artifact'] },
  { name: 'add_to_current_phase_guest_subset', description: 'add_to_current_phase_guest_subset = {', supportedScopes: ['activity'], syntax: "name = <subset_key>\ntarget = scope:character\n}\nAdds the target character to the designated subset in the current phase.", parameters: ['name', 'target'] },
  { name: 'add_to_guest_subset', description: 'add_to_guest_subset = {', supportedScopes: ['activity'], syntax: "name = <subset_key>\ntarget = scope:character\nphase = <phase_key> # Optional\n}\nAdds the target character to the designated subset. Will add to all phases\nand ongoing subsets if phase is not specified. If a phase is specified, they\nwill be added to all phases of that type.", parameters: ['name', 'target', 'phase'] },
  { name: 'every_activity_phase_location', description: 'Iterate through all province locations of the phases of the activity, optionally limited to unique locations.', supportedScopes: ['activity'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, syntax: "any/every/random_activity_phase_location {\nunique = yes/no\n}\nevery_activity_phase_location = { limit = { <triggers> } <effects> }", parameters: ['unique'] },
  { name: 'every_activity_phase_location_future', description: 'Iterate through all future province locations of the phases of the activity, optionally limited to unique locations. (\'future\' does not include any started phase)', supportedScopes: ['activity'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, syntax: "any/every/random_activity_phase_location_future {\nunique = yes/no\n}\nevery_activity_phase_location_future = { limit = { <triggers> } <effects> }", parameters: ['unique'] },
  { name: 'every_activity_phase_location_past', description: 'Iterate through all past province locations of the phases of the activity, optionally limited to unique locations. (\'past\' only includes ended phases)', supportedScopes: ['activity'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, syntax: "any/every/random_activity_phase_location_future {\nunique = yes/no\n}\nevery_activity_phase_location_past = { limit = { <triggers> } <effects> }", parameters: ['unique'] },
  { name: 'every_attending_character', description: 'Iterate through all characters attending an activity.', supportedScopes: ['activity'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "Invited guests that have not accepted/declined yet are not part of this list.\nSupports an optional state the character must be in.\nany_attending_character = { state = travel/passive/active }\nevery_attending_character = { limit = { <triggers> } <effects> }", parameters: ['any_attending_character'] },
  { name: 'every_guest_subset', description: 'any/every/random_guest_subset = {', supportedScopes: ['activity'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "name = <subset_key>\nphase = <phase_key> # Optional\n}\nIterates through characteres within the specified subset for past, current and\nfuture phases. If phase is specified it will only iterate through characters\nsubsets of that particular phase type.\nevery_guest_subset = { limit = { <triggers> } <effects> }", parameters: ['name', 'phase'] },
  { name: 'every_guest_subset_current_phase', description: 'any/every/random_guest_subset_current_phase = {', supportedScopes: ['activity'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "name = <subset_key>\n}\nIterates through characteres within the specified subset of the current phase.\nevery_guest_subset_current_phase = { limit = { <triggers> } <effects> }", parameters: ['name'] },
  { name: 'every_invited_character', description: 'Iterate through all characters invited to an activity. Once they accept/decline, they are removed from this list.', supportedScopes: ['activity'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_invited_character = { limit = { <triggers> } <effects> }" },
  { name: 'every_special_guest', description: 'Iterate through all special guests of an activity.', supportedScopes: ['activity'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "any_special_guest = { ... }\nevery_special_guest = { limit = { <triggers> } <effects> }", parameters: ['any_special_guest'] },
  { name: 'ordered_activity_phase_location', description: 'Iterate through all province locations of the phases of the activity, optionally limited to unique locations.', supportedScopes: ['activity'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, syntax: "any/every/random_activity_phase_location {\nunique = yes/no\n}\nordered_activity_phase_location = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['unique', 'order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_activity_phase_location_future', description: 'Iterate through all future province locations of the phases of the activity, optionally limited to unique locations. (\'future\' does not include any started phase)', supportedScopes: ['activity'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, syntax: "any/every/random_activity_phase_location_future {\nunique = yes/no\n}\nordered_activity_phase_location_future = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['unique', 'order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_activity_phase_location_past', description: 'Iterate through all past province locations of the phases of the activity, optionally limited to unique locations. (\'past\' only includes ended phases)', supportedScopes: ['activity'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, syntax: "any/every/random_activity_phase_location_future {\nunique = yes/no\n}\nordered_activity_phase_location_past = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['unique', 'order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_attending_character', description: 'Iterate through all characters attending an activity.', supportedScopes: ['activity'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "Invited guests that have not accepted/declined yet are not part of this list.\nSupports an optional state the character must be in.\nany_attending_character = { state = travel/passive/active }\nordered_attending_character = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['any_attending_character', 'order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_guest_subset', description: 'any/every/random_guest_subset = {', supportedScopes: ['activity'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "name = <subset_key>\nphase = <phase_key> # Optional\n}\nIterates through characteres within the specified subset for past, current and\nfuture phases. If phase is specified it will only iterate through characters\nsubsets of that particular phase type.\nordered_guest_subset = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['name', 'phase', 'order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_guest_subset_current_phase', description: 'any/every/random_guest_subset_current_phase = {', supportedScopes: ['activity'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "name = <subset_key>\n}\nIterates through characteres within the specified subset of the current phase.\nordered_guest_subset_current_phase = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['name', 'order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_invited_character', description: 'Iterate through all characters invited to an activity. Once they accept/decline, they are removed from this list.', supportedScopes: ['activity'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_invited_character = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_special_guest', description: 'Iterate through all special guests of an activity.', supportedScopes: ['activity'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "any_special_guest = { ... }\nordered_special_guest = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['any_special_guest', 'order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'progress_activity_phase_after', description: 'Progress the current activity phase forward after X days.', supportedScopes: ['activity'], syntax: "progress_activity_phase_after = { days = X weeks = Z months = Y}" },
  { name: 'random_activity_phase_location', description: 'Iterate through all province locations of the phases of the activity, optionally limited to unique locations.', supportedScopes: ['activity'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, syntax: "any/every/random_activity_phase_location {\nunique = yes/no\n}\nrandom_activity_phase_location = { limit = { <triggers> } (optional) weight = { mtth } <effects> }", parameters: ['unique'] },
  { name: 'random_activity_phase_location_future', description: 'Iterate through all future province locations of the phases of the activity, optionally limited to unique locations. (\'future\' does not include any started phase)', supportedScopes: ['activity'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, syntax: "any/every/random_activity_phase_location_future {\nunique = yes/no\n}\nrandom_activity_phase_location_future = { limit = { <triggers> } (optional) weight = { mtth } <effects> }", parameters: ['unique'] },
  { name: 'random_activity_phase_location_past', description: 'Iterate through all past province locations of the phases of the activity, optionally limited to unique locations. (\'past\' only includes ended phases)', supportedScopes: ['activity'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, syntax: "any/every/random_activity_phase_location_future {\nunique = yes/no\n}\nrandom_activity_phase_location_past = { limit = { <triggers> } (optional) weight = { mtth } <effects> }", parameters: ['unique'] },
  { name: 'random_attending_character', description: 'Iterate through all characters attending an activity.', supportedScopes: ['activity'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "Invited guests that have not accepted/declined yet are not part of this list.\nSupports an optional state the character must be in.\nany_attending_character = { state = travel/passive/active }\nrandom_attending_character = { limit = { <triggers> } (optional) weight = { mtth } <effects> }", parameters: ['any_attending_character'] },
  { name: 'random_guest_subset', description: 'any/every/random_guest_subset = {', supportedScopes: ['activity'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "name = <subset_key>\nphase = <phase_key> # Optional\n}\nIterates through characteres within the specified subset for past, current and\nfuture phases. If phase is specified it will only iterate through characters\nsubsets of that particular phase type.\nrandom_guest_subset = { limit = { <triggers> } (optional) weight = { mtth } <effects> }", parameters: ['name', 'phase'] },
  { name: 'random_guest_subset_current_phase', description: 'any/every/random_guest_subset_current_phase = {', supportedScopes: ['activity'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "name = <subset_key>\n}\nIterates through characteres within the specified subset of the current phase.\nrandom_guest_subset_current_phase = { limit = { <triggers> } (optional) weight = { mtth } <effects> }", parameters: ['name'] },
  { name: 'random_invited_character', description: 'Iterate through all characters invited to an activity. Once they accept/decline, they are removed from this list.', supportedScopes: ['activity'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_invited_character = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_special_guest', description: 'Iterate through all special guests of an activity.', supportedScopes: ['activity'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "any_special_guest = { ... }\nrandom_special_guest = { limit = { <triggers> } (optional) weight = { mtth } <effects> }", parameters: ['any_special_guest'] },
  { name: 'remove_from_current_phase_guest_subset', description: 'remove_from_current_phase_guest_subset = {', supportedScopes: ['activity'], syntax: "name = <subset_key>\ntarget = scope:character\n}\nRemoves the target character from the designated subset in the current phase.", parameters: ['name', 'target'] },
  { name: 'remove_from_guest_subset', description: 'add_to_guest_subset = {', supportedScopes: ['activity'], syntax: "name = <subset_key>\ntarget = scope:character\nphase = <phase_key> # Optional\n}\nRemoves the target character from the designated subset. Will remove from all\nupcoming and ongoing subsets if phase is not specified. If a phase is specified,\nthey will be removed from all phases of that type.", parameters: ['name', 'target', 'phase'] },
  { name: 'set_activity_host', description: 'set_activity_host = character', supportedScopes: ['activity'], supportedTargets: ['character'], syntax: "The host of the scoped activity is set to the target character" },
  { name: 'set_special_guest', description: 'Sets the target character as a special guest for the scoped activity, replacing the existing one if set.', supportedScopes: ['activity'], syntax: "The character will be invited to the activity if they are not already attending, potentially using one of the slots reserved for effect invites.\nSpecify the type of special guest to set - this effect will error if the activity doesn't involve the specified guest type.\nset_special_guest = {\ntype = <special guest key>\ntarget = scope:character\n}", parameters: ['type', 'target'] },
  { name: 'skip_activity_phase', description: 'Skip the current activity phase, either directly to the next phase, or to completion. (fast-forwards) skip_activity_phase = yes/no.', supportedScopes: ['activity'] },
];

/**
 * Effects for artifact scope (26 effects)
 */
export const artifactEffects: EffectDefinition[] = [
  { name: 'add_artifact_history', description: 'Adds a history entry to the artifact, could for example be a reforging event', supportedScopes: ['artifact'], syntax: "type = enum - history entry type\ndate = jomini date - when this historical event took place\nactor = character - who is the actor in the event, for example who created it\nrecipient = character - who is the recipient in the event, for example who was the artifact given to\nlocation = province - where the event took place", parameters: ['type', 'date', 'actor', 'recipient', 'location'] },
  { name: 'add_artifact_modifier', description: 'Adds a static modifier to the given artifact', supportedScopes: ['artifact'], syntax: "add_artifact_modifier = modifier_name\nNOTE: does not support duration!" },
  { name: 'add_artifact_title_history', description: 'Adds the title history of the given title to the scoped artifacts history', supportedScopes: ['artifact'], syntax: "add_artifact_title_history = {}\ntarget = title scope - landed title to take history from\ndate = game date - from which date onwards to copy historical entries", parameters: ['target', 'date'] },
  { name: 'add_durability', description: 'Add this much to the artifacts durability', supportedScopes: ['artifact'] },
  { name: 'clear_artifact_modifiers', description: 'Removes all modifiers from the scoped artifact', supportedScopes: ['artifact'], syntax: "clear_artifact_modifiers = yes" },
  { name: 'copy_artifact_modifiers', description: 'Copies the modifiers of the target artifact. Does *not* clear out existing modifiers', supportedScopes: ['artifact'], supportedTargets: ['artifact'], syntax: "copy_artifact_modifiers = target_artifact" },
  { name: 'equip_artifact_to_owner', description: 'Makes the owner of the scoped artifact equip it, will fail if there already is an equipment in the artifact\'s slot.', supportedScopes: ['artifact'] },
  { name: 'equip_artifact_to_owner_replace', description: 'Makes the owner of the scoped artifact equip it, will replace the first held artifact if all slots of its type are filled.', supportedScopes: ['artifact'] },
  { name: 'every_artifact_claimant', description: 'Iterate through all characters with a claim on the scoped artifact', supportedScopes: ['artifact'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_artifact_claimant = { limit = { <triggers> } <effects> }" },
  { name: 'every_artifact_house_claimant', description: 'Iterate through all dynasty houses with a claim on the scoped artifact', supportedScopes: ['artifact'], supportedTargets: ['dynasty_house'], outputScope: 'dynasty_house', isIterator: true, syntax: "every_artifact_house_claimant = { limit = { <triggers> } <effects> }" },
  { name: 'ordered_artifact_claimant', description: 'Iterate through all characters with a claim on the scoped artifact', supportedScopes: ['artifact'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_artifact_claimant = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_artifact_house_claimant', description: 'Iterate through all dynasty houses with a claim on the scoped artifact', supportedScopes: ['artifact'], supportedTargets: ['dynasty_house'], outputScope: 'dynasty_house', isIterator: true, syntax: "ordered_artifact_house_claimant = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'random_artifact_claimant', description: 'Iterate through all characters with a claim on the scoped artifact', supportedScopes: ['artifact'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_artifact_claimant = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_artifact_house_claimant', description: 'Iterate through all dynasty houses with a claim on the scoped artifact', supportedScopes: ['artifact'], supportedTargets: ['dynasty_house'], outputScope: 'dynasty_house', isIterator: true, syntax: "random_artifact_house_claimant = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'reforge_artifact', description: 'Reforges the given artifact, restoring its durability and potentially changing any other attributes such as type or modifiers unless those fields are left empty', supportedScopes: ['artifact'], syntax: "Be aware that we make use of the current scopes implicitly. This is done in common/artifacts/visuals\nname = dynamic description - artifact name\ndescription = dynamic description - artifact description\nrarity = enum - artifact rarity, ex. legendary\ntype = flag - inventory slot type, ex. trinket\nmodifier = static modifier - applied to the character whom wields this artifact\ndurability = script value - new durability, will be max by default\nmax_durability = script value - Optional. A value for the max durability, which would override the one normally assigned by the defines\ndecaying = yes/no - Optional. Set if artifact decays with time. Yes by default\nhistory = artifact history entry - custom history entry to denote for example that this is artifact was reforged by someone else than the owner\ntype = artifact history entry type - available types:\ncreated_before_history\ncreated\nprize_created\ndiscovered\ncreator_discovered\nclaimed_by_house\ngiven\nstolen\ninherited\nconquest\ntaken_in_siege\ntaken_in_battle\nwon_in_duel\npurchased\nprize_awarded\nransomed\nreforged\ntemplate = artifact scripted template - a scripted base template with triggers and modifiers\nvisuals = artifact visual type - how this artifact should appear visually\ngenerate_history = bool - automatically generate a new history entry if none has been scripted?\nquality = script value - new quality, used in AI scoring\nwealth = script value - new wealth, used in AI scoring\ncreator = character scope - set a custom creator of the artifact ( default is the owner )\nvisuals_source = scope containing landed title, dynasty or house - set a source of coat of arms graphics for the artifact\n(only few artifact models actually make use of it. Most notable - banners)", parameters: ['name', 'description', 'rarity', 'type', 'modifier', 'durability', 'max_durability', 'decaying', 'history', 'template', 'visuals', 'generate_history', 'quality', 'wealth', 'creator', 'visuals_source'] },
  { name: 'remove_artifact_feature_group', description: 'Removes th feature from the specified group from the artifact.', supportedScopes: ['artifact'], syntax: "Cannot remove required groups.\nremove_artifact_feature_group = key" },
  { name: 'remove_artifact_modifier', description: 'Removes a static modifier to the given artifact', supportedScopes: ['artifact'], syntax: "remove_artifact_modifier = modifier_name\nNOTE: does not support duration!" },
  { name: 'set_artifact_description', description: 'Sets the description of the given artifact', supportedScopes: ['artifact'], syntax: "set_artifact_description = dynamic desc" },
  { name: 'set_artifact_feature', description: 'Sets the specified feature on the artifact.', supportedScopes: ['artifact'], syntax: "If there's already a feature of that group, it gets overridden.\nset_artifact_feature = key" },
  { name: 'set_artifact_feature_group', description: 'Sets a feature from the specified group on the artifact.', supportedScopes: ['artifact'], syntax: "Uses the current scopes. Uses the weighting from the group.\nIf there's already a feature of that group, it gets overridden.\nset_artifact_feature_group = key" },
  { name: 'set_artifact_name', description: 'Sets the name of the given artifact', supportedScopes: ['artifact'], syntax: "set_artifact_name = dynamic name" },
  { name: 'set_artifact_rarity', description: 'Sets the rarity of the scoped artifact. Note that this does not update graphics and the like', supportedScopes: ['artifact'], syntax: "set_artifact_rarity = common" },
  { name: 'set_max_durability', description: 'Sets the artifact\'s max durability', supportedScopes: ['artifact'] },
  { name: 'set_owner', description: 'Change the artifacts owner and transfer it to the given character', supportedScopes: ['artifact'], syntax: "set_artifact_owner = {}\ntarget = character scope - the new owner character\nhistory = artifact history entry - custom history entry to denote for example that this is artifact was stolen rather than given\ngenerate_history = bool - automatically generate a new history entry if none has been scripted?", parameters: ['set_artifact_owner', 'target', 'history', 'generate_history'] },
  { name: 'set_should_decay', description: 'Set if the scoped artifact should decay with time or not', supportedScopes: ['artifact'], syntax: "set_should_decay = yes/no" },
  { name: 'unequip_artifact_from_owner', description: 'Makes the owner of the scoped artifact unequip it.', supportedScopes: ['artifact'] },
];

/**
 * Effects for secret scope (13 effects)
 */
export const secretEffects: EffectDefinition[] = [
  { name: 'add_secret_participant', description: 'Adds an participant to the secret', supportedScopes: ['secret'], supportedTargets: ['character'] },
  { name: 'disable_exposure_by', description: 'Forbids the target character from exposing the secret, disable_exposure_by = target_character', supportedScopes: ['secret'], supportedTargets: ['character'] },
  { name: 'every_secret_knower', description: 'Iterate through all characters who know the secret', supportedScopes: ['secret'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_secret_knower = { limit = { <triggers> } <effects> }" },
  { name: 'every_secret_participant', description: 'Iterate through participants in a secret', supportedScopes: ['secret'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_secret_participant = { limit = { <triggers> } <effects> }" },
  { name: 'expose_secret', description: 'Exposes the scope secret', supportedScopes: ['secret'], supportedTargets: ['character'] },
  { name: 'ordered_secret_knower', description: 'Iterate through all characters who know the secret', supportedScopes: ['secret'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_secret_knower = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_secret_participant', description: 'Iterate through participants in a secret', supportedScopes: ['secret'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_secret_participant = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'random_secret_knower', description: 'Iterate through all characters who know the secret', supportedScopes: ['secret'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_secret_knower = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_secret_participant', description: 'Iterate through participants in a secret', supportedScopes: ['secret'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_secret_participant = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'remove_secret', description: 'Removes the scope secret', supportedScopes: ['secret'] },
  { name: 'reveal_to', description: 'Reveals the scope secret to the target character', supportedScopes: ['secret'], supportedTargets: ['character'] },
  { name: 'set_secret_owner', description: 'Sets a new owner for the secret', supportedScopes: ['secret'], supportedTargets: ['character'] },
  { name: 'spend_by', description: 'Spends the scope secret, spend_by = target_character', supportedScopes: ['secret'], supportedTargets: ['character'] },
];

/**
 * Effects for faction scope (14 effects)
 */
export const factionEffects: EffectDefinition[] = [
  { name: 'add_faction_discontent', description: 'add_faction_discontent = X adds (or subtracts) discontent to the scope faction', supportedScopes: ['faction'] },
  { name: 'destroy_faction', description: 'the scoped faction is destroyed [yes|no]', supportedScopes: ['faction'] },
  { name: 'every_faction_county_member', description: 'Iterate through all faction county members', supportedScopes: ['faction'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_faction_county_member = { limit = { <triggers> } <effects> }" },
  { name: 'every_faction_member', description: 'Iterate through all faction character members', supportedScopes: ['faction'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_faction_member = { limit = { <triggers> } <effects> }" },
  { name: 'faction_remove_war', description: 'Removes the war currently associated with the faction', supportedScopes: ['faction'], syntax: "faction_remove_war = yes" },
  { name: 'faction_start_war', description: 'The scope faction starts the war agains their target.', supportedScopes: ['faction'], syntax: "faction_start_war = {\ntitle = [optional]\n}", parameters: ['title'] },
  { name: 'ordered_faction_county_member', description: 'Iterate through all faction county members', supportedScopes: ['faction'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_faction_county_member = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_faction_member', description: 'Iterate through all faction character members', supportedScopes: ['faction'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_faction_member = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'random_faction_county_member', description: 'Iterate through all faction county members', supportedScopes: ['faction'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_faction_county_member = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_faction_member', description: 'Iterate through all faction character members', supportedScopes: ['faction'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_faction_member = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'remove_special_character', description: 'Removes the special character for the scope faction', supportedScopes: ['faction'] },
  { name: 'remove_special_title', description: 'Removes the special character for the scope faction', supportedScopes: ['faction'] },
  { name: 'set_special_character', description: 'Sets the special character for the scope faction', supportedScopes: ['faction'], supportedTargets: ['character'] },
  { name: 'set_special_title', description: 'Sets the special title for the scope faction', supportedScopes: ['faction'], supportedTargets: ['landed_title'] },
];

/**
 * Effects for holy_order scope (3 effects)
 */
export const holyorderEffects: EffectDefinition[] = [
  { name: 'every_leased_title', description: 'Iterate through all titles leased to a holy order', supportedScopes: ['holy_order'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_leased_title = { limit = { <triggers> } <effects> }" },
  { name: 'ordered_leased_title', description: 'Iterate through all titles leased to a holy order', supportedScopes: ['holy_order'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_leased_title = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'random_leased_title', description: 'Iterate through all titles leased to a holy order', supportedScopes: ['holy_order'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_leased_title = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
];

/**
 * Effects for inspiration scope (2 effects)
 */
export const inspirationEffects: EffectDefinition[] = [
  { name: 'change_inspiration_progress', description: 'change_progress = int', supportedScopes: ['inspiration'], syntax: "Changes the progress of the scoped inspiration" },
  { name: 'invest_gold', description: 'invest_gold = value', supportedScopes: ['inspiration'], syntax: "Invests gold into the scoped inspiration from its sponsor, it handles the removal of the gold from the sponsor, must be a positive value" },
];

/**
 * Effects for story scope (2 effects)
 */
export const storyEffects: EffectDefinition[] = [
  { name: 'end_story', description: 'Ends a story and executes it\'s on_end effect, the story can no longer be accessed after this', supportedScopes: ['story'] },
  { name: 'make_story_owner', description: '= character_target  makes the character the new owner of the story', supportedScopes: ['story'], supportedTargets: ['character'] },
];

/**
 * Effects for casus_belli scope (5 effects)
 */
export const casusbelliEffects: EffectDefinition[] = [
  { name: 'add_from_contribution_attackers', description: 'Adds prestige, gold and piety based on contribution to allied attackers. Supports almost all currencies.', supportedScopes: ['casus_belli'], syntax: "* prestige, gold, piety, merit and influence are awarded to the participating rulers\n* dynasty_prestige is awarded to the participating rulers' dynasty\n* treasury is paid to the rulers' primary title's treasury cache, if it supports a treasury. Errors will occur otherwise.\n* herd and provisions are paid to the rulers' domicile, if it exists and supports the currency. Errors will occur otherwise.\n* Can only be called once per casus belli. Errors will occur otherwise\nUsage:\ncasus_belli = {\nadd_from_contribution_attackers = {\nprestige = medium_prestige_value\ngold = medium_gold_value\npiety = medium_piety_value\ninfluence = medium_influence_value\nmerit = medium_herd_value\nrenown = 50\ntreasury = medium_treasury_value\nherd = medium_herd_value\nprovisions = medium_provisions_value\nbarter_goods = 50\nopinion = {\nmodifier = contributed_in_war\n}\n}\n}", parameters: ['casus_belli', 'prestige', 'piety', 'influence', 'merit', 'renown', 'treasury', 'herd', 'provisions', 'barter_goods', 'opinion', 'modifier'] },
  { name: 'add_from_contribution_defenders', description: 'Adds prestige, gold and piety based on contribution to allied defenders. Supports almost all currencies.', supportedScopes: ['casus_belli'], syntax: "Usage:\ncasus_belli = {\nadd_from_contribution_defenders = {\nprestige = medium_prestige_value\ngold = medium_gold_value\npiety = medium_piety_value\ninfluence = medium_influence_value\nmerit = medium_herd_value\nrenown = medium_renown_value\ntreasury = medium_treasury_value\nherd = medium_herd_value\nprovisions = medium_provisions_value\nopinion = {\nmodifier = contributed_in_war\n}\n}\n}", parameters: ['casus_belli', 'prestige', 'piety', 'influence', 'merit', 'renown', 'treasury', 'herd', 'provisions', 'opinion', 'modifier'] },
  { name: 'every_target_title', description: 'Iterate through all casus belli\'s target titles', supportedScopes: ['casus_belli'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_target_title = { limit = { <triggers> } <effects> }" },
  { name: 'ordered_target_title', description: 'Iterate through all casus belli\'s target titles', supportedScopes: ['casus_belli'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_target_title = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'random_target_title', description: 'Iterate through all casus belli\'s target titles', supportedScopes: ['casus_belli'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_target_title = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
];

/**
 * Effects for travel_plan scope (28 effects)
 */
export const travelplanEffects: EffectDefinition[] = [
  { name: 'abort_travel_plan', description: 'Abort the travel plan immediately - no further travelling is executed, the on_action effect \'on_travel_plan_abort\' will be run.', supportedScopes: ['travel_plan'], syntax: "abort_travel_plan = yes/no." },
  { name: 'add_companion', description: 'Adds a character as a companion to the scoped travel plan.', supportedScopes: ['travel_plan'], supportedTargets: ['character'], syntax: "add_companion = CHARACTER" },
  { name: 'add_destination_progress', description: 'Add X days towards the progress of the travel plan to the next destination. If the next destination is reached, excess progress is discarded.', supportedScopes: ['travel_plan'], syntax: "'on_travel_plan_movement' on_action will not be triggered for any of the provinces. 'on_travel_plan_arrival' will be triggered.\nadd_destination_progress = {\ndays/weeks/months/years = X\n}" },
  { name: 'add_travel_option', description: 'Adds the travel option specified in the RHS to the scope travel plan.<travel_plan> = { add_travel_option = name }', supportedScopes: ['travel_plan'] },
  { name: 'add_travel_plan_modifier', description: 'Add a modifier to a travel plan', supportedScopes: ['travel_plan'], syntax: "add_travel_plan_modifier = name\nadd_travel_plan_modifier = { modifier = name days/weeks/months/years = int }\nYou can also add an optional 'desc' field. This is a dynamic description that'll be used for your timed modifier" },
  { name: 'add_travel_waypoint', description: 'Adds a travel waypoint just ahead of the current travel location, and change the path accordingly.', supportedScopes: ['travel_plan'], syntax: "<travel_plan> = { add_travel_waypoint = province }" },
  { name: 'cancel_travel_plan', description: 'Cancel travel plan future path, leave any associated activities, and reroute to home.', supportedScopes: ['travel_plan'], syntax: "cancel_travel_plan = yes/no." },
  { name: 'complete_travel_plan', description: 'Complete the travel plan immediately - no further travelling is executed, and the on_action effect \'on_travel_plan_complete\' is run.', supportedScopes: ['travel_plan'], syntax: "complete_travel_plan = yes/no" },
  { name: 'delay_travel_plan', description: 'Delay the travel plan by specific time duration. Will pause the travel plan, and resume after the duration ends.', supportedScopes: ['travel_plan'], syntax: "Will add to any existing delay duration, unless 'add = no' is set.\ndelay_travel_plan = {\ndays/weeks/months/years = X\nadd = yes/no [optional]\n}", parameters: ['add'] },
  { name: 'every_entourage_character', description: 'Iterate through all characters travelling along with the travel plan owner. Includes travel leader, but not the travel plan owner.', supportedScopes: ['travel_plan'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_entourage_character = { limit = { <triggers> } <effects> }" },
  { name: 'every_future_path_location', description: 'Iterate through all provinces this travel plan has in its route.', supportedScopes: ['travel_plan'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, syntax: "every_future_path_location = { limit = { <triggers> } <effects> }" },
  { name: 'every_visited_location', description: 'Iterate through all provinces this travel plan has arrived at so far.', supportedScopes: ['travel_plan'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, syntax: "every_visited_location = { limit = { <triggers> } <effects> }" },
  { name: 'ordered_entourage_character', description: 'Iterate through all characters travelling along with the travel plan owner. Includes travel leader, but not the travel plan owner.', supportedScopes: ['travel_plan'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_entourage_character = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_future_path_location', description: 'Iterate through all provinces this travel plan has in its route.', supportedScopes: ['travel_plan'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, syntax: "ordered_future_path_location = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_visited_location', description: 'Iterate through all provinces this travel plan has arrived at so far.', supportedScopes: ['travel_plan'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, syntax: "ordered_visited_location = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'pause_travel_plan', description: 'Pause the travel plan, until explicitly resumed. Any existing pause resume date is removed.', supportedScopes: ['travel_plan'], syntax: "pause_travel_plan = yes/no." },
  { name: 'pause_travel_plan_mp', description: 'Pause the travel plan, until resumed, if in multiplayer. Any existing pause resume date is removed.', supportedScopes: ['travel_plan'], syntax: "pause_travel_plan_mp = yes/no." },
  { name: 'random_entourage_character', description: 'Iterate through all characters travelling along with the travel plan owner. Includes travel leader, but not the travel plan owner.', supportedScopes: ['travel_plan'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_entourage_character = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_future_path_location', description: 'Iterate through all provinces this travel plan has in its route.', supportedScopes: ['travel_plan'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, syntax: "random_future_path_location = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_visited_location', description: 'Iterate through all provinces this travel plan has arrived at so far.', supportedScopes: ['travel_plan'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, syntax: "random_visited_location = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'remove_all_travel_plan_modifier_instances', description: 'Remove all instances of a modifier from a travel plan', supportedScopes: ['travel_plan'], syntax: "remove_all_travel_plan_modifier_instances = name" },
  { name: 'remove_character', description: 'Remove character from a travel plan. You cannot remove the travel plan owner.', supportedScopes: ['travel_plan'], supportedTargets: ['character'], syntax: "remove_character = CHARACTER." },
  { name: 'remove_travel_option', description: 'Removes the travel option specified in the RHS from the scope travel plan.<travel_plan> = { remove_travel_option = name }', supportedScopes: ['travel_plan'] },
  { name: 'remove_travel_plan_modifier', description: 'Remove a modifier from a travel plan', supportedScopes: ['travel_plan'], syntax: "remove_travel_plan_modifier = name" },
  { name: 'resume_travel_plan', description: 'Resume the travel plan, if paused.', supportedScopes: ['travel_plan'], syntax: "resume_travel_plan = yes/no." },
  { name: 'resume_travel_plan_mp', description: 'Resume the travel plan, if paused for multiplayer purposes via \'pause_travel_plan_mp\'.', supportedScopes: ['travel_plan'], syntax: "resume_travel_plan_mp = yes/no." },
  { name: 'set_travel_leader', description: 'Set a character as the travel leader on the scoped travel plan. Any current leader is moved to be a regular companion in the entourage.', supportedScopes: ['travel_plan'], supportedTargets: ['character'], syntax: "set_travel_leader = CHARACTER" },
  { name: 'set_travel_plan_owner', description: 'Set a character as the owner of the scoped travel plan. If they\'re already the travel leader or an entourage member, it will remove them from those positions. The current owner is moved to be a regular companion in the entourage.', supportedScopes: ['travel_plan'], supportedTargets: ['character'], syntax: "set_travel_plan_owner = CHARACTER" },
];

/**
 * Effects for struggle scope (17 effects)
 */
export const struggleEffects: EffectDefinition[] = [
  { name: 'activate_struggle_catalyst', description: 'Activate a catalyst, activate_struggle_catalyst = { catalyst = X character = Y}where X is a catalystY is scope:character # optionalsimplified: activate_struggle_catalyst = <catalyst>', supportedScopes: ['struggle'] },
  { name: 'change_struggle_phase', description: 'Change the phase from the current one to a listed scripted phase without going into transition phase', supportedScopes: ['struggle'], syntax: "change_struggle_phase = X\nchange_struggle_phase = { struggle_phase = X with_transition = yes/no }\nwhere X is a struggle phase type" },
  { name: 'change_struggle_phase_duration', description: 'Change the current phase duration in the scoped Struggle.', supportedScopes: ['struggle'], syntax: "change_struggle_phase_duration = { duration = { points = X } }\nor\nchange_struggle_phase_duration = { duration = { days/weeks/months/years = Y }\nwhereX is amount of points(can be negative);Y is amount of days/weeks/months/years (can be negative)" },
  { name: 'end_struggle', description: 'End a struggle, end_struggle = yes', supportedScopes: ['struggle'] },
  { name: 'every_interloper_ruler', description: 'Iterate through all characters that are interloper in a struggle.', supportedScopes: ['struggle'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_interloper_ruler = { limit = { <triggers> } <effects> }" },
  { name: 'every_involved_county', description: 'Iterate through all counties that are involved in a struggle', supportedScopes: ['struggle'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_involved_county = { limit = { <triggers> } <effects> }" },
  { name: 'every_involved_ruler', description: 'Iterate through all characters that are involved in a struggle.', supportedScopes: ['struggle'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_involved_ruler = { limit = { <triggers> } <effects> }" },
  { name: 'ordered_interloper_ruler', description: 'Iterate through all characters that are interloper in a struggle.', supportedScopes: ['struggle'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_interloper_ruler = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_involved_county', description: 'Iterate through all counties that are involved in a struggle', supportedScopes: ['struggle'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_involved_county = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_involved_ruler', description: 'Iterate through all characters that are involved in a struggle.', supportedScopes: ['struggle'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_involved_ruler = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'random_interloper_ruler', description: 'Iterate through all characters that are interloper in a struggle.', supportedScopes: ['struggle'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_interloper_ruler = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_involved_county', description: 'Iterate through all counties that are involved in a struggle', supportedScopes: ['struggle'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_involved_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_involved_ruler', description: 'Iterate through all characters that are involved in a struggle.', supportedScopes: ['struggle'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_involved_ruler = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'set_culture_as_involved', description: 'Set a culture as involved in the scoped Struggle.', supportedScopes: ['struggle'], supportedTargets: ['culture'] },
  { name: 'set_culture_as_uninvolved', description: 'Set a culture as involved in the scoped Struggle.', supportedScopes: ['struggle'], supportedTargets: ['culture'] },
  { name: 'set_faith_as_involved', description: 'Set a faith as involved in the scoped Struggle.', supportedScopes: ['struggle'], supportedTargets: ['faith'] },
  { name: 'set_faith_as_uninvolved', description: 'Set a faith as uninvolved in the scoped Struggle.', supportedScopes: ['struggle'], supportedTargets: ['faith'] },
];

/**
 * Effects for legend scope (19 effects)
 */
export const legendEffects: EffectDefinition[] = [
  { name: 'add_legend_county_modifier', description: 'Add a modifier to a legend whose effects should be applied to the county', supportedScopes: ['legend'], syntax: "add_legend_county_modifier = name\nadd_legend_county_modifier = { modifier = name days/weeks/months/years = int }\nYou can also add an optional 'desc' field. This is a dynamic description that'll be used for your timed modifier" },
  { name: 'add_legend_owner_modifier', description: 'Add a modifier to a legend whose effects should be applied to the owner', supportedScopes: ['legend'], syntax: "add_legend_owner_modifier = name\nadd_legend_owner_modifier = { modifier = name days/weeks/months/years = int }\nYou can also add an optional 'desc' field. This is a dynamic description that'll be used for your timed modifier" },
  { name: 'add_legend_province_modifier', description: 'Add a modifier to a legend whose effects should be applied to the provinces', supportedScopes: ['legend'], syntax: "add_legend_province_modifier = name\nadd_legend_province_modifier = { modifier = name days/weeks/months/years = int }\nYou can also add an optional 'desc' field. This is a dynamic description that'll be used for your timed modifier" },
  { name: 'clear_legend_chapter', description: 'Clears the localization key for the named chapter of the scoped legend.', supportedScopes: ['legend'], syntax: "clear_legend_chapter = opening" },
  { name: 'every_legend_promoter', description: 'Gets all promoters of the scoped legend', supportedScopes: ['legend'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_legend_promoter = { limit = { <triggers> } <effects> }" },
  { name: 'every_spread_province', description: 'Gets all provinces the scoped legend has spread into', supportedScopes: ['legend'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, syntax: "every_spread_province = { limit = { <triggers> } <effects> }" },
  { name: 'ordered_legend_promoter', description: 'Gets all promoters of the scoped legend', supportedScopes: ['legend'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_legend_promoter = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_spread_province', description: 'Gets all provinces the scoped legend has spread into', supportedScopes: ['legend'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, syntax: "ordered_spread_province = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'random_legend_promoter', description: 'Gets all promoters of the scoped legend', supportedScopes: ['legend'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_legend_promoter = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_spread_province', description: 'Gets all provinces the scoped legend has spread into', supportedScopes: ['legend'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, syntax: "random_spread_province = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'remove_all_legend_county_modifier_instances', description: 'Remove all instances of a modifier from affecting the counties in a legend', supportedScopes: ['legend'], syntax: "remove_all_legend_county_modifier_instances = name" },
  { name: 'remove_all_legend_owner_modifier_instances', description: 'Remove all instances of a modifier from affecting the owner of a legend', supportedScopes: ['legend'], syntax: "remove_all_legend_owner_modifier_instances = name" },
  { name: 'remove_all_legend_province_modifier_instances', description: 'Remove all instances of a modifier from affecting the provinces in a legend', supportedScopes: ['legend'], syntax: "remove_all_legend_province_modifier_instances = name" },
  { name: 'remove_legend_county_modifier', description: 'Remove a modifier from affecting the counties in a legend', supportedScopes: ['legend'], syntax: "remove_legend_county_modifier = name" },
  { name: 'remove_legend_owner_modifier', description: 'Remove a modifier from affecting the owner of a legend', supportedScopes: ['legend'], syntax: "remove_legend_owner_modifier = name" },
  { name: 'remove_legend_province_modifier', description: 'Remove a modifier from affecting the provinces in a legend', supportedScopes: ['legend'], syntax: "remove_legend_province_modifier = name" },
  { name: 'set_legend_chapter', description: 'Sets the localization key for the named chapter of the scoped legend to the new value.', supportedScopes: ['legend'], syntax: "set_legend_chapter = { name = opening localization_key = <loc_key> }" },
  { name: 'set_legend_property', description: 'Sets the object at the named property of the scoped legend to the new value.', supportedScopes: ['legend'], syntax: "set_legend_property = { name = animal_type target = var:hunt_type }" },
  { name: 'set_legend_quality', description: 'Sets the legend quality to the new value.', supportedScopes: ['legend'], syntax: "set_legend_quality = famed\nfamed, illustrious, mythical" },
];

/**
 * Effects for accolade scope (4 effects)
 */
export const accoladeEffects: EffectDefinition[] = [
  { name: 'activate_accolade', description: 'Activates the scoped Accolade, if there are free slots available else it will be deactivated', supportedScopes: ['accolade'], syntax: "activate_accolade = yes" },
  { name: 'add_glory', description: 'Add this much to the Accolades glory', supportedScopes: ['accolade'] },
  { name: 'deactivate_accolade', description: 'Deactivates the scoped Accolade, does nothing if it\'s already inactive', supportedScopes: ['accolade'], syntax: "deactivate_accolade = yes" },
  { name: 'remove_acclaimed_knight', description: 'Removes the acclaimed knight from this Accolade and passes it onto the successor ( if any )', supportedScopes: ['accolade'], syntax: "remove_acclaimed_knight = yes" },
];

/**
 * Effects for epidemic scope (4 effects)
 */
export const epidemicEffects: EffectDefinition[] = [
  { name: 'every_infected_province', description: 'Gets all provinces infected by the scoped epidemic', supportedScopes: ['epidemic'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, syntax: "every_infected_province = { limit = { <triggers> } <effects> }" },
  { name: 'ordered_infected_province', description: 'Gets all provinces infected by the scoped epidemic', supportedScopes: ['epidemic'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, syntax: "ordered_infected_province = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'random_infected_province', description: 'Gets all provinces infected by the scoped epidemic', supportedScopes: ['epidemic'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, syntax: "random_infected_province = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'set_epidemic_outbreak_intensity', description: 'Sets the epidemic outbreak intensity to the new value.', supportedScopes: ['epidemic'], syntax: "set_epidemic_outbreak_intensity = major\nminor, major, apocalyptic" },
];

/**
 * Effects for task_contract scope (3 effects)
 */
export const taskcontractEffects: EffectDefinition[] = [
  { name: 'complete_task_contract', description: 'complete_task_contract = task_contract_reward', supportedScopes: ['task_contract'] },
  { name: 'invalidate_contract', description: 'Invalidate contract', supportedScopes: ['task_contract'], syntax: "invalidate_contract = yes/no" },
  { name: 'set_task_contract_target', description: 'set_task_task_contract_target = CHARACTER_SCOPE', supportedScopes: ['task_contract'], supportedTargets: ['character'] },
];

/**
 * Effects for situation scope (20 effects)
 */
export const situationEffects: EffectDefinition[] = [
  { name: 'add_manual_participant', description: 'add_manual_participant = scope:character', supportedScopes: ['situation'], supportedTargets: ['character'], syntax: "Mark a character as a manual participant candidate for the Situation. They will be sorted into the first participant group that is valid for them. If no groups are valid, they will continue to be considered for participation in the future, but not be an actual participant until matched with a group.Use `remove_manual_participant` to remove them from consideration." },
  { name: 'change_top_phase', description: 'Change the phase of the top sub-region from the current one to a specific phase', supportedScopes: ['situation'], syntax: "change_top_phase = my_first_phase\nchange_top_phase = { phase = my_first_phase }" },
  { name: 'end_situation', description: 'End a situation, end_situation = yes', supportedScopes: ['situation'] },
  { name: 'every_participant_group', description: 'Iterate through all participant groups of the situation (in all sub-regions)', supportedScopes: ['situation'], supportedTargets: ['situation_participant_group'], outputScope: 'situation_participant_group', isIterator: true, syntax: "every_participant_group = { limit = { <triggers> } <effects> }" },
  { name: 'every_situation_county', description: 'Iterate through all counties that are involved in a situation', supportedScopes: ['situation'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_situation_county = { limit = { <triggers> } <effects> }" },
  { name: 'every_situation_participant', description: 'Iterate through all characters that are participating in a situation.', supportedScopes: ['situation'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_situation_participant = { limit = { <triggers> } <effects> }" },
  { name: 'every_situation_sub_region', description: 'Iterate through all sub-regions of a situation', supportedScopes: ['situation'], supportedTargets: ['situation_sub_region'], outputScope: 'situation_sub_region', isIterator: true, syntax: "every_situation_sub_region = { limit = { <triggers> } <effects> }" },
  { name: 'log_natural_disaster', description: 'Writes a log entry for the natural disaster situation in scope', supportedScopes: ['situation'], syntax: "Enabled with 'Logging.NaturalDisasters' in console first.\nShould be run after set_situation_capital_province and once severity has been set to capture accurate data.\nlog_natural_disaster = \"started\"\nlog_natural_disaster = \"ended\"" },
  { name: 'ordered_participant_group', description: 'Iterate through all participant groups of the situation (in all sub-regions)', supportedScopes: ['situation'], supportedTargets: ['situation_participant_group'], outputScope: 'situation_participant_group', isIterator: true, syntax: "ordered_participant_group = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_situation_county', description: 'Iterate through all counties that are involved in a situation', supportedScopes: ['situation'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_situation_county = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_situation_participant', description: 'Iterate through all characters that are participating in a situation.', supportedScopes: ['situation'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_situation_participant = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_situation_sub_region', description: 'Iterate through all sub-regions of a situation', supportedScopes: ['situation'], supportedTargets: ['situation_sub_region'], outputScope: 'situation_sub_region', isIterator: true, syntax: "ordered_situation_sub_region = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'random_participant_group', description: 'Iterate through all participant groups of the situation (in all sub-regions)', supportedScopes: ['situation'], supportedTargets: ['situation_participant_group'], outputScope: 'situation_participant_group', isIterator: true, syntax: "random_participant_group = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_situation_county', description: 'Iterate through all counties that are involved in a situation', supportedScopes: ['situation'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_situation_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_situation_participant', description: 'Iterate through all characters that are participating in a situation.', supportedScopes: ['situation'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_situation_participant = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_situation_sub_region', description: 'Iterate through all sub-regions of a situation', supportedScopes: ['situation'], supportedTargets: ['situation_sub_region'], outputScope: 'situation_sub_region', isIterator: true, syntax: "random_situation_sub_region = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'record_situation_special_event', description: 'Adds a special situation history entry. Only applies to situations that support full history (\'keep_full_history = yes\').', supportedScopes: ['situation'], syntax: "The entry date will be the date when the effect is executed.\nThe key field is mandatory and enables special entry localization. You will be able to access the character and the specified variables when localizing it.\nVariables only support objects, not values.\nscope:situation = {\nrecord_situation_special_event = {\nkey = special_event_key\nactor = scope:character (optional)\nphase = situation_phase_type_key (optional)\nvariables = {\nother_character = scope:other_character\ntitle = scope:title\n}\n}\n}", parameters: ['actor', 'phase', 'variables', 'other_character', 'title'] },
  { name: 'remove_manual_participant', description: 'remove_manual_participant = scope:character', supportedScopes: ['situation'], supportedTargets: ['character'], syntax: "Remove a manual participant from a situation. They were added before with `add_manual_participant`." },
  { name: 'set_situation_center_province', description: 'Sets a center province for the situation, useful for displaying pins in a specific place.', supportedScopes: ['situation'], supportedTargets: ['province'], syntax: "Can be retrieved with situation_center_province link.\nscope:situation = {\nset_situation_center_province = province\n}" },
  { name: 'trigger_situation_catalyst', description: 'Trigger a Situation catalyst on all subregions of a situation.', supportedScopes: ['situation'], syntax: "If a target province is specified, the catalyst will only trigger in that subregion.\nscope:situation = {\ntrigger_situation_catalyst = {\ncatalyst = catalyst_type\ncharacter = scope:character (optional, the actor who will trigger the catalyst)\ncounty = scope:province (optional, identifies the subregion where the catalyst will trigger)\n}\n}\nsimplified: activate_situation_catalyst = <catalyst_type>\nexample: activate_situation_catalyst = situation_catalyst_type:war_started", parameters: ['catalyst', 'character', 'county'] },
];

/**
 * Effects for situation_sub_region scope (23 effects)
 */
export const situationsubregionEffects: EffectDefinition[] = [
  { name: 'add_character_realm_to_sub_region', description: 'Adds all defacto counties of a character\'s realm to the situation sub-region.', supportedScopes: ['situation_sub_region'], supportedTargets: ['character'], syntax: "usage:\nadd_character_realm_to_sub_region = <character>" },
  { name: 'add_dejure_title_to_sub_region', description: 'Adds all dejure counties of a landed title to the situation sub-region.', supportedScopes: ['situation_sub_region'], supportedTargets: ['landed_title'], syntax: "usage:\nadd_dejure_title_to_sub_region = <title>" },
  { name: 'add_geographical_region', description: 'Adds a geographical region to the situation sub-region.', supportedScopes: ['situation_sub_region'], supportedTargets: ['geographical_region'], syntax: "usage:\nadd_geographical_region = db_type:geographical_region" },
  { name: 'add_phase_max_duration', description: 'Add (or subtract if negative) duration from the sub-region current phase\' max duration.', supportedScopes: ['situation_sub_region'], syntax: "add_phase_max_duration = {\ndays = 123\nmonths = 123\n}", parameters: ['days', 'months'] },
  { name: 'add_takeover_phase_duration', description: 'Add (or subtract if negative) duration towards a future takeover phase of this situation sub-region.', supportedScopes: ['situation_sub_region'], syntax: "add_takeover_phase_duration = {\nphase = situation_phase_key\ndays = 123\nmonths = 123\n}", parameters: ['phase', 'days', 'months'] },
  { name: 'add_takeover_phase_points', description: 'Add (or subtract if negative) points towards a future takeover phase of this situation sub-region. (rounded down)', supportedScopes: ['situation_sub_region'], syntax: "add_takeover_phase_points = {\nphase = situation_phase_key\npoints = scripted_value\n}", parameters: ['phase', 'points'] },
  { name: 'change_phase', description: 'Change the phase of a sub-region from the current one to a specific phase', supportedScopes: ['situation_sub_region'], syntax: "change_phase = my_first_phase\nchange_phase = { phase = my_first_phase }" },
  { name: 'every_situation_sub_region_county', description: 'Iterate through all counties of a situation sub-region (warning: not fast)', supportedScopes: ['situation_sub_region'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_situation_sub_region_county = { limit = { <triggers> } <effects> }" },
  { name: 'every_situation_sub_region_geographical_region', description: 'Iterate through all geographical regions of a situation sub-region', supportedScopes: ['situation_sub_region'], supportedTargets: ['geographical_region'], outputScope: 'geographical_region', isIterator: true, syntax: "every_situation_sub_region_geographical_region = { limit = { <triggers> } <effects> }" },
  { name: 'every_situation_sub_region_participant', description: 'Iterate through all characters that are participating in a situation, in a specific subregion', supportedScopes: ['situation_sub_region'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_situation_sub_region_participant = { limit = { <triggers> } <effects> }" },
  { name: 'every_situation_sub_region_participant_group', description: 'Iterate through all participant groups of the situation sub-region', supportedScopes: ['situation_sub_region'], supportedTargets: ['situation_participant_group'], outputScope: 'situation_participant_group', isIterator: true, syntax: "every_situation_sub_region_participant_group = { limit = { <triggers> } <effects> }" },
  { name: 'ordered_situation_sub_region_county', description: 'Iterate through all counties of a situation sub-region (warning: not fast)', supportedScopes: ['situation_sub_region'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_situation_sub_region_county = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_situation_sub_region_geographical_region', description: 'Iterate through all geographical regions of a situation sub-region', supportedScopes: ['situation_sub_region'], supportedTargets: ['geographical_region'], outputScope: 'geographical_region', isIterator: true, syntax: "ordered_situation_sub_region_geographical_region = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_situation_sub_region_participant', description: 'Iterate through all characters that are participating in a situation, in a specific subregion', supportedScopes: ['situation_sub_region'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_situation_sub_region_participant = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_situation_sub_region_participant_group', description: 'Iterate through all participant groups of the situation sub-region', supportedScopes: ['situation_sub_region'], supportedTargets: ['situation_participant_group'], outputScope: 'situation_participant_group', isIterator: true, syntax: "ordered_situation_sub_region_participant_group = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'random_situation_sub_region_county', description: 'Iterate through all counties of a situation sub-region (warning: not fast)', supportedScopes: ['situation_sub_region'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_situation_sub_region_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_situation_sub_region_geographical_region', description: 'Iterate through all geographical regions of a situation sub-region', supportedScopes: ['situation_sub_region'], supportedTargets: ['geographical_region'], outputScope: 'geographical_region', isIterator: true, syntax: "random_situation_sub_region_geographical_region = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_situation_sub_region_participant', description: 'Iterate through all characters that are participating in a situation, in a specific subregion', supportedScopes: ['situation_sub_region'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_situation_sub_region_participant = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_situation_sub_region_participant_group', description: 'Iterate through all participant groups of the situation sub-region', supportedScopes: ['situation_sub_region'], supportedTargets: ['situation_participant_group'], outputScope: 'situation_participant_group', isIterator: true, syntax: "random_situation_sub_region_participant_group = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'remove_character_realm_from_sub_region', description: 'Removes all defacto counties of a character\'s realm from the situation sub-region.', supportedScopes: ['situation_sub_region'], supportedTargets: ['character'], syntax: "usage:\nremove_character_realm_from_sub_region = <character>" },
  { name: 'remove_dejure_title_from_sub_region', description: 'Removes all dejure counties of the target title from the situation sub-region.', supportedScopes: ['situation_sub_region'], supportedTargets: ['landed_title'], syntax: "usage:\nremove_dejure_title_from_sub_region = <title>" },
  { name: 'remove_geographical_region', description: 'Removes a geographical region from the situation sub-region.', supportedScopes: ['situation_sub_region'], supportedTargets: ['geographical_region'], syntax: "usage:\nremove_geographical_region = db_type:geographical_region" },
  { name: 'trigger_sub_region_catalyst', description: 'Triggers a catalyst in a specific subregion only. Works in short version without specifying an actor:', supportedScopes: ['situation_sub_region'], syntax: "scope:situation_sub_region = {\ntrigger_sub_region_catalyst = catalyst_type\n}\ncan specify an actor that triggers the catalyst:\nscope:situation_sub_region = {\ntrigger_sub_region_catalyst = {\ncatalyst = catalyst_type\ncharacter = scope:character\n}\n}", parameters: ['catalyst', 'character'] },
];

/**
 * Effects for tax_slot scope (3 effects)
 */
export const taxslotEffects: EffectDefinition[] = [
  { name: 'every_tax_slot_vassal', description: 'Iterates through all Vassals assigned to the scoped Tax Slot', supportedScopes: ['tax_slot'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_tax_slot_vassal = { limit = { <triggers> } <effects> }" },
  { name: 'ordered_tax_slot_vassal', description: 'Iterates through all Vassals assigned to the scoped Tax Slot', supportedScopes: ['tax_slot'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_tax_slot_vassal = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'random_tax_slot_vassal', description: 'Iterates through all Vassals assigned to the scoped Tax Slot', supportedScopes: ['tax_slot'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_tax_slot_vassal = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
];

/**
 * Effects for domicile scope (12 effects)
 */
export const domicileEffects: EffectDefinition[] = [
  { name: 'add_animate_domicile_building', description: 'Add building to scoped domicile, ignores cost and construction time', supportedScopes: ['domicile'], syntax: "domicile = { add_animate_domicile_building = domicile building key }", parameters: ['domicile'] },
  { name: 'add_domicile_building', description: 'Add building to scoped domicile, ignores cost and construction time, no building animation', supportedScopes: ['domicile'], syntax: "domicile = { add_domicile_building = domicile building key }", parameters: ['domicile'] },
  { name: 'change_herd', description: 'Adds/removes herd to/from a scoped domicile', supportedScopes: ['domicile'] },
  { name: 'change_provisions', description: 'Adds (or removes) provisions to a scoped domicile', supportedScopes: ['domicile'] },
  { name: 'construct_domicile_building', description: 'Construct building to scoped domicile, ignores cost but uses construction time', supportedScopes: ['domicile'], syntax: "domicile = { construct_domicile_building = domicile building key }", parameters: ['domicile'] },
  { name: 'lower_domicile_building', description: 'Downgrade building to previous from scoped domicile or destroy it if at lowest', supportedScopes: ['domicile'], syntax: "domicile = { lower_domicile_building = domicile building key }", parameters: ['domicile'] },
  { name: 'lower_domicile_building_no_refund', description: 'Downgrade building to previous from scoped domicile or destroy it if at lowest, without refunding', supportedScopes: ['domicile'], syntax: "domicile = { lower_domicile_building = domicile building key }", parameters: ['domicile'] },
  { name: 'move_domicile', description: 'Moves domicile to target location', supportedScopes: ['domicile'], supportedTargets: ['province'], syntax: "domicile = { move_domicile = location }", parameters: ['domicile'] },
  { name: 'remove_domicile_building', description: 'Remove building from scoped domicile', supportedScopes: ['domicile'], syntax: "domicile = { remove_domicile_building = domicile building key }", parameters: ['domicile'] },
  { name: 'remove_domicile_building_no_refund', description: 'Remove building from scoped domicile without refunding it', supportedScopes: ['domicile'], syntax: "domicile = { remove_domicile_building = domicile building key }", parameters: ['domicile'] },
  { name: 'set_domicile_culture', description: 'Sets the domicile\'s culture, if it supports it', supportedScopes: ['domicile'], supportedTargets: ['culture'] },
  { name: 'set_domicile_faith', description: 'Sets the domicile\'s faith, if it supports it', supportedScopes: ['domicile'], supportedTargets: ['faith'] },
];

/**
 * Effects for great_project scope (3 effects)
 */
export const greatprojectEffects: EffectDefinition[] = [
  { name: 'every_contribution', description: 'Iterate through all Contributions of a given Great Project, regardless of whether they were funded or not.', supportedScopes: ['great_project'], supportedTargets: ['project_contribution'], outputScope: 'project_contribution', isIterator: true, syntax: "every_contribution = { limit = { <triggers> } <effects> }" },
  { name: 'ordered_contribution', description: 'Iterate through all Contributions of a given Great Project, regardless of whether they were funded or not.', supportedScopes: ['great_project'], supportedTargets: ['project_contribution'], outputScope: 'project_contribution', isIterator: true, syntax: "ordered_contribution = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'random_contribution', description: 'Iterate through all Contributions of a given Great Project, regardless of whether they were funded or not.', supportedScopes: ['great_project'], supportedTargets: ['project_contribution'], outputScope: 'project_contribution', isIterator: true, syntax: "random_contribution = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
];

/**
 * Effects for confederation scope (17 effects)
 */
export const confederationEffects: EffectDefinition[] = [
  { name: 'add_confederation_member', description: 'Adds a character to the scoped confederation, unless they\'re already part of one.', supportedScopes: ['confederation'], supportedTargets: ['character'], syntax: "The target character must have their primary title tier lower than the confederation title's tier.\nThis will also make the character a vassal of the confederation leader.\nusage:\n<confederation> = {\nadd_member = <character>\n}", parameters: ['add_member'] },
  { name: 'add_confederation_member_house', description: 'Adds a house to the scoped confederation, unless they\'re already part of it.', supportedScopes: ['confederation'], supportedTargets: ['dynasty_house'], syntax: "usage:\n<confederation> = {\nadd_confederation_member_house = <house>\n}" },
  { name: 'change_cohesion', description: 'Change confederation cohesion by the provided amount.', supportedScopes: ['confederation'] },
  { name: 'clear_leading_house', description: 'Clear this confederation\'s leading house.', supportedScopes: ['confederation'], syntax: "usage:\n<confederation> = {\nclear_leading_house = <yes/no> # where a 'no' means the leading house is kept.\n}" },
  { name: 'disband_confederation', description: 'Disbands the scoped confederation, destroying the confederation title.disband_confederation = yes', supportedScopes: ['confederation'] },
  { name: 'every_confederation_member', description: 'Iterates through all member characters of the scoped confederation', supportedScopes: ['confederation'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_confederation_member = { limit = { <triggers> } <effects> }" },
  { name: 'every_confederation_member_house', description: 'Iterates through all member houses of the scoped confederation', supportedScopes: ['confederation'], supportedTargets: ['dynasty_house'], outputScope: 'dynasty_house', isIterator: true, syntax: "every_confederation_member_house = { limit = { <triggers> } <effects> }" },
  { name: 'ordered_confederation_member', description: 'Iterates through all member characters of the scoped confederation', supportedScopes: ['confederation'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_confederation_member = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_confederation_member_house', description: 'Iterates through all member houses of the scoped confederation', supportedScopes: ['confederation'], supportedTargets: ['dynasty_house'], outputScope: 'dynasty_house', isIterator: true, syntax: "ordered_confederation_member_house = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'random_confederation_member', description: 'Iterates through all member characters of the scoped confederation', supportedScopes: ['confederation'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_confederation_member = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_confederation_member_house', description: 'Iterates through all member houses of the scoped confederation', supportedScopes: ['confederation'], supportedTargets: ['dynasty_house'], outputScope: 'dynasty_house', isIterator: true, syntax: "random_confederation_member_house = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'remove_confederation_member', description: 'Removes the target character from the scoped confederation.', supportedScopes: ['confederation'], supportedTargets: ['character'], syntax: "The holder of the confederation title cannot be removed.\nusage:\n<confederation> =\nremove_member = <character>\n}", parameters: ['remove_member'] },
  { name: 'remove_confederation_member_house', description: 'Removes the target house from the scoped confederation.', supportedScopes: ['confederation'], supportedTargets: ['dynasty_house'], syntax: "usage:\n<confederation> =\nremove_member_house = <house>\n}", parameters: ['remove_member_house'] },
  { name: 'set_cohesion', description: 'Set confederation cohesion to the provided amount.', supportedScopes: ['confederation'] },
  { name: 'set_confederation_color', description: 'Changes the map color of the confederation/bloc to the specified value. Both named and RGB values are supported.', supportedScopes: ['confederation'], syntax: "usage:\nscope:the_bloc = {\nset_confederation_color = { 255 128 64 }\n}" },
  { name: 'set_confederation_name', description: 'Sets confederation name.set_confederation_name=<dynamic_description>', supportedScopes: ['confederation'] },
  { name: 'set_leading_house', description: 'Sets the leading house of the confederation.', supportedScopes: ['confederation'], supportedTargets: ['dynasty_house'], syntax: "usage:\n<confederation> = {\nset_leading_house = <house>\n}" },
];

/**
 * Effects for house_relation scope (5 effects)
 */
export const houserelationEffects: EffectDefinition[] = [
  { name: 'change_house_relation_level', description: 'Shifts the house relation between levels.', supportedScopes: ['house_relation'], syntax: "usage:\nsome_house_relation = {\nchange_house_relation_level = {\nsteps = 2.0 # Can be either full steps, or fractional ones\ndescription = <dynamic description> # Why the latest change happened\nnotification = <yes/no> # Optional (default: yes). Should we show a message if a players house is involved?\n}\n}", parameters: ['some_house_relation', 'steps', 'description', 'notification'] },
  { name: 'clear_house_relation', description: 'Clear the relation between two houses.', supportedScopes: ['house_relation'], syntax: "usage:\nsome_relation = {\nclear_house_relation = yes\n}", parameters: ['some_relation'] },
  { name: 'every_relation_house', description: 'Iterate over both houses in the given relation', supportedScopes: ['house_relation'], supportedTargets: ['dynasty_house'], outputScope: 'dynasty_house', isIterator: true, syntax: "every_relation_house = { limit = { <triggers> } <effects> }" },
  { name: 'ordered_relation_house', description: 'Iterate over both houses in the given relation', supportedScopes: ['house_relation'], supportedTargets: ['dynasty_house'], outputScope: 'dynasty_house', isIterator: true, syntax: "ordered_relation_house = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'random_relation_house', description: 'Iterate over both houses in the given relation', supportedScopes: ['house_relation'], supportedTargets: ['dynasty_house'], outputScope: 'dynasty_house', isIterator: true, syntax: "random_relation_house = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
];

/**
 * Effects for none scope (317 effects)
 */
export const generalEffects: EffectDefinition[] = [
  { name: 'add_diplomacy_skill', description: 'Adds diplomacy skill', supportedScopes: ['none'] },
  { name: 'add_focus_progress', description: 'Adds focus progress', supportedScopes: ['none'] },
  { name: 'add_internal_flag', description: 'adds effect to be read internally (no effect in the gamestate)', supportedScopes: ['none'] },
  { name: 'add_intrigue_skill', description: 'Adds intrigue skill', supportedScopes: ['none'] },
  { name: 'add_learning_skill', description: 'Adds learning skill', supportedScopes: ['none'] },
  { name: 'add_martial_skill', description: 'Adds martial skill', supportedScopes: ['none'] },
  { name: 'add_prowess_skill', description: 'Adds prowess skill', supportedScopes: ['none'] },
  { name: 'add_stewardship_skill', description: 'Adds stewardship skill', supportedScopes: ['none'] },
  { name: 'add_title_law', description: 'add law to scoped title, overriding any current law from the same group. DOES NOT apply law change costs and effects.', supportedScopes: ['none'], syntax: "add_title_law = princely_elective_succession_law" },
  { name: 'add_title_law_effects', description: 'add law to scoped title, overriding any current law from the same group. DOES apply law change costs and effects.', supportedScopes: ['none'], syntax: "add_title_law = princely_elective_succession_law", parameters: ['add_title_law'] },
  { name: 'add_to_global_variable_list', description: 'Adds the event target to a variable list for the given duration', supportedScopes: ['none'], syntax: "add_to_variable_list = { name = X target = Y days/weeks/months/years = Z }\nWhere X is the name of the variable\nWhere Y is an event target\nAn optional days where Z is the number of days or script value", parameters: ['add_to_variable_list'] },
  { name: 'add_to_list', description: 'Adds the current scope to an arbitrarily-named list (or creates the list if not already present) to be referenced later in the (unbroken) event chain', supportedScopes: ['none'], syntax: "add_to_list = <name_of_list>\nadd_to_list = { name = <name_of_list> value = <script_value> }\nNOTE, if adding a permanent target to a temporary list, the whole list becomes permanent" },
  { name: 'add_to_local_variable_list', description: 'Adds the event target to a variable list for the given duration', supportedScopes: ['none'], syntax: "add_to_variable_list = { name = X target = Y days/weeks/months/years = Z }\nWhere X is the name of the variable\nWhere Y is an event target\nAn optional days where Z is the number of days or script value", parameters: ['add_to_variable_list'] },
  { name: 'add_to_temporary_list', description: 'Adds the current scope to an arbitrarily-named list (or creates the list if not already present) to be referenced later in the same effect', supportedScopes: ['none'], syntax: "add_to_temporary_list = <name_of_list>\nadd_to_temporary_list = { name = <name_of_list> value = <script_value> }\nNOTE, if adding a temporary target to a permanent list, the list will stay permanent" },
  { name: 'add_to_variable_list', description: 'Adds the event target to a variable list for the given duration', supportedScopes: ['none'], syntax: "add_to_variable_list = { name = X target = Y days/weeks/months/years = Z }\nWhere X is the name of the variable\nWhere Y is an event target\nAn optional days where Z is the number of days or script value" },
  { name: 'assert_if', description: 'Conditionally cause an assert during run time', supportedScopes: ['none'], syntax: "assert_if = { limit = { X } text = Y }, where X is a trigger and Y is an optional string" },
  { name: 'assert_read', description: 'Conditionally cause an assert during read time', supportedScopes: ['none'], syntax: "assert_read = X, where X is yes or the string to be printed in the assert" },
  { name: 'break_betrothal', description: 'Breaks the betrothal between the scope character to the target character, break_betrothal = target', supportedScopes: ['none'], supportedTargets: ['character'] },
  { name: 'cancel_great_project', description: 'Stops the planning or construction of a Great Project.', supportedScopes: ['none'], supportedTargets: ['great_project'], syntax: "Will trigger on_cancel effects for the Great Project. No refunds.\nusage:\n<scope:great_project> =\t{\ncancel_great_project = this\n}" },
  { name: 'change_global_variable', description: 'Changes the value or a numeric variable', supportedScopes: ['none'], syntax: "change_variable = { name = X operation = Y }\nWhere X is the name of the numeric variable to modify\nWhere the valid operations are add, subtract, multiply, divide, modulo, min and max\nWhere Y is a fixed point value, script value or event target of a value type", parameters: ['change_variable'] },
  { name: 'change_local_variable', description: 'Changes the value or a numeric variable', supportedScopes: ['none'], syntax: "change_variable = { name = X operation = Y }\nWhere X is the name of the numeric variable to modify\nWhere the valid operations are add, subtract, multiply, divide, modulo, min and max\nWhere Y is a fixed point value, script value or event target of a value type", parameters: ['change_variable'] },
  { name: 'change_realm_law_level', description: 'Change the realm law level by X steps for law group. DOES apply law change costs and effects.', supportedScopes: ['none'], syntax: "When exceeding law list bounds, the edge law is used. Invalid laws are not skipped.\nchange_realm_law_level = { law_group = budget_allocation_salary_law change = -2 }" },
  { name: 'change_realm_law_level_skip_effects', description: 'Change the realm law level by X steps for law group. Skips the cost and the pass effect, and the revoke effects of the current law.', supportedScopes: ['none'], syntax: "When exceeding law list bounds, the edge law is used. Invalid laws are not skipped.\nchange_realm_law_level_skip_effects = { law_group = budget_allocation_salary_law change = -2 }" },
  { name: 'change_title_holder', description: '= {', supportedScopes: ['none'], syntax: "holder = Character that should get the title\nchange = 'previously created title_and_vassal_change', adds a title change, will not transfer vassals\ntake_baronies = yes # Optional; if set, will cause baronies to be taken (rather than vassalized) as well if this title is a county\ngovernment_base = character # Optional, if the character getting the title was unlanded, their new government\n# will be based on the government of government_base.\n# If no government_base is specified, the government will be based on holder's government.", parameters: ['holder', 'change', 'take_baronies', 'government_base'] },
  { name: 'change_title_holder_include_vassals', description: '= {\n"', supportedScopes: ['none'], syntax: "holder = 'Character that should get the title'\nchange = 'previously created title_and_vassal_change', adds a title change, will transfer vassals\ntake_baronies = yes # Optional; if set, will cause baronies to be taken (rather than vassalized) as well if this title is a county\ngovernment_base = character # Optional, if the character getting the title was unlanded, their new government\n# will be based on the government of government_base.\n# If no government_base is specified, the government will be based on holder's government.", parameters: ['holder', 'change', 'take_baronies', 'government_base'] },
  { name: 'change_title_law_level', description: 'Change the title law level by X steps for law group. DOES NOT apply law change costs and effects.', supportedScopes: ['none'], syntax: "When exceeding law list bounds, the edge law is used. Invalid laws are not skipped.\nchange_title_law_level = { law_group = budget_allocation_salary_law change = -2 }" },
  { name: 'change_title_law_level_effects', description: 'Change the title law level by X steps for law group. DOES apply law change costs and effects.', supportedScopes: ['none'], syntax: "When exceeding law list bounds, the edge law is used. Invalid laws are not skipped.\nchange_title_law_level = { law_group = budget_allocation_salary_law change = -2 }", parameters: ['change_title_law_level'] },
  { name: 'change_variable', description: 'Changes the value or a numeric variable', supportedScopes: ['none'], syntax: "change_variable = { name = X operation = Y }\nWhere X is the name of the numeric variable to modify\nWhere the valid operations are add, subtract, multiply, divide, modulo, min and max\nWhere Y is a fixed point value, script value or event target of a value type" },
  { name: 'clamp_global_variable', description: 'Clamps a variable the specified max and min', supportedScopes: ['none'], syntax: "clamp_variable = { name = X max = Y min = Z }\nWhere X is the name of the variable\nWhere Y and Z are script values", parameters: ['clamp_variable'] },
  { name: 'clamp_local_variable', description: 'Clamps a variable the specified max and min', supportedScopes: ['none'], syntax: "clamp_variable = { name = X max = Y min = Z }\nWhere X is the name of the variable\nWhere Y and Z are script values", parameters: ['clamp_variable'] },
  { name: 'clamp_variable', description: 'Clamps a variable the specified max and min', supportedScopes: ['none'], syntax: "clamp_variable = { name = X max = Y min = Z }\nWhere X is the name of the variable\nWhere Y and Z are script values" },
  { name: 'clear_global_variable_list', description: 'Empties the list', supportedScopes: ['none'], syntax: "clear_variable_list = variable_name", parameters: ['clear_variable_list'] },
  { name: 'clear_local_variable_list', description: 'Empties the list', supportedScopes: ['none'], syntax: "clear_variable_list = variable_name", parameters: ['clear_variable_list'] },
  { name: 'clear_saved_scope', description: 'Clears a saved scope from the top scope', supportedScopes: ['none'], syntax: "save_scope_as = cool_scope -> clear_saved_scope = cool_scope" },
  { name: 'clear_traits', description: 'Removes all traits for the character. clear_traits = yes', supportedScopes: ['none'] },
  { name: 'clear_variable_list', description: 'Empties the list', supportedScopes: ['none'], syntax: "clear_variable_list = variable_name" },
  { name: 'close_all_views', description: 'Closes all views. close_all_views = yes', supportedScopes: ['none'] },
  { name: 'close_view', description: 'Tries to close the defined view.', supportedScopes: ['none'], syntax: "Take care to set player if effect is executed not through UI but through synchronized code. Else all the window will open for all players.\nclose_view = {\nview = <view name>\nplayer = scope:character # optional, else closes for all players who execute the effect\n}simplified: close_view = <view name>", parameters: ['view', 'player'] },
  { name: 'complete_great_project', description: 'Completes the Great Project immediately as if it was fully constructed.', supportedScopes: ['none'], supportedTargets: ['great_project'], syntax: "Will trigger on_complete effects for the Great Project, but no animations. Does not care if you have met the requirements (e.g. contributions) or not.\nusage:\n<scope:great_project> =\t{\ncomplete_great_project = this\n}" },
  { name: 'complete_great_project_animated', description: 'Completes the Great Project immediately as if it was fully constructed.', supportedScopes: ['none'], supportedTargets: ['great_project'], syntax: "Will trigger on_complete and any animation effects for the Great Project. Does not care if you have met the requirements (e.g. contributions) or not.\nusage:\n<scope:great_project> =\t{\ncomplete_great_project_animated = this\n}" },
  { name: 'copy_traits', description: 'Adds all traits of the target to the character. Skips any traits that the character isn\'t allowed to have. Will not remove the character\'s existing traits. copy_traits = scope:character', supportedScopes: ['none'], supportedTargets: ['character'] },
  { name: 'create_accolade', description: 'Create an accolade for the scoped character with the given knight and types. The name is an optional loc key, a default name will be generated otherwise.', supportedScopes: ['none'], syntax: "create_accolade = { knight = scope:character primary = accolade_type secondary = accolade_type name = loc_key }" },
  { name: 'create_adventurer_title', description: 'Create a title for a landless adventurer.', supportedScopes: ['none'], syntax: "usage:\ncreate_adventurer_title = \\\"\nname = key/dynamic description\nholder = <character> (intended holder of the new title)\ngovernment = administrative_government # optional government, default is adventurer\nsave_scope_as = <name>\nprefix = key/dynamic description (optional; name used if not specified)\nadjective = key/dynamic description (optional; name used if not specified)\n}", parameters: ['name', 'holder', 'government', 'prefix', 'adjective'] },
  { name: 'create_betrothal', description: 'Betroth the scope character to the target character, create_betrothal = target (at least one of the characters need to not be adult)', supportedScopes: ['none'], supportedTargets: ['character'] },
  { name: 'create_betrothal_matrilineal', description: 'Betroth the scope character to the target character matrilineally, create_betrothal_matrilineal = target (at least one of the characters need to not be adult)', supportedScopes: ['none'], supportedTargets: ['character'] },
  { name: 'create_character', description: 'Creates a character', supportedScopes: ['none'], syntax: "save_event_target_as = flag - save the character as an event target\nsave_temporary_event_target_as = flag - save the character as a temporary event target\nname =\nage =\ngender = male/female/character scope\ngender_female_chance = script_value - Range (0..100)\nopposite_gender = character scope\ntrait = add this trait\nrandom_traits_list = { count = { 1 5 } traitID = { some triggers } traitID = { some triggers } } - A number of traits specified by count (1 if not specified) will be picked from the traits that have their triggers met. Scopes are the same as where create_character is used. More than one grouping like this can be defined\nrandom_traits = yes/no\nhealth =\nfertility =\nmother =\nfather =\nreal_father = (should only be set if the real father is not the same as father=)\nemployer = will end up in this court, will become a pool character unless specified or father/mother is landed\nlocation = pool province; mutually exclusive with employer\ntemplate_character =\nfaith, culture and dynasty are set from 1. template_character 2. father 3. mother 4. employer (not employer for dynasty) unless specified directly\nfaith = faith tag OR a faith scope\nrandom_faith = { catholic = { some triggers } cathar = { some triggers }. Random one where the triggers are met will be picked. Scopes are the same as where create_character is used\nrandom_faith_in_religion = religion tag OR a faith scope (there's no religion scope)\nculture = culture name OR a culture scope\nrandom_culture = { norse = { some triggers } norwegian = { some triggers }. Random one where the triggers are met will be picked. Scopes are the same as where create_character is used\nrandom_culture_in_group = culture group name OR a culture scope (there's no group scope)\ndynasty_house = dynasty house name OR a dynasty house scope\ndynasty = generate/inherit/none - What to do if dynasty_house is not specified. generate by default.\nethnicity = culture/mother/father/parents/<ethnicity> - How to select ethnicity, culture by default.\nethnicities = { <key> = { some_triggers } } - Pick randomly from these ethnicities instead.\nmartial/diplomacy/intrigue...  =  will get random unless specified\nafter_creation = { some effects } run after character is created. Scope starts off in the character, with the scope it was created in as PREV, and the same top scope and saved targets etc.", parameters: ['save_event_target_as', 'save_temporary_event_target_as', 'name', 'gender', 'gender_female_chance', 'opposite_gender', 'trait', 'random_traits_list', 'random_traits', 'health', 'fertility', 'mother', 'father', 'real_father', 'employer', 'location', 'template_character', 'faith', 'random_faith', 'random_faith_in_religion', 'culture', 'random_culture', 'random_culture_in_group', 'dynasty_house', 'dynasty', 'ethnicity', 'ethnicities', 'after_creation'] },
  { name: 'create_dynamic_title', description: 'Creates a dynamic title', supportedScopes: ['none'], syntax: "The title will be saved to scope:new_titleusage:\ncreate_dynamic_title = {\ntier = <tier>\nname = key/dynamic description\nadj = key/dynamic description (optional; name used if not specified)\npre = key/dynamic description (optional)\narticle = key/dynamic description (optional)\n}", parameters: ['tier', 'name', 'adj', 'pre', 'article'] },
  { name: 'create_holy_order', description: 'Create a new holy order', supportedScopes: ['none'], syntax: "create_holy_order = {\nleader = scope:a_character\ncapital = scope:a_barony_title\nname = <name> #Optional\ncoat_of_arms = <coa_name> #Optional\nsave_scope_as/save_temporary_scope_as = new_holy_order # optional way to get a reference to the new holy order\n}", parameters: ['leader', 'capital', 'name', 'coat_of_arms'] },
  { name: 'create_nomad_title', description: 'Create a title for a nomad.', supportedScopes: ['none'], syntax: "usage:\ncreate_nomad_title = \\\"\nname = key/dynamic description\nholder = <character> (intended holder of the new title)\ngovernment = administrative_government # optional government, default is herder_government\nsave_scope_as = <name>\nprefix = key/dynamic description (optional; name used if not specified)\nadjective = key/dynamic description (optional; name used if not specified)\n}", parameters: ['name', 'holder', 'government', 'prefix', 'adjective'] },
  { name: 'create_title_and_vassal_change', description: 'starts a title and vassal change and saves it as a temporary event target', supportedScopes: ['none'], syntax: "create_title_and_vassal_change = {\ntype = conquest (or other type)\nsave_scope_as = change (name of resulting saved scope)\nadd_claim_on_loss = yes (optional)\n}", parameters: ['type', 'add_claim_on_loss'] },
  { name: 'custom_description', description: 'Wraps effects that get a custom description instead of the auto-generated one', supportedScopes: ['none'], syntax: "custom_description = {\ntext = <effect_localization_key>\nsubject = <optional subject scope> #defaults to current scope\nobject = <optional object scope>\nvalue = <optional script value>\n... effects ...\n}", parameters: ['text', 'subject', 'object'] },
  { name: 'custom_description_no_bullet', description: 'Wraps effects that get a custom description instead of the auto-generated one. Also ensures no bullet point appears', supportedScopes: ['none'], syntax: "custom_description_no_bullet = {\ntext = <effect_localization_key>\nsubject = <optional subject scope> #defaults to current scope\nobject = <optional object scope>\nvalue = <optional script value>\n... effects ...\n}", parameters: ['text', 'subject', 'object'] },
  { name: 'custom_label', description: 'just a tooltip, the scope as object (for grouping, localization). Can also be written as custom_label = { text = key subject = scope (optional) <hidden effects> }', supportedScopes: ['none'] },
  { name: 'custom_tooltip', description: 'just a tooltip, the scope as subject (for grouping, localization). Can also be written as custom_tooltip = { text = key subject = scope (optional) <hidden effects> }', supportedScopes: ['none'] },
  { name: 'debug_log', description: 'Log a string to the debug log when this effect executes, debug_log = message, the message can be a localization string with ROOT, SCOPE and PREV available', supportedScopes: ['none'] },
  { name: 'debug_log_date', description: 'Logs the current date to the debug.log', supportedScopes: ['none'] },
  { name: 'debug_log_scopes', description: 'Log the current scope to the debug log when this effect executes; yes = full scope info, no=only current scope', supportedScopes: ['none'] },
  { name: 'debug_log_stack_trace', description: 'Log a string to the *debug* log followed by a stack trace.', supportedScopes: ['none'], syntax: "The message can be a localization string with ROOT, SCOPE and PREV available.\nUsage:\ndebug_log_stack_trace = \"This is a test message\"" },
  { name: 'debug_trigger_event', description: 'Like trigger_event, except it\'ll print the trigger fulfillment and immediate effects of the event too', supportedScopes: ['none'] },
  { name: 'destroy_artifact', description: 'Destroy given artifact, regardless of owner.', supportedScopes: ['none'], supportedTargets: ['artifact'], syntax: "destroy_artifact = artifact" },
  { name: 'destroy_character_memory', description: 'destroy_character_memory = character_memory', supportedScopes: ['none'], supportedTargets: ['character_memory'], syntax: "Destroys the targeted character memory, do not use the destroyed scope after calling this since it will have been removed" },
  { name: 'destroy_inspiration', description: 'destroy_inspiration = inspiration', supportedScopes: ['none'], supportedTargets: ['inspiration'], syntax: "Destroys the targeted inspiration, do not use the destroyed scope after calling this since it will have been removed" },
  { name: 'destroy_owned_artifact', description: 'Destroy artifact owned by character. Safer version of \'destroy_artifact\'.', supportedScopes: ['none'], supportedTargets: ['artifact'], syntax: "destroy_owned_artifact = artifact" },
  { name: 'divorce', description: 'Divorces the scope character from the target character. divorce = target', supportedScopes: ['none'], supportedTargets: ['character'] },
  { name: 'duel', description: 'duel effect that selects an effect based on comparing specified skill(s), and/or saved variable(s) on, of a character to a value or another character\'s skill(s). Alternatively, the compare value can be scripted completely', supportedScopes: ['none'], syntax: "duel = {\nskill = X\n(skills = { X1 X2 ... })\nchallenge_variable = saved_variable_name\n(challenge_variables = { saved_variable_name_1 saved_variable_name_2 ... })\ntarget = Y\nvalue = Z\nlocalization = W\n... random list body\n}\nWhere X is the skill to compare, or the list of skills listed; Y is the target character (requires skill(s) to be set) or integer value Z (works with or without the skill), the rest of the effect is the same as random_list.\nIf the skill(s) are unspecified, the effect needs a value Z (which can use scripted math) which it will then use as the duel value directly.\nIf localization = W is specified, the effect localization W will be used (entry in effect_localization database, not a localization key directly).\nWhen multiple skills are specified, they are added together and the average is taken.\nThe skill difference (or scripted duel value) is available as scope:duel_value inside the outcome entries, the duel target is accessible as scope:duel_target.\nThe three valid types of combinations are: skill(s) + target / skill(s) + value / only value\nSince there is now no automatic weighting, we should be using weight numbers in a comparable range to the scope:duel_value value. Since that will always be between -20 and 20 (unless you do something very unusual), and typically in a more narrow range than that, we should stick to those ranges.\nOnly use larger weights if you want the duel_value to have a smaller impact on the weighting, and only use smaller weights if you want the duel_value to have a huge impact on the weighting.\nIn addition, it is fully possible for the compare_modifier to reduce the weight to 0, which would mean that it will not be possible to happen at all. I've requested code support to make it so that we can define min and max values for weights, but until further notice we should use ranges that are guaranteed to not hit 0, or include min values in the compare_modifier itself.\nLastly, remember that if you want the outcome of a duel to scale linearly from (almost) 0% to (almost) 100%, the duel_value should be applied 50% to the good outcome, and -50% to the bad outcome. If you only apply it on one side, you will retain a (presumably significant) chunk of chance for the other outcome.\nIf 'challenge_variable' or 'challenge_variables' are used, the variables specified must be localized with <variable_key>_name. You can also do text icons with named <variable_key>_icon", parameters: ['skill', 'challenge_variable', 'target', 'localization'] },
  { name: 'else', description: 'Executes enclosed effects if limit criteria of preceding \'if\' or \'else_if\' is not met', supportedScopes: ['none'], syntax: "if = { limit = { <triggers> } <effects> }\nelse = { <effects> }" },
  { name: 'else_if', description: 'Executes enclosed effects if limit criteria of preceding \'if\' or \'else_if\' is not met, and its own limit is met', supportedScopes: ['none'], syntax: "if = { limit = { <triggers> } <effects> }\nelse_if = { limit = { <triggers> } <effects> }" },
  { name: 'end_inspiration_sponsorship', description: 'end_inspiration_sponsorship = inspiration', supportedScopes: ['none'], supportedTargets: ['inspiration'], syntax: "Stops the sponsorship of the targeted inspiration" },
  { name: 'error_log', description: 'Log a string to the error log when this effect executes, error_log = message, the message can be a localization string with ROOT, SCOPE and PREV available', supportedScopes: ['none'] },
  { name: 'error_log_scopes', description: 'Log the current scope to the error log when this effect executes; yes = full scope info, no=only current scope', supportedScopes: ['none'] },
  { name: 'error_log_stack_trace', description: 'Log a string to the *error* log followed by a stack trace.', supportedScopes: ['none'], syntax: "The message can be a localization string with ROOT, SCOPE and PREV available.\nUsage:\nerror_log_stack_trace = \"This is a test message\"" },
  { name: 'every_accolade_type', description: 'Iterate through every accolade_type in the database', supportedScopes: ['none'], supportedTargets: ['accolade_type'], outputScope: 'accolade_type', isIterator: true, syntax: "every_accolade_type = { limit = { <triggers> } <effects> }" },
  { name: 'every_active_dynasty', description: 'Iterate through all dynasties with dynasty head', supportedScopes: ['none'], supportedTargets: ['dynasty'], outputScope: 'dynasty', isIterator: true, syntax: "every_active_dynasty = { limit = { <triggers> } <effects> }" },
  { name: 'every_activity', description: 'Iterate through all activities in the world', supportedScopes: ['none'], supportedTargets: ['activity'], outputScope: 'activity', isIterator: true, syntax: "every_activity = { limit = { <triggers> } <effects> }" },
  { name: 'every_activity_type', description: 'Iterate through every activity_type in the database', supportedScopes: ['none'], supportedTargets: ['activity_type'], outputScope: 'activity_type', isIterator: true, syntax: "every_activity_type = { limit = { <triggers> } <effects> }" },
  { name: 'every_artifact', description: 'Iterate through all existing artifacts', supportedScopes: ['none'], supportedTargets: ['artifact'], outputScope: 'artifact', isIterator: true, syntax: "every_artifact = { limit = { <triggers> } <effects> }" },
  { name: 'every_barony', description: 'Iterate through all baronies in the game', supportedScopes: ['none'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_barony = { limit = { <triggers> } <effects> }" },
  { name: 'every_casus_belli_type', description: 'Iterate through every casus_belli_type in the database', supportedScopes: ['none'], supportedTargets: ['casus_belli_type'], outputScope: 'casus_belli_type', isIterator: true, syntax: "every_casus_belli_type = { limit = { <triggers> } <effects> }" },
  { name: 'every_character_with_royal_court', description: 'Iterate through all characters with a royal court', supportedScopes: ['none'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_character_with_royal_court = { limit = { <triggers> } <effects> }" },
  { name: 'every_completed_legend', description: 'Gets all legends in the world that have been completed', supportedScopes: ['none'], supportedTargets: ['legend'], outputScope: 'legend', isIterator: true, syntax: "every_completed_legend = { limit = { <triggers> } <effects> }" },
  { name: 'every_confederation', description: 'List all confederations', supportedScopes: ['none'], supportedTargets: ['confederation'], outputScope: 'confederation', isIterator: true, syntax: "every_confederation = { limit = { <triggers> } <effects> }" },
  { name: 'every_confederation_type', description: 'Iterate through every confederation_type in the database', supportedScopes: ['none'], supportedTargets: ['confederation_type'], outputScope: 'confederation_type', isIterator: true, syntax: "every_confederation_type = { limit = { <triggers> } <effects> }" },
  { name: 'every_county', description: 'Iterate through all counties in the game', supportedScopes: ['none'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_county = { limit = { <triggers> } <effects> }" },
  { name: 'every_county_in_region', description: 'Iterate through all counties in the region. Put \'region = region_name\' inside it', supportedScopes: ['none'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_county_in_region = { limit = { <triggers> } <effects> }" },
  { name: 'every_court_position_type', description: 'Iterate through every court_position_type in the database', supportedScopes: ['none'], supportedTargets: ['court_position_type'], outputScope: 'court_position_type', isIterator: true, syntax: "every_court_position_type = { limit = { <triggers> } <effects> }" },
  { name: 'every_culture_global', description: 'Iterate through all cultures in the game', supportedScopes: ['none'], supportedTargets: ['culture'], outputScope: 'culture', isIterator: true, syntax: "every_culture_global = { limit = { <triggers> } <effects> }" },
  { name: 'every_culture_innovation', description: 'Iterate through every culture_innovation in the database', supportedScopes: ['none'], supportedTargets: ['culture_innovation'], outputScope: 'culture_innovation', isIterator: true, syntax: "every_culture_innovation = { limit = { <triggers> } <effects> }" },
  { name: 'every_culture_pillar', description: 'Iterate through every culture_pillar in the database', supportedScopes: ['none'], supportedTargets: ['culture_pillar'], outputScope: 'culture_pillar', isIterator: true, syntax: "every_culture_pillar = { limit = { <triggers> } <effects> }" },
  { name: 'every_culture_tradition', description: 'Iterate through every culture_tradition in the database', supportedScopes: ['none'], supportedTargets: ['culture_tradition'], outputScope: 'culture_tradition', isIterator: true, syntax: "every_culture_tradition = { limit = { <triggers> } <effects> }" },
  { name: 'every_decision', description: 'Iterate through every decision in the database', supportedScopes: ['none'], supportedTargets: ['decision'], outputScope: 'decision', isIterator: true, syntax: "every_decision = { limit = { <triggers> } <effects> }" },
  { name: 'every_doctrine', description: 'Iterate through every doctrine in the database', supportedScopes: ['none'], supportedTargets: ['doctrine'], outputScope: 'doctrine', isIterator: true, syntax: "every_doctrine = { limit = { <triggers> } <effects> }" },
  { name: 'every_domicile', description: 'Iterate through all domiciles', supportedScopes: ['none'], supportedTargets: ['domicile'], outputScope: 'domicile', isIterator: true, syntax: "every_domicile = { limit = { <triggers> } <effects> }" },
  { name: 'every_duchy', description: 'Iterate through all duchies in the game', supportedScopes: ['none'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_duchy = { limit = { <triggers> } <effects> }" },
  { name: 'every_dynasty', description: 'Iterate through all dynasties (even those without head)', supportedScopes: ['none'], supportedTargets: ['dynasty'], outputScope: 'dynasty', isIterator: true, syntax: "every_dynasty = { limit = { <triggers> } <effects> }" },
  { name: 'every_empire', description: 'Iterate through all empires in the game', supportedScopes: ['none'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_empire = { limit = { <triggers> } <effects> }" },
  { name: 'every_epidemic', description: 'Gets all epidemics in the world', supportedScopes: ['none'], supportedTargets: ['epidemic'], outputScope: 'epidemic', isIterator: true, syntax: "every_epidemic = { limit = { <triggers> } <effects> }" },
  { name: 'every_epidemic_type', description: 'Iterate through every epidemic_type in the database', supportedScopes: ['none'], supportedTargets: ['epidemic_type'], outputScope: 'epidemic_type', isIterator: true, syntax: "every_epidemic_type = { limit = { <triggers> } <effects> }" },
  { name: 'every_geographical_region', description: 'Iterate through every geographical_region in the database', supportedScopes: ['none'], supportedTargets: ['geographical_region'], outputScope: 'geographical_region', isIterator: true, syntax: "every_geographical_region = { limit = { <triggers> } <effects> }" },
  { name: 'every_government_type', description: 'Iterate through every government_type in the database', supportedScopes: ['none'], supportedTargets: ['government_type'], outputScope: 'government_type', isIterator: true, syntax: "every_government_type = { limit = { <triggers> } <effects> }" },
  { name: 'every_great_project', description: 'Iterate through all active Great Projects.', supportedScopes: ['none'], supportedTargets: ['great_project'], outputScope: 'great_project', isIterator: true, syntax: "every_great_project = { limit = { <triggers> } <effects> }" },
  { name: 'every_great_project_type', description: 'Iterate through every great_project_type in the database', supportedScopes: ['none'], supportedTargets: ['great_project_type'], outputScope: 'great_project_type', isIterator: true, syntax: "every_great_project_type = { limit = { <triggers> } <effects> }" },
  { name: 'every_hegemony', description: 'Iterate through all hegemonies in the game', supportedScopes: ['none'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_hegemony = { limit = { <triggers> } <effects> }" },
  { name: 'every_holding_type', description: 'Iterate through every holding_type in the database', supportedScopes: ['none'], supportedTargets: ['holding_type'], outputScope: 'holding_type', isIterator: true, syntax: "every_holding_type = { limit = { <triggers> } <effects> }" },
  { name: 'every_house_aspiration', description: 'Iterate through every house_aspiration in the database', supportedScopes: ['none'], supportedTargets: ['house_aspiration'], outputScope: 'house_aspiration', isIterator: true, syntax: "every_house_aspiration = { limit = { <triggers> } <effects> }" },
  { name: 'every_house_relation_level', description: 'Iterate through every house_relation_level in the database', supportedScopes: ['none'], supportedTargets: ['house_relation_level'], outputScope: 'house_relation_level', isIterator: true, syntax: "every_house_relation_level = { limit = { <triggers> } <effects> }" },
  { name: 'every_house_relation_type', description: 'Iterate through every house_relation_type in the database', supportedScopes: ['none'], supportedTargets: ['house_relation_type'], outputScope: 'house_relation_type', isIterator: true, syntax: "every_house_relation_type = { limit = { <triggers> } <effects> }" },
  { name: 'every_important_location', description: 'Iterate through all counties that are important for at least some title', supportedScopes: ['none'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_important_location = { limit = { <triggers> } <effects> }" },
  { name: 'every_in_global_list', description: 'Iterate through all items in global list. list = name or variable = name', supportedScopes: ['none'], isIterator: true, syntax: "every_in_global_list = { limit = { <triggers> } <effects> }" },
  { name: 'every_in_list', description: 'Iterate through all items in list. list = name or variable = name', supportedScopes: ['none'], isIterator: true, syntax: "every_in_list = { limit = { <triggers> } <effects> }" },
  { name: 'every_in_local_list', description: 'Iterate through all items in local list. list = name or variable = name', supportedScopes: ['none'], isIterator: true, syntax: "every_in_local_list = { limit = { <triggers> } <effects> }" },
  { name: 'every_independent_ruler', description: 'Independent rulers list with a COUNT tier or above who hold land', supportedScopes: ['none'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_independent_ruler = { limit = { <triggers> } <effects> }" },
  { name: 'every_inspiration', description: 'Iterate through all inspirations in the world', supportedScopes: ['none'], supportedTargets: ['inspiration'], outputScope: 'inspiration', isIterator: true, syntax: "every_inspiration = { limit = { <triggers> } <effects> }" },
  { name: 'every_inspired_character', description: 'Iterate through all characters with an inspirations in the world', supportedScopes: ['none'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_inspired_character = { limit = { <triggers> } <effects> }" },
  { name: 'every_interested_title', description: 'Iterate through all titles that are interested in any county', supportedScopes: ['none'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_interested_title = { limit = { <triggers> } <effects> }" },
  { name: 'every_kingdom', description: 'Iterate through all kingdoms in the game', supportedScopes: ['none'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "every_kingdom = { limit = { <triggers> } <effects> }" },
  { name: 'every_legend', description: 'Gets all legends in the world that have not been completed', supportedScopes: ['none'], supportedTargets: ['legend'], outputScope: 'legend', isIterator: true, syntax: "every_legend = { limit = { <triggers> } <effects> }" },
  { name: 'every_legend_type', description: 'Iterate through every legend_type in the database', supportedScopes: ['none'], supportedTargets: ['legend_type'], outputScope: 'legend_type', isIterator: true, syntax: "every_legend_type = { limit = { <triggers> } <effects> }" },
  { name: 'every_living_character', description: 'Iterate through all living characters', supportedScopes: ['none'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_living_character = { limit = { <triggers> } <effects> }" },
  { name: 'every_mercenary_company', description: 'Iterate through all mercenary companies', supportedScopes: ['none'], supportedTargets: ['mercenary_company'], outputScope: 'mercenary_company', isIterator: true, syntax: "every_mercenary_company = { limit = { <triggers> } <effects> }" },
  { name: 'every_open_invite_activity', description: 'Iterate through all open invite activities in the world', supportedScopes: ['none'], supportedTargets: ['activity'], outputScope: 'activity', isIterator: true, syntax: "every_open_invite_activity = { limit = { <triggers> } <effects> }" },
  { name: 'every_player', description: 'Iterate through all player characters', supportedScopes: ['none'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_player = { limit = { <triggers> } <effects> }" },
  { name: 'every_pool_character', description: 'Iterate through all characters in the pool of the given province', supportedScopes: ['none'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_pool_character = { limit = { <triggers> } <effects> }" },
  { name: 'every_province', description: 'Iterate through all provinces (skips non-land and impassable provinces)', supportedScopes: ['none'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, syntax: "every_province = { limit = { <triggers> } <effects> }" },
  { name: 'every_religion_global', description: 'Iterate through all religions in the game', supportedScopes: ['none'], supportedTargets: ['religion'], outputScope: 'religion', isIterator: true, syntax: "every_religion_global = { limit = { <triggers> } <effects> }" },
  { name: 'every_ruler', description: 'Rulers list with a COUNT tier o above', supportedScopes: ['none'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "every_ruler = { limit = { <triggers> } <effects> }" },
  { name: 'every_special_building_province', description: 'Iterate through all provinces with a special building slot (built or un-built)', supportedScopes: ['none'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, syntax: "every_special_building_province = { limit = { <triggers> } <effects> }" },
  { name: 'every_task_contract', description: 'Gets all available and accepted task contracts.', supportedScopes: ['none'], supportedTargets: ['task_contract'], outputScope: 'task_contract', isIterator: true, syntax: "Optionally specify a contract type filter\nany_task_contract = { task_contract_type = laamp_raid_contract }\nevery_task_contract = { limit = { <triggers> } <effects> }", parameters: ['any_task_contract'] },
  { name: 'every_task_contract_type', description: 'Iterate through every task_contract_type in the database', supportedScopes: ['none'], supportedTargets: ['task_contract_type'], outputScope: 'task_contract_type', isIterator: true, syntax: "every_task_contract_type = { limit = { <triggers> } <effects> }" },
  { name: 'every_trait', description: 'Iterate through every trait in the database', supportedScopes: ['none'], supportedTargets: ['trait'], outputScope: 'trait', isIterator: true, syntax: "every_trait = { limit = { <triggers> } <effects> }" },
  { name: 'every_trait_in_category', description: 'Iterate through all traits in a given category', supportedScopes: ['none'], supportedTargets: ['trait'], outputScope: 'trait', isIterator: true, syntax: "any_trait_in_category = { category = fame/health/etc }\nevery_trait_in_category = { limit = { <triggers> } <effects> }", parameters: ['any_trait_in_category'] },
  { name: 'every_vassal_contract', description: 'Iterate through every vassal_contract in the database', supportedScopes: ['none'], supportedTargets: ['vassal_contract'], outputScope: 'vassal_contract', isIterator: true, syntax: "every_vassal_contract = { limit = { <triggers> } <effects> }" },
  { name: 'hidden_effect', description: 'Effect not shown in tooltips', supportedScopes: ['none'] },
  { name: 'hidden_effect_new_object', description: 'Suppress errors for effects using to-be created objects (like artifacts or characters) in tooltips. The effects inside are hidden from the tooltip, with no description generated whatsoever!', supportedScopes: ['none'] },
  { name: 'if', description: 'Executes enclosed effects if limit criteria are met', supportedScopes: ['none'], syntax: "if = { limit = { <triggers> } <effects> }" },
  { name: 'info_log', description: 'Log a string to the info log when this effect executes, info_log = message, the message can be a localization string with ROOT, SCOPE and PREV available', supportedScopes: ['none'] },
  { name: 'info_log_scopes', description: 'Log the current scope to the info log when this effect executes; yes = full scope info, no=only current scope', supportedScopes: ['none'] },
  { name: 'info_log_stack_trace', description: 'Log a string to the *info* log followed by a stack trace.', supportedScopes: ['none'], syntax: "The message can be a localization string with ROOT, SCOPE and PREV available.\nUsage:\ninfo_log_stack_trace = \"This is a test message\"" },
  { name: 'invalidate_activity', description: 'Invalidate and destroy the target activity, running its on_invalidate effect', supportedScopes: ['none'], supportedTargets: ['activity'], syntax: "invalidate_activity = scope:activity" },
  { name: 'multiply_focus_progress', description: 'Multiplies focus progress', supportedScopes: ['none'] },
  { name: 'open_interaction_window', description: 'Tries to open the defined view.', supportedScopes: ['none'], syntax: "interaction = interaction_key - the interaction object key to open\nredirect = [yes|no] - yes by default, redirect the actor and recipients ( only works if secondary_actor and secondary_recipient are not setup or are invalid)\nactor = character_actor - must be defined, must coincide with the current player\nrecipient = character_actor - must be defined\nsecondary_actor = character_secondary_actor - optional\nsecondary_recipient = character_secondary_recipient - optional\ntarget_title = title - optional", parameters: ['interaction', 'redirect', 'actor', 'recipient', 'secondary_actor', 'secondary_recipient', 'target_title'] },
  { name: 'open_view', description: 'Tries to open the defined view without scope data.', supportedScopes: ['none'], syntax: "Take care to set player if effect is executed not through UI but through synchronized code. Else all the window will open for all players.\nopen_view = {\nview = <view name>\nview_message = <view specific instruction> # optional\nplayer = scope:character # optional, else shows for all players who execute the effect\n}simplified: open_view = <view name>", parameters: ['view', 'view_message', 'player'] },
  { name: 'open_view_data', description: 'Tries to open the defined view with scope data.', supportedScopes: ['none'], syntax: "Take care to set player if effect is executed not through UI but through synchronized code. Else all the window will open for all players.\nopen_view_data = {\nview = <view name>\nview_message = <view specific instruction> # optional\nplayer = scope:character # optional, else shows for all players who execute the effect\n}\nsimplified: open_view_data = <view name>\nfor example: scope:faith = { open_view_data = faith_conversion }", parameters: ['view', 'view_message', 'player'] },
  { name: 'ordered_accolade_type', description: 'Iterate through every accolade_type in the database', supportedScopes: ['none'], supportedTargets: ['accolade_type'], outputScope: 'accolade_type', isIterator: true, syntax: "ordered_accolade_type = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_active_dynasty', description: 'Iterate through all dynasties with dynasty head', supportedScopes: ['none'], supportedTargets: ['dynasty'], outputScope: 'dynasty', isIterator: true, syntax: "ordered_active_dynasty = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_activity', description: 'Iterate through all activities in the world', supportedScopes: ['none'], supportedTargets: ['activity'], outputScope: 'activity', isIterator: true, syntax: "ordered_activity = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_activity_type', description: 'Iterate through every activity_type in the database', supportedScopes: ['none'], supportedTargets: ['activity_type'], outputScope: 'activity_type', isIterator: true, syntax: "ordered_activity_type = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_artifact', description: 'Iterate through all existing artifacts', supportedScopes: ['none'], supportedTargets: ['artifact'], outputScope: 'artifact', isIterator: true, syntax: "ordered_artifact = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_barony', description: 'Iterate through all baronies in the game', supportedScopes: ['none'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_barony = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_casus_belli_type', description: 'Iterate through every casus_belli_type in the database', supportedScopes: ['none'], supportedTargets: ['casus_belli_type'], outputScope: 'casus_belli_type', isIterator: true, syntax: "ordered_casus_belli_type = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_character_with_royal_court', description: 'Iterate through all characters with a royal court', supportedScopes: ['none'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_character_with_royal_court = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_completed_legend', description: 'Gets all legends in the world that have been completed', supportedScopes: ['none'], supportedTargets: ['legend'], outputScope: 'legend', isIterator: true, syntax: "ordered_completed_legend = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_confederation', description: 'List all confederations', supportedScopes: ['none'], supportedTargets: ['confederation'], outputScope: 'confederation', isIterator: true, syntax: "ordered_confederation = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_confederation_type', description: 'Iterate through every confederation_type in the database', supportedScopes: ['none'], supportedTargets: ['confederation_type'], outputScope: 'confederation_type', isIterator: true, syntax: "ordered_confederation_type = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_county', description: 'Iterate through all counties in the game', supportedScopes: ['none'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_county = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_county_in_region', description: 'Iterate through all counties in the region. Put \'region = region_name\' inside it', supportedScopes: ['none'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_county_in_region = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_court_position_type', description: 'Iterate through every court_position_type in the database', supportedScopes: ['none'], supportedTargets: ['court_position_type'], outputScope: 'court_position_type', isIterator: true, syntax: "ordered_court_position_type = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_culture_global', description: 'Iterate through all cultures in the game', supportedScopes: ['none'], supportedTargets: ['culture'], outputScope: 'culture', isIterator: true, syntax: "ordered_culture_global = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_culture_innovation', description: 'Iterate through every culture_innovation in the database', supportedScopes: ['none'], supportedTargets: ['culture_innovation'], outputScope: 'culture_innovation', isIterator: true, syntax: "ordered_culture_innovation = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_culture_pillar', description: 'Iterate through every culture_pillar in the database', supportedScopes: ['none'], supportedTargets: ['culture_pillar'], outputScope: 'culture_pillar', isIterator: true, syntax: "ordered_culture_pillar = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_culture_tradition', description: 'Iterate through every culture_tradition in the database', supportedScopes: ['none'], supportedTargets: ['culture_tradition'], outputScope: 'culture_tradition', isIterator: true, syntax: "ordered_culture_tradition = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_decision', description: 'Iterate through every decision in the database', supportedScopes: ['none'], supportedTargets: ['decision'], outputScope: 'decision', isIterator: true, syntax: "ordered_decision = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_doctrine', description: 'Iterate through every doctrine in the database', supportedScopes: ['none'], supportedTargets: ['doctrine'], outputScope: 'doctrine', isIterator: true, syntax: "ordered_doctrine = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_domicile', description: 'Iterate through all domiciles', supportedScopes: ['none'], supportedTargets: ['domicile'], outputScope: 'domicile', isIterator: true, syntax: "ordered_domicile = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_duchy', description: 'Iterate through all duchies in the game', supportedScopes: ['none'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_duchy = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_dynasty', description: 'Iterate through all dynasties (even those without head)', supportedScopes: ['none'], supportedTargets: ['dynasty'], outputScope: 'dynasty', isIterator: true, syntax: "ordered_dynasty = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_empire', description: 'Iterate through all empires in the game', supportedScopes: ['none'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_empire = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_epidemic', description: 'Gets all epidemics in the world', supportedScopes: ['none'], supportedTargets: ['epidemic'], outputScope: 'epidemic', isIterator: true, syntax: "ordered_epidemic = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_epidemic_type', description: 'Iterate through every epidemic_type in the database', supportedScopes: ['none'], supportedTargets: ['epidemic_type'], outputScope: 'epidemic_type', isIterator: true, syntax: "ordered_epidemic_type = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_geographical_region', description: 'Iterate through every geographical_region in the database', supportedScopes: ['none'], supportedTargets: ['geographical_region'], outputScope: 'geographical_region', isIterator: true, syntax: "ordered_geographical_region = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_government_type', description: 'Iterate through every government_type in the database', supportedScopes: ['none'], supportedTargets: ['government_type'], outputScope: 'government_type', isIterator: true, syntax: "ordered_government_type = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_great_project', description: 'Iterate through all active Great Projects.', supportedScopes: ['none'], supportedTargets: ['great_project'], outputScope: 'great_project', isIterator: true, syntax: "ordered_great_project = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_great_project_type', description: 'Iterate through every great_project_type in the database', supportedScopes: ['none'], supportedTargets: ['great_project_type'], outputScope: 'great_project_type', isIterator: true, syntax: "ordered_great_project_type = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_hegemony', description: 'Iterate through all hegemonies in the game', supportedScopes: ['none'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_hegemony = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_holding_type', description: 'Iterate through every holding_type in the database', supportedScopes: ['none'], supportedTargets: ['holding_type'], outputScope: 'holding_type', isIterator: true, syntax: "ordered_holding_type = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_house_aspiration', description: 'Iterate through every house_aspiration in the database', supportedScopes: ['none'], supportedTargets: ['house_aspiration'], outputScope: 'house_aspiration', isIterator: true, syntax: "ordered_house_aspiration = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_house_relation_level', description: 'Iterate through every house_relation_level in the database', supportedScopes: ['none'], supportedTargets: ['house_relation_level'], outputScope: 'house_relation_level', isIterator: true, syntax: "ordered_house_relation_level = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_house_relation_type', description: 'Iterate through every house_relation_type in the database', supportedScopes: ['none'], supportedTargets: ['house_relation_type'], outputScope: 'house_relation_type', isIterator: true, syntax: "ordered_house_relation_type = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_important_location', description: 'Iterate through all counties that are important for at least some title', supportedScopes: ['none'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_important_location = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_in_global_list', description: 'Iterate through all items in global list. list = name or variable = name', supportedScopes: ['none'], isIterator: true, syntax: "ordered_in_global_list = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_in_list', description: 'Iterate through all items in list. list = name or variable = name', supportedScopes: ['none'], isIterator: true, syntax: "ordered_in_list = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_in_local_list', description: 'Iterate through all items in local list. list = name or variable = name', supportedScopes: ['none'], isIterator: true, syntax: "ordered_in_local_list = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_independent_ruler', description: 'Independent rulers list with a COUNT tier or above who hold land', supportedScopes: ['none'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_independent_ruler = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_inspiration', description: 'Iterate through all inspirations in the world', supportedScopes: ['none'], supportedTargets: ['inspiration'], outputScope: 'inspiration', isIterator: true, syntax: "ordered_inspiration = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_inspired_character', description: 'Iterate through all characters with an inspirations in the world', supportedScopes: ['none'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_inspired_character = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_interested_title', description: 'Iterate through all titles that are interested in any county', supportedScopes: ['none'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_interested_title = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_kingdom', description: 'Iterate through all kingdoms in the game', supportedScopes: ['none'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "ordered_kingdom = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_legend', description: 'Gets all legends in the world that have not been completed', supportedScopes: ['none'], supportedTargets: ['legend'], outputScope: 'legend', isIterator: true, syntax: "ordered_legend = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_legend_type', description: 'Iterate through every legend_type in the database', supportedScopes: ['none'], supportedTargets: ['legend_type'], outputScope: 'legend_type', isIterator: true, syntax: "ordered_legend_type = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_living_character', description: 'Iterate through all living characters', supportedScopes: ['none'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_living_character = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_mercenary_company', description: 'Iterate through all mercenary companies', supportedScopes: ['none'], supportedTargets: ['mercenary_company'], outputScope: 'mercenary_company', isIterator: true, syntax: "ordered_mercenary_company = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_open_invite_activity', description: 'Iterate through all open invite activities in the world', supportedScopes: ['none'], supportedTargets: ['activity'], outputScope: 'activity', isIterator: true, syntax: "ordered_open_invite_activity = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_player', description: 'Iterate through all player characters', supportedScopes: ['none'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_player = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_pool_character', description: 'Iterate through all characters in the pool of the given province', supportedScopes: ['none'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_pool_character = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_province', description: 'Iterate through all provinces (skips non-land and impassable provinces)', supportedScopes: ['none'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, syntax: "ordered_province = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_religion_global', description: 'Iterate through all religions in the game', supportedScopes: ['none'], supportedTargets: ['religion'], outputScope: 'religion', isIterator: true, syntax: "ordered_religion_global = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_ruler', description: 'Rulers list with a COUNT tier o above', supportedScopes: ['none'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "ordered_ruler = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_special_building_province', description: 'Iterate through all provinces with a special building slot (built or un-built)', supportedScopes: ['none'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, syntax: "ordered_special_building_province = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_task_contract', description: 'Gets all available and accepted task contracts.', supportedScopes: ['none'], supportedTargets: ['task_contract'], outputScope: 'task_contract', isIterator: true, syntax: "Optionally specify a contract type filter\nany_task_contract = { task_contract_type = laamp_raid_contract }\nordered_task_contract = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['any_task_contract', 'order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_task_contract_type', description: 'Iterate through every task_contract_type in the database', supportedScopes: ['none'], supportedTargets: ['task_contract_type'], outputScope: 'task_contract_type', isIterator: true, syntax: "ordered_task_contract_type = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_trait', description: 'Iterate through every trait in the database', supportedScopes: ['none'], supportedTargets: ['trait'], outputScope: 'trait', isIterator: true, syntax: "ordered_trait = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_trait_in_category', description: 'Iterate through all traits in a given category', supportedScopes: ['none'], supportedTargets: ['trait'], outputScope: 'trait', isIterator: true, syntax: "any_trait_in_category = { category = fame/health/etc }\nordered_trait_in_category = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['any_trait_in_category', 'order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'ordered_vassal_contract', description: 'Iterate through every vassal_contract in the database', supportedScopes: ['none'], supportedTargets: ['vassal_contract'], outputScope: 'vassal_contract', isIterator: true, syntax: "ordered_vassal_contract = {\nlimit = { <triggers> }\norder_by = script_value\nposition = int\nmin = int\nmax = script_value\ncheck_range_bounds = no # If you don't want an error logged if the list is smaller than the min/max\n<effects> }", parameters: ['order_by', 'position', 'min', 'max', 'check_range_bounds'] },
  { name: 'pan_camera_to_province', description: 'Pans the camera to the specified province', supportedScopes: ['none'], supportedTargets: ['province'], syntax: "pan_camera_to_province = scope:army.location" },
  { name: 'pan_camera_to_title', description: 'Pans the camera to the specified title', supportedScopes: ['none'], supportedTargets: ['landed_title'], syntax: "pan_camera_to_title = capital_barony" },
  { name: 'random', description: 'a random effect, random = { chance = X modifier = Y effects... }', supportedScopes: ['none'], syntax: "where X is a chance of the enclosed effects being fired and can be modified by optional value modifier list (AKA MTTH) Y" },
  { name: 'random_accolade_type', description: 'Iterate through every accolade_type in the database', supportedScopes: ['none'], supportedTargets: ['accolade_type'], outputScope: 'accolade_type', isIterator: true, syntax: "random_accolade_type = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_active_dynasty', description: 'Iterate through all dynasties with dynasty head', supportedScopes: ['none'], supportedTargets: ['dynasty'], outputScope: 'dynasty', isIterator: true, syntax: "random_active_dynasty = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_activity', description: 'Iterate through all activities in the world', supportedScopes: ['none'], supportedTargets: ['activity'], outputScope: 'activity', isIterator: true, syntax: "random_activity = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_activity_type', description: 'Iterate through every activity_type in the database', supportedScopes: ['none'], supportedTargets: ['activity_type'], outputScope: 'activity_type', isIterator: true, syntax: "random_activity_type = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_artifact', description: 'Iterate through all existing artifacts', supportedScopes: ['none'], supportedTargets: ['artifact'], outputScope: 'artifact', isIterator: true, syntax: "random_artifact = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_barony', description: 'Iterate through all baronies in the game', supportedScopes: ['none'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_barony = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_casus_belli_type', description: 'Iterate through every casus_belli_type in the database', supportedScopes: ['none'], supportedTargets: ['casus_belli_type'], outputScope: 'casus_belli_type', isIterator: true, syntax: "random_casus_belli_type = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_character_with_royal_court', description: 'Iterate through all characters with a royal court', supportedScopes: ['none'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_character_with_royal_court = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_completed_legend', description: 'Gets all legends in the world that have been completed', supportedScopes: ['none'], supportedTargets: ['legend'], outputScope: 'legend', isIterator: true, syntax: "random_completed_legend = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_confederation', description: 'List all confederations', supportedScopes: ['none'], supportedTargets: ['confederation'], outputScope: 'confederation', isIterator: true, syntax: "random_confederation = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_confederation_type', description: 'Iterate through every confederation_type in the database', supportedScopes: ['none'], supportedTargets: ['confederation_type'], outputScope: 'confederation_type', isIterator: true, syntax: "random_confederation_type = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_county', description: 'Iterate through all counties in the game', supportedScopes: ['none'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_county = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_county_in_region', description: 'Iterate through all counties in the region. Put \'region = region_name\' inside it', supportedScopes: ['none'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_county_in_region = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_court_position_type', description: 'Iterate through every court_position_type in the database', supportedScopes: ['none'], supportedTargets: ['court_position_type'], outputScope: 'court_position_type', isIterator: true, syntax: "random_court_position_type = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_culture_global', description: 'Iterate through all cultures in the game', supportedScopes: ['none'], supportedTargets: ['culture'], outputScope: 'culture', isIterator: true, syntax: "random_culture_global = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_culture_innovation', description: 'Iterate through every culture_innovation in the database', supportedScopes: ['none'], supportedTargets: ['culture_innovation'], outputScope: 'culture_innovation', isIterator: true, syntax: "random_culture_innovation = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_culture_pillar', description: 'Iterate through every culture_pillar in the database', supportedScopes: ['none'], supportedTargets: ['culture_pillar'], outputScope: 'culture_pillar', isIterator: true, syntax: "random_culture_pillar = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_culture_tradition', description: 'Iterate through every culture_tradition in the database', supportedScopes: ['none'], supportedTargets: ['culture_tradition'], outputScope: 'culture_tradition', isIterator: true, syntax: "random_culture_tradition = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_decision', description: 'Iterate through every decision in the database', supportedScopes: ['none'], supportedTargets: ['decision'], outputScope: 'decision', isIterator: true, syntax: "random_decision = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_doctrine', description: 'Iterate through every doctrine in the database', supportedScopes: ['none'], supportedTargets: ['doctrine'], outputScope: 'doctrine', isIterator: true, syntax: "random_doctrine = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_domicile', description: 'Iterate through all domiciles', supportedScopes: ['none'], supportedTargets: ['domicile'], outputScope: 'domicile', isIterator: true, syntax: "random_domicile = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_duchy', description: 'Iterate through all duchies in the game', supportedScopes: ['none'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_duchy = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_dynasty', description: 'Iterate through all dynasties (even those without head)', supportedScopes: ['none'], supportedTargets: ['dynasty'], outputScope: 'dynasty', isIterator: true, syntax: "random_dynasty = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_empire', description: 'Iterate through all empires in the game', supportedScopes: ['none'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_empire = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_epidemic', description: 'Gets all epidemics in the world', supportedScopes: ['none'], supportedTargets: ['epidemic'], outputScope: 'epidemic', isIterator: true, syntax: "random_epidemic = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_epidemic_type', description: 'Iterate through every epidemic_type in the database', supportedScopes: ['none'], supportedTargets: ['epidemic_type'], outputScope: 'epidemic_type', isIterator: true, syntax: "random_epidemic_type = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_geographical_region', description: 'Iterate through every geographical_region in the database', supportedScopes: ['none'], supportedTargets: ['geographical_region'], outputScope: 'geographical_region', isIterator: true, syntax: "random_geographical_region = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_government_type', description: 'Iterate through every government_type in the database', supportedScopes: ['none'], supportedTargets: ['government_type'], outputScope: 'government_type', isIterator: true, syntax: "random_government_type = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_great_project', description: 'Iterate through all active Great Projects.', supportedScopes: ['none'], supportedTargets: ['great_project'], outputScope: 'great_project', isIterator: true, syntax: "random_great_project = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_great_project_type', description: 'Iterate through every great_project_type in the database', supportedScopes: ['none'], supportedTargets: ['great_project_type'], outputScope: 'great_project_type', isIterator: true, syntax: "random_great_project_type = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_hegemony', description: 'Iterate through all hegemonies in the game', supportedScopes: ['none'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_hegemony = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_holding_type', description: 'Iterate through every holding_type in the database', supportedScopes: ['none'], supportedTargets: ['holding_type'], outputScope: 'holding_type', isIterator: true, syntax: "random_holding_type = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_house_aspiration', description: 'Iterate through every house_aspiration in the database', supportedScopes: ['none'], supportedTargets: ['house_aspiration'], outputScope: 'house_aspiration', isIterator: true, syntax: "random_house_aspiration = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_house_relation_level', description: 'Iterate through every house_relation_level in the database', supportedScopes: ['none'], supportedTargets: ['house_relation_level'], outputScope: 'house_relation_level', isIterator: true, syntax: "random_house_relation_level = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_house_relation_type', description: 'Iterate through every house_relation_type in the database', supportedScopes: ['none'], supportedTargets: ['house_relation_type'], outputScope: 'house_relation_type', isIterator: true, syntax: "random_house_relation_type = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_important_location', description: 'Iterate through all counties that are important for at least some title', supportedScopes: ['none'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_important_location = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_in_global_list', description: 'Iterate through all items in global list. list = name or variable = name', supportedScopes: ['none'], isIterator: true, syntax: "random_in_global_list = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_in_list', description: 'Iterate through all items in list. list = name or variable = name', supportedScopes: ['none'], isIterator: true, syntax: "random_in_list = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_in_local_list', description: 'Iterate through all items in local list. list = name or variable = name', supportedScopes: ['none'], isIterator: true, syntax: "random_in_local_list = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_independent_ruler', description: 'Independent rulers list with a COUNT tier or above who hold land', supportedScopes: ['none'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_independent_ruler = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_inspiration', description: 'Iterate through all inspirations in the world', supportedScopes: ['none'], supportedTargets: ['inspiration'], outputScope: 'inspiration', isIterator: true, syntax: "random_inspiration = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_inspired_character', description: 'Iterate through all characters with an inspirations in the world', supportedScopes: ['none'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_inspired_character = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_interested_title', description: 'Iterate through all titles that are interested in any county', supportedScopes: ['none'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_interested_title = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_kingdom', description: 'Iterate through all kingdoms in the game', supportedScopes: ['none'], supportedTargets: ['landed_title'], outputScope: 'landed_title', isIterator: true, syntax: "random_kingdom = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_legend', description: 'Gets all legends in the world that have not been completed', supportedScopes: ['none'], supportedTargets: ['legend'], outputScope: 'legend', isIterator: true, syntax: "random_legend = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_legend_type', description: 'Iterate through every legend_type in the database', supportedScopes: ['none'], supportedTargets: ['legend_type'], outputScope: 'legend_type', isIterator: true, syntax: "random_legend_type = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_list', description: 'a random list effect', supportedScopes: ['none'], isIterator: true, syntax: "random_list = { X1 = { trigger = { enables/disable this effect} modifier/compare_modifier/opinion_modifier = Y1 effect1 } X2 = { trigger = { enables/disable this effect} modifier/compare_modifier/opinion_modifier = Y2 effect2 } ... }\nSelects one effect from the list and fires it. The effects are weighted by numbers X1, X2... (the higher the number, the higher the chance of the effect being picked).\nThe chances can be modified by optional value modifier lists Y1, Y2... (AKA MTTH)" },
  { name: 'random_living_character', description: 'Iterate through all living characters', supportedScopes: ['none'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_living_character = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_log_scopes', description: 'Log the current scope to the random log when this effect executes. Only use temprorarily for debugging purposes as it can introduce localized strings into the Scopes._Random log. yes = full scope info, no=only current scope', supportedScopes: ['none'], isIterator: true },
  { name: 'random_mercenary_company', description: 'Iterate through all mercenary companies', supportedScopes: ['none'], supportedTargets: ['mercenary_company'], outputScope: 'mercenary_company', isIterator: true, syntax: "random_mercenary_company = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_open_invite_activity', description: 'Iterate through all open invite activities in the world', supportedScopes: ['none'], supportedTargets: ['activity'], outputScope: 'activity', isIterator: true, syntax: "random_open_invite_activity = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_player', description: 'Iterate through all player characters', supportedScopes: ['none'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_player = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_pool_character', description: 'Iterate through all characters in the pool of the given province', supportedScopes: ['none'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_pool_character = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_province', description: 'Iterate through all provinces (skips non-land and impassable provinces)', supportedScopes: ['none'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, syntax: "random_province = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_religion_global', description: 'Iterate through all religions in the game', supportedScopes: ['none'], supportedTargets: ['religion'], outputScope: 'religion', isIterator: true, syntax: "random_religion_global = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_ruler', description: 'Rulers list with a COUNT tier o above', supportedScopes: ['none'], supportedTargets: ['character'], outputScope: 'character', isIterator: true, syntax: "random_ruler = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_special_building_province', description: 'Iterate through all provinces with a special building slot (built or un-built)', supportedScopes: ['none'], supportedTargets: ['province'], outputScope: 'province', isIterator: true, syntax: "random_special_building_province = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_task_contract', description: 'Gets all available and accepted task contracts.', supportedScopes: ['none'], supportedTargets: ['task_contract'], outputScope: 'task_contract', isIterator: true, syntax: "Optionally specify a contract type filter\nany_task_contract = { task_contract_type = laamp_raid_contract }\nrandom_task_contract = { limit = { <triggers> } (optional) weight = { mtth } <effects> }", parameters: ['any_task_contract'] },
  { name: 'random_task_contract_type', description: 'Iterate through every task_contract_type in the database', supportedScopes: ['none'], supportedTargets: ['task_contract_type'], outputScope: 'task_contract_type', isIterator: true, syntax: "random_task_contract_type = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_trait', description: 'Iterate through every trait in the database', supportedScopes: ['none'], supportedTargets: ['trait'], outputScope: 'trait', isIterator: true, syntax: "random_trait = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'random_trait_in_category', description: 'Iterate through all traits in a given category', supportedScopes: ['none'], supportedTargets: ['trait'], outputScope: 'trait', isIterator: true, syntax: "any_trait_in_category = { category = fame/health/etc }\nrandom_trait_in_category = { limit = { <triggers> } (optional) weight = { mtth } <effects> }", parameters: ['any_trait_in_category'] },
  { name: 'random_vassal_contract', description: 'Iterate through every vassal_contract in the database', supportedScopes: ['none'], supportedTargets: ['vassal_contract'], outputScope: 'vassal_contract', isIterator: true, syntax: "random_vassal_contract = { limit = { <triggers> } (optional) weight = { mtth } <effects> }" },
  { name: 'raze_county', description: 'Changes the county capital province holding to the designated type. If purge_secondary_holdings = yes, then all secondary province holdings in the county will be destroyed, unless their holding type is excluded with excluded_holding_type = <holding_type>', supportedScopes: ['none'], syntax: "scope:county_title = {\nraze_county = {\nholding_type = nomad_holding\npurge_secondary_holdings = yes (optional, default = no)\nexcluded_holding_type = temple_holding (optional, can be repeated)\n}\n}", parameters: ['holding_type', 'purge_secondary_holdings', 'excluded_holding_type'] },
  { name: 'recalculate_cultural_heads_of_type', description: 'Forces a recalculation of heads of provided determination type', supportedScopes: ['none'], syntax: "recalculate_cultural_heads_of_type = herd\ndomain, herd" },
  { name: 'remove_from_list', description: 'Removes the current scope from a named list remove_from_list = <string>', supportedScopes: ['none'] },
  { name: 'remove_global_variable', description: 'Removes a variable', supportedScopes: ['none'], syntax: "remove_variable = variable_name", parameters: ['remove_variable'] },
  { name: 'remove_list_global_variable', description: 'Removes the target from a variable list', supportedScopes: ['none'], syntax: "remove_list_variable = { name = X target = Y }\nWhere X is the name of the variable\nWhere Y is an event target", parameters: ['remove_list_variable'] },
  { name: 'remove_list_local_variable', description: 'Removes the target from a variable list', supportedScopes: ['none'], syntax: "remove_list_variable = { name = X target = Y }\nWhere X is the name of the variable\nWhere Y is an event target", parameters: ['remove_list_variable'] },
  { name: 'remove_list_variable', description: 'Removes the target from a variable list', supportedScopes: ['none'], syntax: "remove_list_variable = { name = X target = Y }\nWhere X is the name of the variable\nWhere Y is an event target" },
  { name: 'remove_local_variable', description: 'Removes a variable', supportedScopes: ['none'], syntax: "remove_variable = variable_name", parameters: ['remove_variable'] },
  { name: 'remove_title_law', description: 'remove law from scoped title. This will leave the law group empty, so only do this if you\'re getting rid of a law group. DOES NOT apply law removal costs and effects.', supportedScopes: ['none'], syntax: "remove_title_law = princely_elective_succession_law" },
  { name: 'remove_title_law_effects', description: 'remove law from scoped title. This will leave the law group empty, so only do this if you\'re getting rid of a law group. DOES apply law removal costs and effects.', supportedScopes: ['none'], syntax: "remove_title_law = princely_elective_succession_law", parameters: ['remove_title_law'] },
  { name: 'remove_variable', description: 'Removes a variable', supportedScopes: ['none'], syntax: "remove_variable = variable_name" },
  { name: 'resolve_title_and_vassal_change', description: 'resolve_title_and_vassal_change = scope:change', supportedScopes: ['none'], supportedTargets: ['title_and_vassal_change'], syntax: "Execute and destory the target title and vassal change, the change cannot be used after calling this effect" },
  { name: 'round_global_variable', description: 'Rounds a variable to the nearest specified value', supportedScopes: ['none'], syntax: "round_variable = { name = X nearest = Y }\nWhere X is the name of the variable\nWhere Y is a script value", parameters: ['round_variable'] },
  { name: 'round_local_variable', description: 'Rounds a variable to the nearest specified value', supportedScopes: ['none'], syntax: "round_variable = { name = X nearest = Y }\nWhere X is the name of the variable\nWhere Y is a script value", parameters: ['round_variable'] },
  { name: 'round_variable', description: 'Rounds a variable to the nearest specified value', supportedScopes: ['none'], syntax: "round_variable = { name = X nearest = Y }\nWhere X is the name of the variable\nWhere Y is a script value" },
  { name: 'run_interaction', description: 'Execute/send the given interaction', supportedScopes: ['none'], syntax: "interaction = interaction_key - the interaction object key to run\nredirect = [yes|no] - yes by default, redirect the actor and recipients ( only works if secondary_actor and secondary_recipient are not setup or are invalid)\nactor = character_actor - must be defined\nrecipient = character_actor - must be defined\nsecondary_actor = character_secontary_actor - optional\nsecondary_recipient = character_secondary_recipient - optional\nexecute_threshold = accept/maybe/decline - will be executed immediately if the AI response is at least this\nsend_threshold = accept/maybe/decline - will be sent if the AI response is at least this\nAt least one of execute_threshold and send_threshold must be set", parameters: ['interaction', 'redirect', 'actor', 'recipient', 'secondary_actor', 'secondary_recipient', 'execute_threshold', 'send_threshold'] },
  { name: 'save_opinion_value_as', description: 'Saves the scoped character\'s opinion of the target character as an arbitrarily-named target to be referenced later in the (unbroken) event chain', supportedScopes: ['none'], syntax: "save_opinion_value_as = { name = <string> target = x }" },
  { name: 'save_scope_as', description: 'Saves the current scope as an arbitrarily-named target to be referenced later in the (unbroken) event chain', supportedScopes: ['none'], syntax: "save_event_target_as = <string>", parameters: ['save_event_target_as'] },
  { name: 'save_scope_value_as', description: 'Saves a numerical or bool value as an arbitrarily-named target to be referenced later in the (unbroken) event chain', supportedScopes: ['none'], syntax: "save_scope_value_as = { name = <string> value = x }" },
  { name: 'save_temporary_opinion_value_as', description: 'Saves the scoped character\'s opinion of the target character as an arbitrarily-named target to be referenced later in the in the same effect', supportedScopes: ['none'], syntax: "save_temporary_opinion_value_as = { name = <string> target = x" },
  { name: 'save_temporary_scope_as', description: 'Saves the current scope as an arbitrarily-named temporary target to be referenced later in the same effect', supportedScopes: ['none'], syntax: "save_temporary_event_target_as = <string>", parameters: ['save_temporary_event_target_as'] },
  { name: 'save_temporary_scope_value_as', description: 'Saves a numerical or bool value as an arbitrarily-named temporary target to be referenced later in the same effect', supportedScopes: ['none'], syntax: "save_temporary_scope_value_as = { name = <string> value = x }" },
  { name: 'send_china_tutorial_finished_telemetry', description: 'Sends a tutorial_finished telemetry event with China version parameter', supportedScopes: ['none'] },
  { name: 'send_china_tutorial_started_telemetry', description: 'Sends a tutorial_started telemetry event with China version parameter', supportedScopes: ['none'] },
  { name: 'send_long_tutorial_finished_telemetry', description: 'Sends a tutorial_finished telemetry event with Long version parameter', supportedScopes: ['none'] },
  { name: 'send_long_tutorial_started_telemetry', description: 'Sends a tutorial_started telemetry event with Long version parameter', supportedScopes: ['none'] },
  { name: 'send_short_tutorial_finished_telemetry', description: 'Sends a tutorial_finished telemetry event with Short version parameter', supportedScopes: ['none'] },
  { name: 'send_short_tutorial_started_telemetry', description: 'Sends a tutorial_started telemetry event with Short version parameter', supportedScopes: ['none'] },
  { name: 'set_focus_progress', description: 'Sets focus progress', supportedScopes: ['none'] },
  { name: 'set_generated_asexuality_chance', description: 'Sets the chance for a generated character to be asexual', supportedScopes: ['none'], syntax: "set_generated_asexuality_chance = 20" },
  { name: 'set_generated_bisexuality_chance', description: 'Sets the chance for a generated character to be bisexual', supportedScopes: ['none'], syntax: "set_generated_bisexuality_chance = 20" },
  { name: 'set_generated_homosexuality_chance', description: 'Sets the chance for a generated character to be homosexual', supportedScopes: ['none'], syntax: "set_generated_homosexuality_chance = 20" },
  { name: 'set_global_variable', description: 'Sets a variable', supportedScopes: ['none'], syntax: "set_variable = { name = X value = Y days = Z }\nWhere X is the name of the variable used to then access it\nWhere Y is any event target, bool, value, script value or flag (flag:W)\nAn optional days where Z is the number of days or script value\nThis variable will be accessible with <type_>var:X. With type being in a scope object or in a top scope\nCan also be used as set_variable = X (equivalent to set_variable = { name = X value = yes })", parameters: ['set_variable'] },
  { name: 'set_local_variable', description: 'Sets a variable', supportedScopes: ['none'], syntax: "set_variable = { name = X value = Y days = Z }\nWhere X is the name of the variable used to then access it\nWhere Y is any event target, bool, value, script value or flag (flag:W)\nAn optional days where Z is the number of days or script value\nThis variable will be accessible with <type_>var:X. With type being in a scope object or in a top scope\nCan also be used as set_variable = X (equivalent to set_variable = { name = X value = yes })", parameters: ['set_variable'] },
  { name: 'set_pregnancy_gender', description: 'Set the gender of the unborn child', supportedScopes: ['none'], syntax: "set_pregnancy_gender = female/male/random" },
  { name: 'set_ruler_objective_decision', description: 'Make characters ruler objective to be the give decision.', supportedScopes: ['none'], syntax: "This will provide additional advice if the decision supports it.\nusage:\nsome_character = {\nset_ruler_objective_decision = <decision>\n}", parameters: ['some_character'] },
  { name: 'set_variable', description: 'Sets a variable', supportedScopes: ['none'], syntax: "set_variable = { name = X value = Y days = Z }\nWhere X is the name of the variable used to then access it\nWhere Y is any event target, bool, value, script value or flag (flag:W)\nAn optional days where Z is the number of days or script value\nThis variable will be accessible with <type_>var:X. With type being in a scope object or in a top scope\nCan also be used as set_variable = X (equivalent to set_variable = { name = X value = yes })" },
  { name: 'setup_claim_cb', description: 'This effect will add a scope:cb_prestige_factor with a value based on what\'s being taken', supportedScopes: ['none'], syntax: "Won't steal land from people not vassalized\nsetup_claim_cb = {\nattacker = scope:attacker\ndefender = scope:defender\nclaimant = scope:claimant\nchange = scope:change\nvictory = yes/no\ntake_occupied = yes/no\n# Will vassalize people based on their capital location rather than being fully contained.\ncivil_war = yes\n}", parameters: ['attacker', 'defender', 'claimant', 'change', 'victory', 'take_occupied', 'civil_war'] },
  { name: 'setup_de_jure_cb', description: 'This effect will add a scope:cb_prestige_factor with a value based on what\'s being taken', supportedScopes: ['none'], syntax: "setup_de_jure_cb = {\nattacker = scope:attacker\ndefender = scope:defender\nchange = scope:change\nvictory = yes/no\n# Optional; will make it target a specific dejure title rather than *everything* that is dejure the attacker's\ntitle = scope:title\n}", parameters: ['attacker', 'defender', 'change', 'victory', 'title'] },
  { name: 'setup_invasion_cb', description: 'This effect will add a scope:cb_prestige_factor with a value based on what\'s being taken', supportedScopes: ['none'], syntax: "setup_invasion_cb = {\nattacker = scope:attacker\ndefender = scope:defender\nchange = scope:change\nvictory = yes/no\ntake_occupied = yes/no\n}", parameters: ['attacker', 'defender', 'change', 'victory', 'take_occupied'] },
  { name: 'show_as_tooltip', description: 'Effect only shown in tooltips (but not executed)', supportedScopes: ['none'] },
  { name: 'start_situation', description: 'Start a Situation of a specific situation type, optionally in a specific starting phase.', supportedScopes: ['none'], syntax: "You can also optionally override named sub-regions with custom data.\nstart_situation = {\ntype = X\n<start_phase = Y>\n<save_scope_as = scope_name>\n<save_temporary_scope_as = scope_name>\nsub_region = {\nkey = my_sub_region\n<start_phase = my_first_phase>\n<geographical_regions = { ... }>\n<map_color = { 0 0 0 }>\n}\nsub_region = {\n...\n}\n}", parameters: ['type', 'sub_region'] },
  { name: 'start_struggle', description: 'Start a struggle, start_struggle = { struggle_type = X start_phase = Y }where X is a struggle type, Y is a phase', supportedScopes: ['none'] },
  { name: 'start_tutorial_lesson', description: 'Starts the tutorial lesson with the given key. Does nothing if the tutorial is not running, the lesson is completed (or already running), or the lesson cannot be triggered (e.g. trigger fails)', supportedScopes: ['none'] },
  { name: 'stats_log', description: 'Log key value pairs to a given category via the elastic logging statistics', supportedScopes: ['none'], syntax: "stats_log = { category = string <string> = <loc_key> }\nThe loc keys will have ROOT, SCOPE, THIS, and PREV available" },
  { name: 'switch', description: 'Switch on a trigger for the evaluation of another trigger with an optional fallback trigger.', supportedScopes: ['none'], syntax: "switch = {\ntrigger = simple_assign_trigger\ncase_1 = { <effects> }\ncase_2 = { <effects> }\ncase_n = { <effects> }\nfallback = { <effects> }", parameters: ['case_1', 'case_2', 'case_n', 'fallback'] },
  { name: 'trigger_event', description: 'triggers an event or on_action', supportedScopes: ['none'], syntax: "trigger_event = {\nid = <event ID>                               # or:\non_action = <on_action name>                  # or:\nsaved_event_id = <event target with event ID> # example: scope:my_flag_name\n# optionally, the event can be delayed via one of those choices:    days/months/years = <num>\ndays/months/years = { <num> <num> }           # pick a value randomly from the range\ntrigger_on_next_date = \"<year>.<month>.<day>\" # trigger on a specific date in the future\ntrigger_on_next_date = \"<month>.<day>\"        # trigger the next time this date is reached (this or next year)\ndelayed = yes                                 # delay to the next tick\n}", parameters: ['id', 'on_action', 'saved_event_id', 'trigger_on_next_date', 'delayed'] },
  { name: 'try_create_important_action', description: 'Tries to create an important action notification. Will keep the current one if already exists.', supportedScopes: ['none'], syntax: "important_action_type = important_action_type_key - the important action object key to create. Must be defined.\nscope_name = object - optional, saves the object as the named scope to be be used by the important action effect", parameters: ['important_action_type', 'scope_name'] },
  { name: 'try_create_suggestion', description: 'Tries to create an suggestuib notification. Will keep the current one if already exists.', supportedScopes: ['none'], syntax: "suggestion_type = suggestion_type_key - the suggestion action object key to create. Must be defined.\nactor = character_actor - optional, can be used by the suggestion effect\nrecipient = character_actor - optional, can be used by the suggestion effect\nsecondary_actor = character_secondary_actor - optional, can be used by the suggestion effect\nsecondary_recipient = character_secondary_recipient - optional, can be used by the suggestion effect\nlanded_title = landed_title - optional, can be used by the suggestion effect", parameters: ['suggestion_type', 'actor', 'recipient', 'secondary_actor', 'secondary_recipient', 'landed_title'] },
  { name: 'while', description: 'Repeats enclosed effects while limit criteria are met or until set iteration count is reached', supportedScopes: ['none'], syntax: "while = { limit = { <triggers> } <effects> }\nwhile = { count = 3 <effects> }\nDefault max of 1000." },
];

/**
 * All effects combined
 */
export const allEffects: EffectDefinition[] = [
  ...characterEffects,
  ...landedtitleEffects,
  ...provinceEffects,
  ...dynastyEffects,
  ...dynastyhouseEffects,
  ...cultureEffects,
  ...faithEffects,
  ...religionEffects,
  ...armyEffects,
  ...schemeEffects,
  ...warEffects,
  ...activityEffects,
  ...artifactEffects,
  ...secretEffects,
  ...factionEffects,
  ...holyorderEffects,
  ...inspirationEffects,
  ...storyEffects,
  ...casusbelliEffects,
  ...travelplanEffects,
  ...struggleEffects,
  ...legendEffects,
  ...accoladeEffects,
  ...epidemicEffects,
  ...taskcontractEffects,
  ...situationEffects,
  ...situationsubregionEffects,
  ...taxslotEffects,
  ...domicileEffects,
  ...greatprojectEffects,
  ...confederationEffects,
  ...houserelationEffects,
  ...generalEffects,
];

/**
 * Get effects valid for a specific scope
 */
export function getEffectsForScope(scope: ScopeType): EffectDefinition[] {
  return allEffects.filter(effect => {
    if (effect.supportedScopes.includes('none')) return true;
    return effect.supportedScopes.includes(scope);
  });
}

/**
 * Build a map for quick lookup
 */
export const effectsMap = new Map<string, EffectDefinition>(
  allEffects.map(e => [e.name, e])
);
